<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>NIO学习笔记分享 | 读万卷书的桃</title><meta name="keywords" content="Java"><meta name="author" content="DoublePeach"><meta name="copyright" content="DoublePeach"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="花了三天的时间把网络编程中的NIO模型学习了，现在将我学习过程中的笔记和心得整理分享出来，希望能帮助到别人或者未来的自己！">
<meta property="og:type" content="article">
<meta property="og:title" content="NIO学习笔记分享">
<meta property="og:url" content="https://github.com/DoublePeach/myblog/2023/07/09/NIO%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%88%86%E4%BA%AB/index.html">
<meta property="og:site_name" content="读万卷书的桃">
<meta property="og:description" content="花了三天的时间把网络编程中的NIO模型学习了，现在将我学习过程中的笔记和心得整理分享出来，希望能帮助到别人或者未来的自己！">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://github.com/DoublePeach/myblog/img/HuLi.jpg">
<meta property="article:published_time" content="2023-07-09T14:22:51.000Z">
<meta property="article:modified_time" content="2023-11-26T14:28:13.098Z">
<meta property="article:author" content="DoublePeach">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://github.com/DoublePeach/myblog/img/HuLi.jpg"><link rel="shortcut icon" href="/DoublePeach/myblog/img/headPic.jpg"><link rel="canonical" href="https://github.com/DoublePeach/myblog/2023/07/09/NIO%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%88%86%E4%BA%AB/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/DoublePeach/myblog/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/DoublePeach/myblog/',
  algolia: undefined,
  localSearch: {"path":"/DoublePeach/myblog/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'NIO学习笔记分享',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-11-26 22:28:13'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/DoublePeach/myblog/img/headPic.jpg" onerror="onerror=null;src='img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/DoublePeach/myblog/archives/"><div class="headline">文章</div><div class="length-num">24</div></a><a href="/DoublePeach/myblog/tags/"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/DoublePeach/myblog/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/DoublePeach/myblog/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/DoublePeach/myblog/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div><div class="menus_item"><a class="site-page" href="/DoublePeach/myblog/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/DoublePeach/myblog/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><span> 我的个人简历</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="http://viptao.love/"><i class="fa-fw fas fa-video"></i><span> 个人简历</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="http://viptao.love:8090"><i class="fa-fw fas fa-video"></i><span> IU-YunPan</span></a></li><li><a class="site-page child" href="/DoublePeach/myblog/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/DoublePeach/myblog/img/HuLi.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/DoublePeach/myblog/">读万卷书的桃</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/DoublePeach/myblog/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/DoublePeach/myblog/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div><div class="menus_item"><a class="site-page" href="/DoublePeach/myblog/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/DoublePeach/myblog/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><span> 我的个人简历</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="http://viptao.love/"><i class="fa-fw fas fa-video"></i><span> 个人简历</span></a></li><li><a class="site-page child" target="_blank" rel="noopener" href="http://viptao.love:8090"><i class="fa-fw fas fa-video"></i><span> IU-YunPan</span></a></li><li><a class="site-page child" href="/DoublePeach/myblog/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">NIO学习笔记分享</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-07-09T14:22:51.000Z" title="发表于 2023-07-09 22:22:51">2023-07-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-11-26T14:28:13.098Z" title="更新于 2023-11-26 22:28:13">2023-11-26</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/DoublePeach/myblog/categories/Java/">Java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">12.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>52分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="NIO学习笔记分享"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>花了三天的时间把网络编程中的NIO模型学习了，现在将我学习过程中的笔记和心得整理分享出来，希望能帮助到别人或者未来的自己！</p>
<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><h2 id="1-网络编程IO模型介绍"><a href="#1-网络编程IO模型介绍" class="headerlink" title="1.网络编程IO模型介绍"></a>1.网络编程IO模型介绍</h2><h2 id="1-）Blocking-IO"><a href="#1-）Blocking-IO" class="headerlink" title="1 ）Blocking IO"></a>1 ）Blocking IO</h2><h4 id="Blocking-IO也称为BIO，即同步阻塞IO。Java的io包基于流模型实现，提供了File、"><a href="#Blocking-IO也称为BIO，即同步阻塞IO。Java的io包基于流模型实现，提供了File、" class="headerlink" title="Blocking IO也称为BIO，即同步阻塞IO。Java的io包基于流模型实现，提供了File、"></a>Blocking IO也称为BIO，即同步阻塞IO。Java的io包基于流模型实现，提供了File、</h4><h4 id="FileInputStream、FileOutputStream等输入输出流的功能。Java的io包下提供的流操"><a href="#FileInputStream、FileOutputStream等输入输出流的功能。Java的io包下提供的流操" class="headerlink" title="FileInputStream、FileOutputStream等输入输出流的功能。Java的io包下提供的流操"></a>FileInputStream、FileOutputStream等输入输出流的功能。Java的io包下提供的流操</h4><h4 id="作，交互方式是同步且阻塞的方式，在输入输出流的操作进行读、写动作完成之"><a href="#作，交互方式是同步且阻塞的方式，在输入输出流的操作进行读、写动作完成之" class="headerlink" title="作，交互方式是同步且阻塞的方式，在输入输出流的操作进行读、写动作完成之"></a>作，交互方式是同步且阻塞的方式，在输入输出流的操作进行读、写动作完成之</h4><h4 id="前，线程会一直阻塞。因此io包中对流的操作容易造成性能的瓶颈。"><a href="#前，线程会一直阻塞。因此io包中对流的操作容易造成性能的瓶颈。" class="headerlink" title="前，线程会一直阻塞。因此io包中对流的操作容易造成性能的瓶颈。"></a>前，线程会一直阻塞。因此io包中对流的操作容易造成性能的瓶颈。</h4><h4 id="同样的，在java-net包下提供的部分网络API，如Socket、ServerSocket、"><a href="#同样的，在java-net包下提供的部分网络API，如Socket、ServerSocket、" class="headerlink" title="同样的，在java.net包下提供的部分网络API，如Socket、ServerSocket、"></a>同样的，在java.net包下提供的部分网络API，如Socket、ServerSocket、</h4><h4 id="HttpURLConnection等，进行网络通信时，也用到了java-io包下的流操作，因此也属"><a href="#HttpURLConnection等，进行网络通信时，也用到了java-io包下的流操作，因此也属" class="headerlink" title="HttpURLConnection等，进行网络通信时，也用到了java.io包下的流操作，因此也属"></a>HttpURLConnection等，进行网络通信时，也用到了java.io包下的流操作，因此也属</h4><h4 id="于同步且阻塞的IO行为。"><a href="#于同步且阻塞的IO行为。" class="headerlink" title="于同步且阻塞的IO行为。"></a>于同步且阻塞的IO行为。</h4><h2 id="2-）Non-Blocking-IO"><a href="#2-）Non-Blocking-IO" class="headerlink" title="2 ）Non Blocking IO"></a>2 ）Non Blocking IO</h2><h4 id="Non-Blocking-IO也称为NIO，即同步非阻塞IO。Java1-4中引入了NIO框架，在"><a href="#Non-Blocking-IO也称为NIO，即同步非阻塞IO。Java1-4中引入了NIO框架，在" class="headerlink" title="Non Blocking IO也称为NIO，即同步非阻塞IO。Java1.4中引入了NIO框架，在"></a>Non Blocking IO也称为NIO，即同步非阻塞IO。Java1.4中引入了NIO框架，在</h4><h4 id="java-nio包中提供了Channel、Selector、Buffer等抽象类，可以快速构建多路复用的"><a href="#java-nio包中提供了Channel、Selector、Buffer等抽象类，可以快速构建多路复用的" class="headerlink" title="java.nio包中提供了Channel、Selector、Buffer等抽象类，可以快速构建多路复用的"></a>java.nio包中提供了Channel、Selector、Buffer等抽象类，可以快速构建多路复用的</h4><h4 id="IO程序，用于提供更接近操作系统底层的高性能数据操作方式。"><a href="#IO程序，用于提供更接近操作系统底层的高性能数据操作方式。" class="headerlink" title="IO程序，用于提供更接近操作系统底层的高性能数据操作方式。"></a>IO程序，用于提供更接近操作系统底层的高性能数据操作方式。</h4><h2 id="3-）Asynchronous-IO"><a href="#3-）Asynchronous-IO" class="headerlink" title="3 ）Asynchronous IO"></a>3 ）Asynchronous IO</h2><h4 id="Asynchronous-IO也称为AIO，即异步非阻塞IO。Java7提供了改进版的NIO，引入了"><a href="#Asynchronous-IO也称为AIO，即异步非阻塞IO。Java7提供了改进版的NIO，引入了" class="headerlink" title="Asynchronous IO也称为AIO，即异步非阻塞IO。Java7提供了改进版的NIO，引入了"></a>Asynchronous IO也称为AIO，即异步非阻塞IO。Java7提供了改进版的NIO，引入了</h4><h4 id="异步非阻塞的IO，由操作系统完成后回调通知服务端程序启动线程去处理。"><a href="#异步非阻塞的IO，由操作系统完成后回调通知服务端程序启动线程去处理。" class="headerlink" title="异步非阻塞的IO，由操作系统完成后回调通知服务端程序启动线程去处理。"></a>异步非阻塞的IO，由操作系统完成后回调通知服务端程序启动线程去处理。</h4><h2 id="2-BIO的实现逻辑"><a href="#2-BIO的实现逻辑" class="headerlink" title="2.BIO的实现逻辑"></a>2.BIO的实现逻辑</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">܉᲋රᙙJavaරᎸᴺ ̓ݩռلဳىJavaຝ຅຾̈́ӥ᫹ಅํ᧞ᑕդᎱ᧞կ݊ૡٍ ᦏದ๞ࢧ୭๜ᧆํጱᕍᶉѺ</span><br></pre></td></tr></table></figure>

<h2 id="2-BIO的实现逻辑-1"><a href="#2-BIO的实现逻辑-1" class="headerlink" title="2.BIO的实现逻辑"></a>2.BIO的实现逻辑</h2><h4 id="在BIO同步阻塞模型下，一个服务端的可以开启多个处理线程来处理客户端的连"><a href="#在BIO同步阻塞模型下，一个服务端的可以开启多个处理线程来处理客户端的连" class="headerlink" title="在BIO同步阻塞模型下，一个服务端的可以开启多个处理线程来处理客户端的连"></a>在BIO同步阻塞模型下，一个服务端的可以开启多个处理线程来处理客户端的连</h4><h4 id="接，但是一个处理线程只能对应一个客户端的连接。"><a href="#接，但是一个处理线程只能对应一个客户端的连接。" class="headerlink" title="接，但是一个处理线程只能对应一个客户端的连接。"></a>接，但是一个处理线程只能对应一个客户端的连接。</h4><h4 id="客户端的实现"><a href="#客户端的实现" class="headerlink" title="客户端的实现"></a>客户端的实现</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">package com.qf.io.bio;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line">import java.io.OutputStream;</span><br><span class="line">import java.net.Socket;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 客户端</span><br><span class="line">* @author htt</span><br><span class="line">* doublepeach</span><br><span class="line">*/</span><br><span class="line">public class SocketClient &#123;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws IOException &#123;</span><br></pre></td></tr></table></figure>
<h5 id><a href="#" class="headerlink" title></a></h5><h4 id="单线程服务端的实现"><a href="#单线程服务端的实现" class="headerlink" title="单线程服务端的实现"></a>单线程服务端的实现</h4><h5 id="x2F-x2F-连接服务端"><a href="#x2F-x2F-连接服务端" class="headerlink" title="&#x2F;&#x2F;连接服务端"></a>&#x2F;&#x2F;连接服务端</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Socket socket = new Socket(&quot;localhost&quot;, 9090 );</span><br><span class="line">//发送数据</span><br><span class="line">OutputStream outputStream = socket.getOutputStream();</span><br><span class="line">outputStream.write(&quot;hello bio&quot;.getBytes());</span><br><span class="line">outputStream.flush();</span><br><span class="line">//接收服务端返回的数据</span><br><span class="line">InputStream inputStream = socket.getInputStream();</span><br><span class="line">byte[] bytes = new byte[ 1024 ];</span><br><span class="line">//阻塞等待服务端返回数据</span><br><span class="line">int len = inputStream.read(bytes);</span><br><span class="line">System.out.println(&quot;接收到服务端返回的数据：&quot;+new</span><br><span class="line">String(bytes, 0 ,len));</span><br><span class="line">//关闭连接</span><br><span class="line">socket.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="-1"><a href="#-1" class="headerlink" title></a></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">package com.qf.io.bio;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line">import java.net.ServerSocket;</span><br><span class="line">import java.net.Socket;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 单线程的服务端</span><br><span class="line">* @author htt</span><br><span class="line">* doublepeach</span><br><span class="line">*/</span><br><span class="line">public class SocketServerSingleThread &#123;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws IOException &#123;</span><br><span class="line">ServerSocket serverSocket = new ServerSocket( 9090 );</span><br></pre></td></tr></table></figure>
<h5 id="-2"><a href="#-2" class="headerlink" title></a></h5><h4 id="多线程服务端的实现"><a href="#多线程服务端的实现" class="headerlink" title="多线程服务端的实现"></a>多线程服务端的实现</h4><h4 id="为了解决单线程服务端的同步阻塞问题，BIO模型下可以让服务端使用多线程来同"><a href="#为了解决单线程服务端的同步阻塞问题，BIO模型下可以让服务端使用多线程来同" class="headerlink" title="为了解决单线程服务端的同步阻塞问题，BIO模型下可以让服务端使用多线程来同"></a>为了解决单线程服务端的同步阻塞问题，BIO模型下可以让服务端使用多线程来同</h4><h4 id="时处理多个客户端的请求。"><a href="#时处理多个客户端的请求。" class="headerlink" title="时处理多个客户端的请求。"></a>时处理多个客户端的请求。</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">while(true)&#123;</span><br><span class="line">System.out.println(&quot;等待客户端的连接&quot;);</span><br><span class="line">//阻塞等待</span><br><span class="line">Socket socket = serverSocket.accept();</span><br><span class="line">System.out.println(&quot;已有客户端连接&quot;);</span><br><span class="line">//开始处理</span><br><span class="line">InputStream is = socket.getInputStream();</span><br><span class="line">byte[] bytes = new byte[ 1024 ];</span><br><span class="line">//阻塞等待客户端发送数据</span><br><span class="line">int len = is.read(bytes);</span><br><span class="line">System.out.println(&quot;收到客户端的数据：&quot;+new</span><br><span class="line">String(bytes, 0 ,len));</span><br><span class="line">socket.getOutputStream().write(&quot;success&quot;.getBytes());</span><br><span class="line">socket.getOutputStream().flush();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">package com.qf.io.bio;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line">import java.net.ServerSocket;</span><br><span class="line">import java.net.Socket;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 单线程的服务端</span><br><span class="line">* @author htt</span><br><span class="line">* doublepeach</span><br><span class="line">*/</span><br><span class="line">public class SocketServerMultipleThread &#123;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws IOException &#123;</span><br></pre></td></tr></table></figure>

<h2 id="3-BIO的局限"><a href="#3-BIO的局限" class="headerlink" title="3.BIO的局限"></a>3.BIO的局限</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ServerSocket serverSocket = new ServerSocket( 9090 );</span><br><span class="line">while(true)&#123;</span><br><span class="line">System.out.println(&quot;等待客户端的连接&quot;);</span><br><span class="line">//阻塞等待</span><br><span class="line">Socket socket = serverSocket.accept();</span><br><span class="line">System.out.println(&quot;已有客户端连接&quot;);</span><br><span class="line">//开始处理</span><br><span class="line">new Thread(new Runnable() &#123;</span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">try &#123;</span><br><span class="line">handle(socket);</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;).start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private static void handle(Socket socket) throws IOException &#123;</span><br><span class="line">InputStream is = socket.getInputStream();</span><br><span class="line">byte[] bytes = new byte[ 1024 ];</span><br><span class="line">//阻塞等待客户端发送数据</span><br><span class="line">int len = is.read(bytes);</span><br><span class="line">System.out.println(&quot;收到客户端的数据：&quot;+new</span><br><span class="line">String(bytes, 0 ,len));</span><br><span class="line">socket.getOutputStream().write(&quot;success&quot;.getBytes());</span><br><span class="line">socket.getOutputStream().flush();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="在上面的例子中可以看出，IO代码里Read操作是阻塞操作，如果连接不做数据读写"><a href="#在上面的例子中可以看出，IO代码里Read操作是阻塞操作，如果连接不做数据读写" class="headerlink" title="在上面的例子中可以看出，IO代码里Read操作是阻塞操作，如果连接不做数据读写"></a>在上面的例子中可以看出，IO代码里Read操作是阻塞操作，如果连接不做数据读写</h4><h4 id="操作，会导致线程阻塞，浪费线程资源。"><a href="#操作，会导致线程阻塞，浪费线程资源。" class="headerlink" title="操作，会导致线程阻塞，浪费线程资源。"></a>操作，会导致线程阻塞，浪费线程资源。</h4><h4 id="除此之外，如果客户端请求过多，将会导致服务端不断创建出新的线程，对服务器"><a href="#除此之外，如果客户端请求过多，将会导致服务端不断创建出新的线程，对服务器" class="headerlink" title="除此之外，如果客户端请求过多，将会导致服务端不断创建出新的线程，对服务器"></a>除此之外，如果客户端请求过多，将会导致服务端不断创建出新的线程，对服务器</h4><h4 id="造成过大压力。"><a href="#造成过大压力。" class="headerlink" title="造成过大压力。"></a>造成过大压力。</h4><h2 id="4-BIO的应用场景"><a href="#4-BIO的应用场景" class="headerlink" title="4.BIO的应用场景"></a>4.BIO的应用场景</h2><h4 id="BIO方式的使用和维护相对比较简单，适用于较小且固定的应用框架。"><a href="#BIO方式的使用和维护相对比较简单，适用于较小且固定的应用框架。" class="headerlink" title="BIO方式的使用和维护相对比较简单，适用于较小且固定的应用框架。"></a>BIO方式的使用和维护相对比较简单，适用于较小且固定的应用框架。</h4><h1 id="二、NIO快速开始"><a href="#二、NIO快速开始" class="headerlink" title="二、NIO快速开始"></a>二、NIO快速开始</h1><h2 id="1-NIO概述"><a href="#1-NIO概述" class="headerlink" title="1.NIO概述"></a>1.NIO概述</h2><h4 id="NIO（Non-Blocking-IO）是同步非阻塞的IO，服务器可以使用一个线程来处理多个"><a href="#NIO（Non-Blocking-IO）是同步非阻塞的IO，服务器可以使用一个线程来处理多个" class="headerlink" title="NIO（Non Blocking IO）是同步非阻塞的IO，服务器可以使用一个线程来处理多个"></a>NIO（Non Blocking IO）是同步非阻塞的IO，服务器可以使用一个线程来处理多个</h4><h4 id="客户端请求，客户端发送的请求会注册到多路复用器Selector上，由多路复用器"><a href="#客户端请求，客户端发送的请求会注册到多路复用器Selector上，由多路复用器" class="headerlink" title="客户端请求，客户端发送的请求会注册到多路复用器Selector上，由多路复用器"></a>客户端请求，客户端发送的请求会注册到多路复用器Selector上，由多路复用器</h4><h4 id="Selector轮询各客户端的请求并进行处理。"><a href="#Selector轮询各客户端的请求并进行处理。" class="headerlink" title="Selector轮询各客户端的请求并进行处理。"></a>Selector轮询各客户端的请求并进行处理。</h4><h2 id="2-NIO线程模型"><a href="#2-NIO线程模型" class="headerlink" title="2.NIO线程模型"></a>2.NIO线程模型</h2><h4 id="NIO包含三大组件："><a href="#NIO包含三大组件：" class="headerlink" title="NIO包含三大组件："></a>NIO包含三大组件：</h4><h4 id="Channel通道：每个通道对应一个buffer缓冲区"><a href="#Channel通道：每个通道对应一个buffer缓冲区" class="headerlink" title="Channel通道：每个通道对应一个buffer缓冲区"></a>Channel通道：每个通道对应一个buffer缓冲区</h4><h4 id="Buffer缓冲区：buffer底层是数组，类似于蓄水池，channel就是水管"><a href="#Buffer缓冲区：buffer底层是数组，类似于蓄水池，channel就是水管" class="headerlink" title="Buffer缓冲区：buffer底层是数组，类似于蓄水池，channel就是水管"></a>Buffer缓冲区：buffer底层是数组，类似于蓄水池，channel就是水管</h4><h4 id="Selector选择器：selector对应一个或多个线程。channel会注册到selector上，由"><a href="#Selector选择器：selector对应一个或多个线程。channel会注册到selector上，由" class="headerlink" title="Selector选择器：selector对应一个或多个线程。channel会注册到selector上，由"></a>Selector选择器：selector对应一个或多个线程。channel会注册到selector上，由</h4><h4 id="selector根据channel读写事件的发生交给某个空闲线程来执行。"><a href="#selector根据channel读写事件的发生交给某个空闲线程来执行。" class="headerlink" title="selector根据channel读写事件的发生交给某个空闲线程来执行。"></a>selector根据channel读写事件的发生交给某个空闲线程来执行。</h4><h4 id="Buffer和Channel都是既可读也可写。"><a href="#Buffer和Channel都是既可读也可写。" class="headerlink" title="Buffer和Channel都是既可读也可写。"></a>Buffer和Channel都是既可读也可写。</h4><h2 id="3-NIO初体验"><a href="#3-NIO初体验" class="headerlink" title="3.NIO初体验"></a>3.NIO初体验</h2><h4 id="服务端程序"><a href="#服务端程序" class="headerlink" title="服务端程序"></a>服务端程序</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">package com.qf.io.nio;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line">import java.net.InetSocketAddress;</span><br><span class="line">import java.nio.ByteBuffer;</span><br><span class="line">import java.nio.channels.*;</span><br><span class="line">import java.nio.charset.StandardCharsets;</span><br><span class="line">import java.util.Iterator;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* NIO服务端</span><br><span class="line">* @author htt</span><br><span class="line">* doublepeach</span><br><span class="line">*/</span><br><span class="line">public class NIOServer &#123;</span><br><span class="line">public static void main(String[] args) throws IOException &#123;</span><br><span class="line">//创建服务端Socket通道，ServerSocketChannel</span><br><span class="line">ServerSocketChannel ssc = ServerSocketChannel.open();</span><br><span class="line">//设置为非阻塞方式</span><br><span class="line">ssc.configureBlocking(false);</span><br><span class="line">//设置端口号为 9090</span><br><span class="line">ssc.socket().bind(new InetSocketAddress( 9090 ));</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//创建Selector多路复用器</span><br><span class="line">Selector selector = Selector.open();</span><br><span class="line">//把ServerSocketChannel注册到Selector上，并且监听客户端的连接事</span><br><span class="line">件操作</span><br><span class="line">ssc.register(selector, SelectionKey.OP_ACCEPT);</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">while(true)&#123;</span><br><span class="line">System.out.println(&quot;等待事件发生&quot;);</span><br><span class="line">//轮询监听所有注册到selector上的channel的SelectionKey，此方</span><br><span class="line">法是阻塞的</span><br><span class="line">int select = selector.select();</span><br><span class="line">System.out.println(&quot;某个事件发生了&quot;);</span><br><span class="line">//获得所有发生事件的channel的key，遍历key的集合并处理每一个</span><br><span class="line">key的channel</span><br><span class="line">Iterator&lt;SelectionKey&gt; iterator =</span><br><span class="line">selector.selectedKeys().iterator();</span><br><span class="line">while(iterator.hasNext())&#123;</span><br><span class="line">SelectionKey key = iterator.next();</span><br><span class="line">handle(key);</span><br><span class="line">//删除本次处理的key，防止重复处理</span><br><span class="line">iterator.remove();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private static void handle(SelectionKey key) throws</span><br><span class="line">IOException &#123;</span><br><span class="line">//判断channel发生的是什么事件</span><br><span class="line">if(key.isAcceptable())&#123;</span><br><span class="line">System.out.println(&quot;有客户端连接了&quot;);</span><br><span class="line">//应为服务端在监听客户端的连接，所有获得ServerSocketChannel</span><br><span class="line">ServerSocketChannel ssc = (ServerSocketChannel)</span><br><span class="line">key.channel();</span><br><span class="line">//处理连接请求，建立SocketChannel。该方法是阻塞的，但该阻塞是</span><br><span class="line">在连接事件发生后⻢上执行的，相当于是非阻塞</span><br><span class="line">//且接收完后不需要阻塞等待客户端的读写操作</span><br></pre></td></tr></table></figure>

<h4 id="客户端程序"><a href="#客户端程序" class="headerlink" title="客户端程序"></a>客户端程序</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">SocketChannel sc = ssc.accept();</span><br><span class="line">//设置成非阻塞</span><br><span class="line">sc.configureBlocking(false);</span><br><span class="line">//注册读事件到Selector上，当读事件发生时（针对于服务端），触发</span><br><span class="line">事件</span><br><span class="line">sc.register(key.selector(),SelectionKey.OP_READ);</span><br><span class="line">&#125;else if(key.isReadable())&#123;</span><br><span class="line">System.out.println(&quot;有客户端向服务端写数据&quot;);</span><br><span class="line">//获得客户端和服务端之间的channel通道</span><br><span class="line">SocketChannel sc = (SocketChannel) key.channel();</span><br><span class="line">//创建Buffer</span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate( 1024 );</span><br><span class="line">//把数据读到buffer中。NIO非阻塞体现在此，read方法本身不会阻</span><br><span class="line">塞，且当read方法发生时一定是客户端做了发送数据的事情</span><br><span class="line">int len = sc.read(buffer);</span><br><span class="line">if(len!=- 1 )&#123;</span><br><span class="line">System.out.println(&quot;读到客户端发送的数据：&quot;+new</span><br><span class="line">String(buffer.array(), 0 ,len));</span><br><span class="line">&#125;</span><br><span class="line">//服务端返回数据给客户端</span><br><span class="line">ByteBuffer bufferToWrite = ByteBuffer.wrap(&quot;hello</span><br><span class="line">nio&quot;.getBytes());</span><br><span class="line">sc.write(bufferToWrite);</span><br><span class="line">//监听下一次事件，读或写</span><br><span class="line">key.interestOps(SelectionKey.OP_READ |</span><br><span class="line">SelectionKey.OP_WRITE);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">package com.qf.io.nio;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line">import java.net.InetSocketAddress;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import java.nio.ByteBuffer;</span><br><span class="line">import java.nio.channels.SelectionKey;</span><br><span class="line">import java.nio.channels.Selector;</span><br><span class="line">import java.nio.channels.SocketChannel;</span><br><span class="line">import java.util.Iterator;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* NIO客户端</span><br><span class="line">* @author htt</span><br><span class="line">* doublepeach</span><br><span class="line">*/</span><br><span class="line">public class NIOClient &#123;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws IOException &#123;</span><br><span class="line">//获得Channel通道</span><br><span class="line">SocketChannel channel = SocketChannel.open();</span><br><span class="line">//设置成非阻塞</span><br><span class="line">channel.configureBlocking(false);</span><br><span class="line">//获得多路复用器Selector</span><br><span class="line">Selector selector = Selector.open();</span><br><span class="line">//客户端连接服务器，需要在监听方法中调用channel的finishConnect()</span><br><span class="line">才能完成连接</span><br><span class="line">channel.connect(new InetSocketAddress(&quot;127.0.0.1&quot;, 9090 ));</span><br><span class="line">//将channel注册到Selector上，并且监听连接事件</span><br><span class="line">channel.register(selector, SelectionKey.OP_CONNECT);</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//轮询访问Selector</span><br><span class="line">while(true)&#123;</span><br><span class="line">//阻塞等待，实际上selector只对应着客户端这一个channel</span><br><span class="line">selector.select();</span><br><span class="line">Iterator&lt;SelectionKey&gt; iterator =</span><br><span class="line">selector.selectedKeys().iterator();</span><br><span class="line">//遍历所有的事件</span><br><span class="line">while(iterator.hasNext())&#123;</span><br><span class="line">SelectionKey key = iterator.next();</span><br><span class="line">if(key.isConnectable())&#123;</span><br><span class="line">//如果是连接</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SocketChannel socketChannel = (SocketChannel)</span><br><span class="line">key.channel();</span><br><span class="line">//如果是正在连接，则完成连接</span><br><span class="line">if(socketChannel.isConnectionPending())&#123;</span><br><span class="line">socketChannel.finishConnect();</span><br><span class="line">//设置成非阻塞</span><br><span class="line">socketChannel.configureBlocking(false);</span><br><span class="line">//给服务端发送消息</span><br><span class="line">ByteBuffer buffer = ByteBuffer.wrap(&quot;hello</span><br><span class="line">server&quot;.getBytes());</span><br><span class="line">//缓存区中的数据写到通道里</span><br><span class="line">socketChannel.write(buffer);</span><br><span class="line">//监听读事件，可以获取服务器返回的数据</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">socketChannel.register(selector,SelectionKey.OP_READ);</span><br><span class="line">&#125;</span><br><span class="line">&#125;else if(key.isReadable())&#123;</span><br><span class="line">//读服务端返回的数据</span><br><span class="line">SocketChannel socketChannel = (SocketChannel)</span><br><span class="line">key.channel();</span><br><span class="line">//创建缓冲区</span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate( 1024 );</span><br><span class="line">//读缓冲区中的数据</span><br><span class="line">int len = channel.read(buffer);</span><br><span class="line">if(len!=- 1 )&#123;</span><br><span class="line">System.out.println(&quot;服务端返回的数据：&quot;+new</span><br><span class="line">String(buffer.array(), 0 ,len));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br><span class="line">//删除本次处理的key，防止重复处理</span><br><span class="line">iterator.remove();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="通信逻辑"><a href="#通信逻辑" class="headerlink" title="通信逻辑"></a>通信逻辑</h4><h1 id="三、NIO-Channel详解"><a href="#三、NIO-Channel详解" class="headerlink" title="三、NIO-Channel详解"></a>三、NIO-Channel详解</h1><h2 id="1-Channel概述"><a href="#1-Channel概述" class="headerlink" title="1.Channel概述"></a>1.Channel概述</h2><h4 id="Channel即通道，表示打开IO设备的连接，比如打开到文件、Socket套接字的连接。"><a href="#Channel即通道，表示打开IO设备的连接，比如打开到文件、Socket套接字的连接。" class="headerlink" title="Channel即通道，表示打开IO设备的连接，比如打开到文件、Socket套接字的连接。"></a>Channel即通道，表示打开IO设备的连接，比如打开到文件、Socket套接字的连接。</h4><h4 id="在使用NIO时，必须要获取用于连接IO设备的通道以及用于容纳数据的缓冲区。通"><a href="#在使用NIO时，必须要获取用于连接IO设备的通道以及用于容纳数据的缓冲区。通" class="headerlink" title="在使用NIO时，必须要获取用于连接IO设备的通道以及用于容纳数据的缓冲区。通"></a>在使用NIO时，必须要获取用于连接IO设备的通道以及用于容纳数据的缓冲区。通</h4><h4 id="过操作缓冲区，实现对数据的处理。也就是说数据是保存在buffer缓冲区中的，需"><a href="#过操作缓冲区，实现对数据的处理。也就是说数据是保存在buffer缓冲区中的，需" class="headerlink" title="过操作缓冲区，实现对数据的处理。也就是说数据是保存在buffer缓冲区中的，需"></a>过操作缓冲区，实现对数据的处理。也就是说数据是保存在buffer缓冲区中的，需</h4><h4 id="要通过Channel来操作缓冲区中的数据。"><a href="#要通过Channel来操作缓冲区中的数据。" class="headerlink" title="要通过Channel来操作缓冲区中的数据。"></a>要通过Channel来操作缓冲区中的数据。</h4><h4 id="Channel相比IO流中的Stream更加高效，可以异步双向传输。"><a href="#Channel相比IO流中的Stream更加高效，可以异步双向传输。" class="headerlink" title="Channel相比IO流中的Stream更加高效，可以异步双向传输。"></a>Channel相比IO流中的Stream更加高效，可以异步双向传输。</h4><h4 id="Channel的主要实现类有以下几个："><a href="#Channel的主要实现类有以下几个：" class="headerlink" title="Channel的主要实现类有以下几个："></a>Channel的主要实现类有以下几个：</h4><h4 id="FileChannel：读写文件的通道"><a href="#FileChannel：读写文件的通道" class="headerlink" title="FileChannel：读写文件的通道"></a>FileChannel：读写文件的通道</h4><h4 id="SocketChannel：读写TCP网络数据的通道"><a href="#SocketChannel：读写TCP网络数据的通道" class="headerlink" title="SocketChannel：读写TCP网络数据的通道"></a>SocketChannel：读写TCP网络数据的通道</h4><h4 id="ServerSocketChannel：像web服务器一样，监听新进来的TCP连接，为连接创建"><a href="#ServerSocketChannel：像web服务器一样，监听新进来的TCP连接，为连接创建" class="headerlink" title="ServerSocketChannel：像web服务器一样，监听新进来的TCP连接，为连接创建"></a>ServerSocketChannel：像web服务器一样，监听新进来的TCP连接，为连接创建</h4><h4 id="SocketChannel"><a href="#SocketChannel" class="headerlink" title="SocketChannel"></a>SocketChannel</h4><h4 id="DatagramChannel：读写UDP网络数据的通道"><a href="#DatagramChannel：读写UDP网络数据的通道" class="headerlink" title="DatagramChannel：读写UDP网络数据的通道"></a>DatagramChannel：读写UDP网络数据的通道</h4><h2 id="2-FileChannel详解"><a href="#2-FileChannel详解" class="headerlink" title="2.FileChannel详解"></a>2.FileChannel详解</h2><h3 id="FileChannel介绍"><a href="#FileChannel介绍" class="headerlink" title="FileChannel介绍"></a>FileChannel介绍</h3><h4 id="用于读取、写入、映射和操作文件的通道。"><a href="#用于读取、写入、映射和操作文件的通道。" class="headerlink" title="用于读取、写入、映射和操作文件的通道。"></a>用于读取、写入、映射和操作文件的通道。</h4><h4 id="文件通道是连接到文件的可搜索字节通道。它在其文件中有一个当前位置，可以查"><a href="#文件通道是连接到文件的可搜索字节通道。它在其文件中有一个当前位置，可以查" class="headerlink" title="文件通道是连接到文件的可搜索字节通道。它在其文件中有一个当前位置，可以查"></a>文件通道是连接到文件的可搜索字节通道。它在其文件中有一个当前位置，可以查</h4><h4 id="询和修改。文件本身包含可变⻓度的字节序列，可以读取和写入，并且可以查询其"><a href="#询和修改。文件本身包含可变⻓度的字节序列，可以读取和写入，并且可以查询其" class="headerlink" title="询和修改。文件本身包含可变⻓度的字节序列，可以读取和写入，并且可以查询其"></a>询和修改。文件本身包含可变⻓度的字节序列，可以读取和写入，并且可以查询其</h4><h4 id="当前大小。当写入的字节超过其当前大小时，文件的大小增加；文件被截断时，其"><a href="#当前大小。当写入的字节超过其当前大小时，文件的大小增加；文件被截断时，其" class="headerlink" title="当前大小。当写入的字节超过其当前大小时，文件的大小增加；文件被截断时，其"></a>当前大小。当写入的字节超过其当前大小时，文件的大小增加；文件被截断时，其</h4><h4 id="大小会减小。文件还可能具有一些相关联的元数据，如访问权限、内容类型和上次"><a href="#大小会减小。文件还可能具有一些相关联的元数据，如访问权限、内容类型和上次" class="headerlink" title="大小会减小。文件还可能具有一些相关联的元数据，如访问权限、内容类型和上次"></a>大小会减小。文件还可能具有一些相关联的元数据，如访问权限、内容类型和上次</h4><h4 id="修改时间；此类不定义元数据访问的方法。"><a href="#修改时间；此类不定义元数据访问的方法。" class="headerlink" title="修改时间；此类不定义元数据访问的方法。"></a>修改时间；此类不定义元数据访问的方法。</h4><h4 id="除了熟悉的字节通道读、写和关闭操作外，此类还定义了以下文件特定操作："><a href="#除了熟悉的字节通道读、写和关闭操作外，此类还定义了以下文件特定操作：" class="headerlink" title="除了熟悉的字节通道读、写和关闭操作外，此类还定义了以下文件特定操作："></a>除了熟悉的字节通道读、写和关闭操作外，此类还定义了以下文件特定操作：</h4><h4 id="字节可以以不影响通道当前位置的方式在文件中的绝对位置读取或写入。"><a href="#字节可以以不影响通道当前位置的方式在文件中的绝对位置读取或写入。" class="headerlink" title="字节可以以不影响通道当前位置的方式在文件中的绝对位置读取或写入。"></a>字节可以以不影响通道当前位置的方式在文件中的绝对位置读取或写入。</h4><h4 id="文件的区域可以直接映射到存储器中；对于大型文件，这通常比调用通常的读"><a href="#文件的区域可以直接映射到存储器中；对于大型文件，这通常比调用通常的读" class="headerlink" title="文件的区域可以直接映射到存储器中；对于大型文件，这通常比调用通常的读"></a>文件的区域可以直接映射到存储器中；对于大型文件，这通常比调用通常的读</h4><h4 id="或写方法更有效。"><a href="#或写方法更有效。" class="headerlink" title="或写方法更有效。"></a>或写方法更有效。</h4><h4 id="对文件进行的更新可能会被强制输出到底层存储设备，以确保在系统崩溃时数"><a href="#对文件进行的更新可能会被强制输出到底层存储设备，以确保在系统崩溃时数" class="headerlink" title="对文件进行的更新可能会被强制输出到底层存储设备，以确保在系统崩溃时数"></a>对文件进行的更新可能会被强制输出到底层存储设备，以确保在系统崩溃时数</h4><h4 id="据不会丢失。"><a href="#据不会丢失。" class="headerlink" title="据不会丢失。"></a>据不会丢失。</h4><h4 id="字节可以从一个文件传输到另一个通道，反之亦然，许多操作系统都可以将其"><a href="#字节可以从一个文件传输到另一个通道，反之亦然，许多操作系统都可以将其" class="headerlink" title="字节可以从一个文件传输到另一个通道，反之亦然，许多操作系统都可以将其"></a>字节可以从一个文件传输到另一个通道，反之亦然，许多操作系统都可以将其</h4><h4 id="优化为直接从文件系统缓存进行非常快速的传输。"><a href="#优化为直接从文件系统缓存进行非常快速的传输。" class="headerlink" title="优化为直接从文件系统缓存进行非常快速的传输。"></a>优化为直接从文件系统缓存进行非常快速的传输。</h4><h4 id="文件的一个区域可以被锁定以防止其他程序访问。"><a href="#文件的一个区域可以被锁定以防止其他程序访问。" class="headerlink" title="文件的一个区域可以被锁定以防止其他程序访问。"></a>文件的一个区域可以被锁定以防止其他程序访问。</h4><h4 id="多个并发线程使用文件通道是安全的。根据通道接口的指定，可以随时调用close方"><a href="#多个并发线程使用文件通道是安全的。根据通道接口的指定，可以随时调用close方" class="headerlink" title="多个并发线程使用文件通道是安全的。根据通道接口的指定，可以随时调用close方"></a>多个并发线程使用文件通道是安全的。根据通道接口的指定，可以随时调用close方</h4><h4 id="法。在任何给定时间，只有一个涉及通道位置或可以改变其文件大小的操作正在进"><a href="#法。在任何给定时间，只有一个涉及通道位置或可以改变其文件大小的操作正在进" class="headerlink" title="法。在任何给定时间，只有一个涉及通道位置或可以改变其文件大小的操作正在进"></a>法。在任何给定时间，只有一个涉及通道位置或可以改变其文件大小的操作正在进</h4><h4 id="行；在第一个操作仍在进行时尝试发起第二个这样的操作将被阻止，直到第一个操"><a href="#行；在第一个操作仍在进行时尝试发起第二个这样的操作将被阻止，直到第一个操" class="headerlink" title="行；在第一个操作仍在进行时尝试发起第二个这样的操作将被阻止，直到第一个操"></a>行；在第一个操作仍在进行时尝试发起第二个这样的操作将被阻止，直到第一个操</h4><h4 id="作完成。其他行动，特别是采取明确立场的行动，可以同时进行；它们是否真的这"><a href="#作完成。其他行动，特别是采取明确立场的行动，可以同时进行；它们是否真的这" class="headerlink" title="作完成。其他行动，特别是采取明确立场的行动，可以同时进行；它们是否真的这"></a>作完成。其他行动，特别是采取明确立场的行动，可以同时进行；它们是否真的这</h4><h4 id="样做取决于底层实现，因此没有具体说明。"><a href="#样做取决于底层实现，因此没有具体说明。" class="headerlink" title="样做取决于底层实现，因此没有具体说明。"></a>样做取决于底层实现，因此没有具体说明。</h4><h2 id="FileChannel示例"><a href="#FileChannel示例" class="headerlink" title="FileChannel示例"></a>FileChannel示例</h2><h4 id="FileChannel读文件"><a href="#FileChannel读文件" class="headerlink" title="FileChannel读文件"></a>FileChannel读文件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">package com.qf.channel.file;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import java.io.FileNotFoundException;</span><br><span class="line">import java.io.RandomAccessFile;</span><br><span class="line">import java.nio.ByteBuffer;</span><br><span class="line">import java.nio.channels.FileChannel;</span><br><span class="line">import java.util.RandomAccess;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* FileChannel读文件</span><br><span class="line">* @author htt</span><br><span class="line">* doublepeach</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<h4 id="FileChannel写数据"><a href="#FileChannel写数据" class="headerlink" title="FileChannel写数据"></a>FileChannel写数据</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class Demo1 &#123;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">//创建随机访问流</span><br><span class="line">RandomAccessFile file = new</span><br><span class="line">RandomAccessFile(&quot;1.txt&quot;,&quot;rw&quot;);</span><br><span class="line">//获得FileChannel</span><br><span class="line">FileChannel fileChannel = file.getChannel();</span><br><span class="line">//创建Buffer</span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate( 1024 );</span><br><span class="line">//读取数据到buffer中</span><br><span class="line">int len = 0 ;</span><br><span class="line">while((len = fileChannel.read(buffer))!=- 1 )&#123;</span><br><span class="line">//将写模式切换成读模式</span><br><span class="line">buffer.flip();</span><br><span class="line">while(buffer.hasRemaining())&#123;</span><br><span class="line">System.out.print((char)buffer.get());</span><br><span class="line">&#125;</span><br><span class="line">buffer.clear();</span><br><span class="line">&#125;</span><br><span class="line">file.close();</span><br><span class="line">System.out.println(&#x27;\n&#x27;+&quot;读取完毕&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">package com.qf.channel.file;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import java.io.FileNotFoundException;</span><br><span class="line">import java.io.RandomAccessFile;</span><br><span class="line">import java.nio.ByteBuffer;</span><br><span class="line">import java.nio.channels.FileChannel;</span><br></pre></td></tr></table></figure>
<h5 id="1-2-3-4-5-6-7"><a href="#1-2-3-4-5-6-7" class="headerlink" title="1 2 3 4 5 6 7"></a>1 2 3 4 5 6 7</h5><h4 id="通道之间传输数据一"><a href="#通道之间传输数据一" class="headerlink" title="通道之间传输数据一"></a>通道之间传输数据一</h4><h5 id="x2F"><a href="#x2F" class="headerlink" title="&#x2F;**"></a>&#x2F;**</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">* FileChannel写数据</span><br><span class="line">* @author htt</span><br><span class="line">* doublepeach</span><br><span class="line">*/</span><br><span class="line">public class Demo2 &#123;</span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">//创建随机访问流</span><br><span class="line">RandomAccessFile file = new</span><br><span class="line">RandomAccessFile(&quot;2.txt&quot;,&quot;rw&quot;);</span><br><span class="line">//获得FileChannel</span><br><span class="line">FileChannel fileChannel = file.getChannel();</span><br><span class="line">//创建buffer对象</span><br><span class="line">ByteBuffer byteBuffer = ByteBuffer.allocate( 1024 );</span><br><span class="line">String data = &quot;hello file channel&quot;;</span><br><span class="line">//存入buffer</span><br><span class="line">byteBuffer.put(data.getBytes());</span><br><span class="line">//读写模式转换</span><br><span class="line">byteBuffer.flip();</span><br><span class="line">//把buffer中的数据写入文件</span><br><span class="line">fileChannel.write(byteBuffer);</span><br><span class="line">//关闭</span><br><span class="line">fileChannel.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">package com.qf.channel.file;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import java.io.FileNotFoundException;</span><br><span class="line">import java.io.RandomAccessFile;</span><br><span class="line">import java.nio.channels.FileChannel;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 通道之间传输数据</span><br></pre></td></tr></table></figure>

<h4 id="通道之间传输数据二"><a href="#通道之间传输数据二" class="headerlink" title="通道之间传输数据二"></a>通道之间传输数据二</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">* @author htt</span><br><span class="line">* doublepeach</span><br><span class="line">*/</span><br><span class="line">public class Demo3 &#123;</span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">//获得两个文件的FileChannel</span><br><span class="line">RandomAccessFile srcFile = new</span><br><span class="line">RandomAccessFile(&quot;1.txt&quot;,&quot;rw&quot;);</span><br><span class="line">FileChannel srcFileChannel = srcFile.getChannel();</span><br><span class="line">RandomAccessFile destFile = new</span><br><span class="line">RandomAccessFile(&quot;3.txt&quot;,&quot;rw&quot;);</span><br><span class="line">FileChannel destFileChannel = destFile.getChannel();</span><br><span class="line">//src-&gt;dest</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">destFileChannel.transferFrom(srcFileChannel, 0 ,srcFileChannel.size</span><br><span class="line">());</span><br><span class="line">//关闭</span><br><span class="line">srcFileChannel.close();</span><br><span class="line">destFileChannel.close();</span><br><span class="line">System.out.println(&quot;传输完成&quot;);</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">package com.qf.channel.file;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import java.io.RandomAccessFile;</span><br><span class="line">import java.nio.channels.FileChannel;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 通道之间传输数据</span><br><span class="line">* @author htt</span><br><span class="line">* doublepeach</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<h2 id="3-Socket通道介绍"><a href="#3-Socket通道介绍" class="headerlink" title="3.Socket通道介绍"></a>3.Socket通道介绍</h2><h4 id="面向流的连接通道。Socket通道用于管理socket和socket之间的通道。Socket通道具"><a href="#面向流的连接通道。Socket通道用于管理socket和socket之间的通道。Socket通道具" class="headerlink" title="面向流的连接通道。Socket通道用于管理socket和socket之间的通道。Socket通道具"></a>面向流的连接通道。Socket通道用于管理socket和socket之间的通道。Socket通道具</h4><h4 id="有以下特点："><a href="#有以下特点：" class="headerlink" title="有以下特点："></a>有以下特点：</h4><h4 id="可以实现非阻塞，一个线程可以同时管理多个Socket连接，提升系统的吞吐"><a href="#可以实现非阻塞，一个线程可以同时管理多个Socket连接，提升系统的吞吐" class="headerlink" title="可以实现非阻塞，一个线程可以同时管理多个Socket连接，提升系统的吞吐"></a>可以实现非阻塞，一个线程可以同时管理多个Socket连接，提升系统的吞吐</h4><h4 id="量。"><a href="#量。" class="headerlink" title="量。"></a>量。</h4><h4 id="Socket通道的实现类（DatagramChannel、SocketChannel和"><a href="#Socket通道的实现类（DatagramChannel、SocketChannel和" class="headerlink" title="Socket通道的实现类（DatagramChannel、SocketChannel和"></a>Socket通道的实现类（DatagramChannel、SocketChannel和</h4><h4 id="ServerSocketChannel）在被实例化时会创建一个对等的Socket对象，也可以从"><a href="#ServerSocketChannel）在被实例化时会创建一个对等的Socket对象，也可以从" class="headerlink" title="ServerSocketChannel）在被实例化时会创建一个对等的Socket对象，也可以从"></a>ServerSocketChannel）在被实例化时会创建一个对等的Socket对象，也可以从</h4><h4 id="Socket对象中通过getChannel-方法获得对应的Channel。"><a href="#Socket对象中通过getChannel-方法获得对应的Channel。" class="headerlink" title="Socket对象中通过getChannel()方法获得对应的Channel。"></a>Socket对象中通过getChannel()方法获得对应的Channel。</h4><h2 id="4-ServerSocketChannel详解"><a href="#4-ServerSocketChannel详解" class="headerlink" title="4.ServerSocketChannel详解"></a>4.ServerSocketChannel详解</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Demo4 &#123;</span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">//获得两个文件的FileChannel</span><br><span class="line">RandomAccessFile srcFile = new</span><br><span class="line">RandomAccessFile(&quot;1.txt&quot;,&quot;rw&quot;);</span><br><span class="line">FileChannel srcFileChannel = srcFile.getChannel();</span><br><span class="line">RandomAccessFile destFile = new</span><br><span class="line">RandomAccessFile(&quot;4.txt&quot;,&quot;rw&quot;);</span><br><span class="line">FileChannel destFileChannel = destFile.getChannel();</span><br><span class="line">//src-&gt;dest</span><br><span class="line">srcFileChannel.transferTo( 0 , srcFileChannel.size(),</span><br><span class="line">destFileChannel);</span><br><span class="line">//关闭</span><br><span class="line">srcFileChannel.close();</span><br><span class="line">destFileChannel.close();</span><br><span class="line">System.out.println(&quot;传输完成&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="-3"><a href="#-3" class="headerlink" title></a></h5><h4 id="ServerSocketChannel是一个基于通道的Socket监听器，能够实现非阻塞模式。"><a href="#ServerSocketChannel是一个基于通道的Socket监听器，能够实现非阻塞模式。" class="headerlink" title="ServerSocketChannel是一个基于通道的Socket监听器，能够实现非阻塞模式。"></a>ServerSocketChannel是一个基于通道的Socket监听器，能够实现非阻塞模式。</h4><h4 id="ServerSocketChannel的主要作用是用来监听端口的连接，来创建SocketChannel。"><a href="#ServerSocketChannel的主要作用是用来监听端口的连接，来创建SocketChannel。" class="headerlink" title="ServerSocketChannel的主要作用是用来监听端口的连接，来创建SocketChannel。"></a>ServerSocketChannel的主要作用是用来监听端口的连接，来创建SocketChannel。</h4><h4 id="也就是说，可以调用ServerSocketChannel的accept方法，来创建SocketChannel对"><a href="#也就是说，可以调用ServerSocketChannel的accept方法，来创建SocketChannel对" class="headerlink" title="也就是说，可以调用ServerSocketChannel的accept方法，来创建SocketChannel对"></a>也就是说，可以调用ServerSocketChannel的accept方法，来创建SocketChannel对</h4><h4 id="象。"><a href="#象。" class="headerlink" title="象。"></a>象。</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">package com.qf.channel.socket;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line">import java.net.InetSocketAddress;</span><br><span class="line">import java.nio.ByteBuffer;</span><br><span class="line">import java.nio.channels.ServerSocketChannel;</span><br><span class="line">import java.nio.channels.SocketChannel;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* ServerSocketChannel</span><br><span class="line">* @author htt</span><br><span class="line">* doublepeach</span><br><span class="line">*/</span><br><span class="line">public class ServerSocketChannelDemo &#123;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws IOException &#123;</span><br><span class="line">//创建buffer</span><br><span class="line">ByteBuffer buffer = ByteBuffer.wrap(&quot;hello server</span><br><span class="line">socket&quot;.getBytes());</span><br><span class="line">//创建ServerSocketChannel</span><br><span class="line">ServerSocketChannel ssc = ServerSocketChannel.open();</span><br><span class="line">//绑定端口</span><br><span class="line">ssc.socket().bind(new InetSocketAddress( 9090 ));</span><br><span class="line">//设置成非阻塞模式</span><br><span class="line">ssc.configureBlocking(false);</span><br><span class="line">//监听新连接</span><br><span class="line">while(true)&#123;</span><br><span class="line">System.out.println(&quot;等待连接&quot;);</span><br><span class="line">SocketChannel socketChannel = ssc.accept();</span><br><span class="line">if(socketChannel!=null)&#123;</span><br></pre></td></tr></table></figure>
<h5 id="-4"><a href="#-4" class="headerlink" title></a></h5><h2 id="5-SocketChannel详解"><a href="#5-SocketChannel详解" class="headerlink" title="5.SocketChannel详解"></a>5.SocketChannel详解</h2><h3 id="SocketChannel介绍"><a href="#SocketChannel介绍" class="headerlink" title="SocketChannel介绍"></a>SocketChannel介绍</h3><h4 id="SocketChannel是连接到TCP网络套接字的通道，更多代表的是客户端的操作。"><a href="#SocketChannel是连接到TCP网络套接字的通道，更多代表的是客户端的操作。" class="headerlink" title="SocketChannel是连接到TCP网络套接字的通道，更多代表的是客户端的操作。"></a>SocketChannel是连接到TCP网络套接字的通道，更多代表的是客户端的操作。</h4><h4 id="SocketChannel具有以下特点："><a href="#SocketChannel具有以下特点：" class="headerlink" title="SocketChannel具有以下特点："></a>SocketChannel具有以下特点：</h4><h4 id="SocketChannel连接的是Socket套接字，也就是说通道的两边是Socket套接字"><a href="#SocketChannel连接的是Socket套接字，也就是说通道的两边是Socket套接字" class="headerlink" title="SocketChannel连接的是Socket套接字，也就是说通道的两边是Socket套接字"></a>SocketChannel连接的是Socket套接字，也就是说通道的两边是Socket套接字</h4><h4 id="SocketChannel是用来处理网络IO的通道"><a href="#SocketChannel是用来处理网络IO的通道" class="headerlink" title="SocketChannel是用来处理网络IO的通道"></a>SocketChannel是用来处理网络IO的通道</h4><h4 id="SocketChannel是可选择的，可以被多路复用"><a href="#SocketChannel是可选择的，可以被多路复用" class="headerlink" title="SocketChannel是可选择的，可以被多路复用"></a>SocketChannel是可选择的，可以被多路复用</h4><h4 id="SocketChannel基于TCP连接传输"><a href="#SocketChannel基于TCP连接传输" class="headerlink" title="SocketChannel基于TCP连接传输"></a>SocketChannel基于TCP连接传输</h4><h3 id="SocketChannel使用细节"><a href="#SocketChannel使用细节" class="headerlink" title="SocketChannel使用细节"></a>SocketChannel使用细节</h3><h4 id="SocketChannel在使用上需要注意以下细节："><a href="#SocketChannel在使用上需要注意以下细节：" class="headerlink" title="SocketChannel在使用上需要注意以下细节："></a>SocketChannel在使用上需要注意以下细节：</h4><h4 id="不能在已经存在的Socket上再创建SocketChannel"><a href="#不能在已经存在的Socket上再创建SocketChannel" class="headerlink" title="不能在已经存在的Socket上再创建SocketChannel"></a>不能在已经存在的Socket上再创建SocketChannel</h4><h4 id="SocketChannel需要指明关联的服务器地址及端口后才能使用"><a href="#SocketChannel需要指明关联的服务器地址及端口后才能使用" class="headerlink" title="SocketChannel需要指明关联的服务器地址及端口后才能使用"></a>SocketChannel需要指明关联的服务器地址及端口后才能使用</h4><h4 id="未进行连接的SocketChannel进行IO操作时将抛出NotYetConnectedException异常"><a href="#未进行连接的SocketChannel进行IO操作时将抛出NotYetConnectedException异常" class="headerlink" title="未进行连接的SocketChannel进行IO操作时将抛出NotYetConnectedException异常"></a>未进行连接的SocketChannel进行IO操作时将抛出NotYetConnectedException异常</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(&quot;有新的连</span><br><span class="line">接:&quot;+socketChannel.socket().getRemoteSocketAddress());</span><br><span class="line">&#125;else&#123;</span><br><span class="line">try &#123;</span><br><span class="line">Thread.sleep( 1000 );</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="-5"><a href="#-5" class="headerlink" title></a></h5><h4 id="参数名称-Description"><a href="#参数名称-Description" class="headerlink" title="参数名称 Description"></a>参数名称 Description</h4><h4 id="SO-SNDBUF-Socket发送缓冲区的大小"><a href="#SO-SNDBUF-Socket发送缓冲区的大小" class="headerlink" title="SO_SNDBUF Socket发送缓冲区的大小"></a>SO_SNDBUF Socket发送缓冲区的大小</h4><h4 id="SO-RCVBUF-Socket接受缓冲区的大小"><a href="#SO-RCVBUF-Socket接受缓冲区的大小" class="headerlink" title="SO_RCVBUF Socket接受缓冲区的大小"></a>SO_RCVBUF Socket接受缓冲区的大小</h4><h4 id="SO-KEEPALIVE-保活连接"><a href="#SO-KEEPALIVE-保活连接" class="headerlink" title="SO_KEEPALIVE 保活连接"></a>SO_KEEPALIVE 保活连接</h4><h4 id="SO-REUSEADDR-复用地址"><a href="#SO-REUSEADDR-复用地址" class="headerlink" title="SO_REUSEADDR 复用地址"></a>SO_REUSEADDR 复用地址</h4><h4 id="SO-LINGER-有数据传输时延缓关闭Channel-只在非阻塞模式下使用"><a href="#SO-LINGER-有数据传输时延缓关闭Channel-只在非阻塞模式下使用" class="headerlink" title="SO_LINGER 有数据传输时延缓关闭Channel (只在非阻塞模式下使用)"></a>SO_LINGER 有数据传输时延缓关闭Channel (只在非阻塞模式下使用)</h4><h4 id="TCP-NODELAY-禁用Nagle算法"><a href="#TCP-NODELAY-禁用Nagle算法" class="headerlink" title="TCP_NODELAY 禁用Nagle算法"></a>TCP_NODELAY 禁用Nagle算法</h4><h4 id="SocketChannel支持阻塞和非阻塞两种模式"><a href="#SocketChannel支持阻塞和非阻塞两种模式" class="headerlink" title="SocketChannel支持阻塞和非阻塞两种模式"></a>SocketChannel支持阻塞和非阻塞两种模式</h4><h4 id="SocketChannel支持异步关闭。"><a href="#SocketChannel支持异步关闭。" class="headerlink" title="SocketChannel支持异步关闭。"></a>SocketChannel支持异步关闭。</h4><h4 id="SocketChannel支持设定参数"><a href="#SocketChannel支持设定参数" class="headerlink" title="SocketChannel支持设定参数"></a>SocketChannel支持设定参数</h4><h3 id="SocketChannel示例"><a href="#SocketChannel示例" class="headerlink" title="SocketChannel示例"></a>SocketChannel示例</h3><h4 id="创建SocketChannel"><a href="#创建SocketChannel" class="headerlink" title="创建SocketChannel"></a>创建SocketChannel</h4><h4 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h4><h4 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h4><h4 id="连接状态校验"><a href="#连接状态校验" class="headerlink" title="连接状态校验"></a>连接状态校验</h4><h4 id="socketChannel-isOpen-判断SocketChannel是否为open状态"><a href="#socketChannel-isOpen-判断SocketChannel是否为open状态" class="headerlink" title="socketChannel.isOpen(): 判断SocketChannel是否为open状态"></a>socketChannel.isOpen(): 判断SocketChannel是否为open状态</h4><h4 id="socketChannel-isConnected-判断SocketChannel是否已连接"><a href="#socketChannel-isConnected-判断SocketChannel是否已连接" class="headerlink" title="socketChannel.isConnected(): 判断SocketChannel是否已连接"></a>socketChannel.isConnected(): 判断SocketChannel是否已连接</h4><h4 id="socketChannel-isConnectionPending-判断SocketChannel是否正在进行连接"><a href="#socketChannel-isConnectionPending-判断SocketChannel是否正在进行连接" class="headerlink" title="socketChannel.isConnectionPending(): 判断SocketChannel是否正在进行连接"></a>socketChannel.isConnectionPending(): 判断SocketChannel是否正在进行连接</h4><h4 id="socketChannel-finishConnect-完成连接，如果此通道已连接，则此方法将"><a href="#socketChannel-finishConnect-完成连接，如果此通道已连接，则此方法将" class="headerlink" title="socketChannel.finishConnect(): 完成连接，如果此通道已连接，则此方法将"></a>socketChannel.finishConnect(): 完成连接，如果此通道已连接，则此方法将</h4><h4 id="不会阻塞，并将立即返回true。如果此通道处于非阻塞模式，则如果连接过"><a href="#不会阻塞，并将立即返回true。如果此通道处于非阻塞模式，则如果连接过" class="headerlink" title="不会阻塞，并将立即返回true。如果此通道处于非阻塞模式，则如果连接过"></a>不会阻塞，并将立即返回true。如果此通道处于非阻塞模式，则如果连接过</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SocketChannel socketChannel = SocketChannel.open(new</span><br><span class="line">InetSocketAddress(&quot;localhost&quot;, 9090 ));</span><br></pre></td></tr></table></figure>
<h5 id="1"><a href="#1" class="headerlink" title="1"></a>1</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SocketChannel socketChannel = SocketChannel.open();</span><br><span class="line">socketChannel.connect(new InetSocketAddress(&quot;localhost&quot;, 9090 ));</span><br></pre></td></tr></table></figure>
<h5 id="1-1"><a href="#1-1" class="headerlink" title="1"></a>1</h5><h5 id="2"><a href="#2" class="headerlink" title="2"></a>2</h5><h4 id="程尚未完成，则此方法将返回false。如果此通道处于阻塞模式，则此方法"><a href="#程尚未完成，则此方法将返回false。如果此通道处于阻塞模式，则此方法" class="headerlink" title="程尚未完成，则此方法将返回false。如果此通道处于阻塞模式，则此方法"></a>程尚未完成，则此方法将返回false。如果此通道处于阻塞模式，则此方法</h4><h4 id="将阻塞，直到连接完成或失败，并且将始终返回true或抛出一个描述失败的"><a href="#将阻塞，直到连接完成或失败，并且将始终返回true或抛出一个描述失败的" class="headerlink" title="将阻塞，直到连接完成或失败，并且将始终返回true或抛出一个描述失败的"></a>将阻塞，直到连接完成或失败，并且将始终返回true或抛出一个描述失败的</h4><h4 id="检查异常。"><a href="#检查异常。" class="headerlink" title="检查异常。"></a>检查异常。</h4><h4 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h4><h4 id="读写操作"><a href="#读写操作" class="headerlink" title="读写操作"></a>读写操作</h4><h5 id="x2F-x2F-设置非阻塞"><a href="#x2F-x2F-设置非阻塞" class="headerlink" title="&#x2F;&#x2F;设置非阻塞"></a>&#x2F;&#x2F;设置非阻塞</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socketChannel.configureBlocking(false);</span><br></pre></td></tr></table></figure>
<h5 id="1-2"><a href="#1-2" class="headerlink" title="1"></a>1</h5><h5 id="2-1"><a href="#2-1" class="headerlink" title="2"></a>2</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">package com.qf.channel.socket;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line">import java.net.InetSocketAddress;</span><br><span class="line">import java.nio.ByteBuffer;</span><br><span class="line">import java.nio.channels.SocketChannel;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* SocketChannel</span><br><span class="line">* @author htt</span><br><span class="line">* doublepeach</span><br><span class="line">*/</span><br><span class="line">public class SocketChannelDemo &#123;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws IOException &#123;</span><br><span class="line">SocketChannel socketChannel = SocketChannel.open();</span><br><span class="line">socketChannel.connect(new</span><br><span class="line">InetSocketAddress(&quot;www.baidu.com&quot;, 80 ));</span><br><span class="line">//设置非阻塞</span><br><span class="line">socketChannel.configureBlocking(true);</span><br><span class="line">if(socketChannel.isConnectionPending())&#123;</span><br><span class="line">//完成连接</span><br><span class="line">socketChannel.finishConnect();</span><br><span class="line">&#125;</span><br><span class="line">ByteBuffer byteBuffer = ByteBuffer.allocate( 1024 );</span><br><span class="line">//如果是阻塞模式，则此处将阻塞</span><br><span class="line">socketChannel.read(byteBuffer);</span><br></pre></td></tr></table></figure>
<h5 id="-6"><a href="#-6" class="headerlink" title></a></h5><h4 id="设置参数"><a href="#设置参数" class="headerlink" title="设置参数"></a>设置参数</h4><h2 id="6-DatagramChannel详解"><a href="#6-DatagramChannel详解" class="headerlink" title="6.DatagramChannel详解"></a>6.DatagramChannel详解</h2><h4 id="DatagramChannel对象关联着一个DatagramSocket对象。"><a href="#DatagramChannel对象关联着一个DatagramSocket对象。" class="headerlink" title="DatagramChannel对象关联着一个DatagramSocket对象。"></a>DatagramChannel对象关联着一个DatagramSocket对象。</h4><h4 id="DatagramChannel基于UDP无连接协议，每个数据报都是一个自包含的实体，拥有"><a href="#DatagramChannel基于UDP无连接协议，每个数据报都是一个自包含的实体，拥有" class="headerlink" title="DatagramChannel基于UDP无连接协议，每个数据报都是一个自包含的实体，拥有"></a>DatagramChannel基于UDP无连接协议，每个数据报都是一个自包含的实体，拥有</h4><h4 id="它自己的目的地址及数据负载。DatagramChannel可以发送单独的数据报给不同的"><a href="#它自己的目的地址及数据负载。DatagramChannel可以发送单独的数据报给不同的" class="headerlink" title="它自己的目的地址及数据负载。DatagramChannel可以发送单独的数据报给不同的"></a>它自己的目的地址及数据负载。DatagramChannel可以发送单独的数据报给不同的</h4><h4 id="目的地，同样也可以接受来自于任意地址的数据报。"><a href="#目的地，同样也可以接受来自于任意地址的数据报。" class="headerlink" title="目的地，同样也可以接受来自于任意地址的数据报。"></a>目的地，同样也可以接受来自于任意地址的数据报。</h4><h4 id="发送方的实现"><a href="#发送方的实现" class="headerlink" title="发送方的实现"></a>发送方的实现</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(&quot;读取到的内容:&quot;+new</span><br><span class="line">String(byteBuffer.array()));</span><br><span class="line">socketChannel.close();</span><br><span class="line">System.out.println(&quot;完成读操作&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="-7"><a href="#-7" class="headerlink" title></a></h5><h5 id="x2F-x2F-设置参数"><a href="#x2F-x2F-设置参数" class="headerlink" title="&#x2F;&#x2F;设置参数"></a>&#x2F;&#x2F;设置参数</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">socketChannel.setOption(StandardSocketOptions.SO_RCVBUF, 2048 );</span><br><span class="line">socketChannel.setOption(StandardSocketOptions.SO_RCVBUF, 2048 );</span><br><span class="line">//获取参数</span><br><span class="line">socketChannel.getOption(StandardSocketOptions.SO_RCVBUF);</span><br></pre></td></tr></table></figure>
<h5 id="-8"><a href="#-8" class="headerlink" title></a></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testSend() throws Exception &#123;</span><br><span class="line">//获得DatagramChannel</span><br><span class="line">DatagramChannel datagramChannel = DatagramChannel.open();</span><br><span class="line">//创建地址对象</span><br><span class="line">InetSocketAddress socketAddress = new</span><br><span class="line">InetSocketAddress(&quot;127.0.0.1&quot;, 9001 );</span><br><span class="line">//创建Buffer</span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate( 1024 );</span><br><span class="line">buffer.put(&quot;hello datagram channel&quot;.getBytes());</span><br></pre></td></tr></table></figure>
<h5 id="-9"><a href="#-9" class="headerlink" title></a></h5><h4 id="接收方的实现"><a href="#接收方的实现" class="headerlink" title="接收方的实现"></a>接收方的实现</h4><h4 id="使用read和write来表示接收和发送"><a href="#使用read和write来表示接收和发送" class="headerlink" title="使用read和write来表示接收和发送"></a>使用read和write来表示接收和发送</h4><h4 id="DatagramChannel并不会建立连接通道，这里的read和write方法是在缓冲区中进行"><a href="#DatagramChannel并不会建立连接通道，这里的read和write方法是在缓冲区中进行" class="headerlink" title="DatagramChannel并不会建立连接通道，这里的read和write方法是在缓冲区中进行"></a>DatagramChannel并不会建立连接通道，这里的read和write方法是在缓冲区中进行</h4><h4 id="读写，来表达发送和接收的动作。"><a href="#读写，来表达发送和接收的动作。" class="headerlink" title="读写，来表达发送和接收的动作。"></a>读写，来表达发送和接收的动作。</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">buffer.flip();</span><br><span class="line">// ByteBuffer buffer = ByteBuffer.wrap(&quot;hello datagram</span><br><span class="line">channel&quot;.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">//发送消息</span><br><span class="line">datagramChannel.send(buffer,socketAddress);</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="-10"><a href="#-10" class="headerlink" title></a></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testReceive() throws Exception &#123;</span><br><span class="line">//获得DatagramChannel</span><br><span class="line">DatagramChannel datagramChannel = DatagramChannel.open();</span><br><span class="line">//创建地址对象</span><br><span class="line">InetSocketAddress socketAddress = new</span><br><span class="line">InetSocketAddress( 9001 );</span><br><span class="line">//绑定端口到Channel上</span><br><span class="line">datagramChannel.bind(socketAddress);</span><br><span class="line">//创建Buffer</span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate( 1024 );</span><br><span class="line">//接收消息</span><br><span class="line">while(true)&#123;</span><br><span class="line">buffer.clear();</span><br><span class="line">SocketAddress address =</span><br><span class="line">datagramChannel.receive(buffer);</span><br><span class="line">buffer.flip();</span><br><span class="line">System.out.println(address.toString()+&quot;发来消息：&quot;+new</span><br><span class="line">String(buffer.array(), 0 ,buffer.limit()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="-11"><a href="#-11" class="headerlink" title></a></h5><h2 id="7-分散和聚集"><a href="#7-分散和聚集" class="headerlink" title="7.分散和聚集"></a>7.分散和聚集</h2><h4 id="Java-NIO的分散Scatter和聚集Gather允许用户通过channel一次读取到的数据存入到"><a href="#Java-NIO的分散Scatter和聚集Gather允许用户通过channel一次读取到的数据存入到" class="headerlink" title="Java NIO的分散Scatter和聚集Gather允许用户通过channel一次读取到的数据存入到"></a>Java NIO的分散Scatter和聚集Gather允许用户通过channel一次读取到的数据存入到</h4><h4 id="多个buffer中，或者一次将多个buffer中的数据写入到一个Channel中。分散和聚集"><a href="#多个buffer中，或者一次将多个buffer中的数据写入到一个Channel中。分散和聚集" class="headerlink" title="多个buffer中，或者一次将多个buffer中的数据写入到一个Channel中。分散和聚集"></a>多个buffer中，或者一次将多个buffer中的数据写入到一个Channel中。分散和聚集</h4><h4 id="的应用场景可以是将数据的多个部分存放在不同的buffer中来进行读写。"><a href="#的应用场景可以是将数据的多个部分存放在不同的buffer中来进行读写。" class="headerlink" title="的应用场景可以是将数据的多个部分存放在不同的buffer中来进行读写。"></a>的应用场景可以是将数据的多个部分存放在不同的buffer中来进行读写。</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testReadAndWrite() throws Exception &#123;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//获得DatagramChannel</span><br><span class="line">DatagramChannel datagramChannel = DatagramChannel.open();</span><br><span class="line">//绑定</span><br><span class="line">datagramChannel.bind(new InetSocketAddress( 9002 ));</span><br><span class="line">//连接</span><br><span class="line">datagramChannel.connect(new</span><br><span class="line">InetSocketAddress(&quot;127.0.0.1&quot;, 9002 ));</span><br><span class="line">//write</span><br><span class="line">datagramChannel.write(ByteBuffer.wrap(&quot;write</span><br><span class="line">message&quot;.getBytes()));</span><br><span class="line">//创建用于读数据的Buffer</span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate( 1024 );</span><br><span class="line">while(true)&#123;</span><br><span class="line">buffer.clear();</span><br><span class="line">datagramChannel.read(buffer);</span><br><span class="line">buffer.flip();</span><br><span class="line">System.out.println(&quot;收到消息：&quot;+new</span><br><span class="line">String(buffer.array(), 0 ,buffer.limit()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="-12"><a href="#-12" class="headerlink" title="}"></a>}</h5><h5 id="-13"><a href="#-13" class="headerlink" title></a></h5><h4 id="分散Scatter"><a href="#分散Scatter" class="headerlink" title="分散Scatter"></a>分散Scatter</h4><h4 id="在一个channel中读取的数据存入到多个buffer中。"><a href="#在一个channel中读取的数据存入到多个buffer中。" class="headerlink" title="在一个channel中读取的数据存入到多个buffer中。"></a>在一个channel中读取的数据存入到多个buffer中。</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">package com.qf.channel.scatterandgather;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import java.io.FileNotFoundException;</span><br><span class="line">import java.io.RandomAccessFile;</span><br><span class="line">import java.nio.ByteBuffer;</span><br><span class="line">import java.nio.channels.FileChannel;</span><br><span class="line">import java.util.Arrays;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 分散</span><br><span class="line">* @author htt</span><br><span class="line">* doublepeach</span><br><span class="line">*/</span><br><span class="line">public class Demo1 &#123;</span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">//随机访问流</span><br><span class="line">RandomAccessFile file = new</span><br><span class="line">RandomAccessFile(&quot;1.txt&quot;,&quot;rw&quot;);</span><br><span class="line">//得到FileChannel</span><br><span class="line">FileChannel fileChannel = file.getChannel();</span><br><span class="line">//创建buffer</span><br></pre></td></tr></table></figure>
<h5 id="-14"><a href="#-14" class="headerlink" title></a></h5><h4 id="聚集Gather"><a href="#聚集Gather" class="headerlink" title="聚集Gather"></a>聚集Gather</h4><h4 id="一次将多个buffer中的数据写入到一个channel中。"><a href="#一次将多个buffer中的数据写入到一个channel中。" class="headerlink" title="一次将多个buffer中的数据写入到一个channel中。"></a>一次将多个buffer中的数据写入到一个channel中。</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buffer1 = ByteBuffer.allocate( 3 );</span><br><span class="line">ByteBuffer buffer2 = ByteBuffer.allocate( 3 );</span><br><span class="line">;</span><br><span class="line">//fileChannel读取数据到buffer中</span><br><span class="line">long len = 0 ;</span><br><span class="line">while((len = fileChannel.read(new ByteBuffer[]</span><br><span class="line">&#123;buffer1,buffer2&#125;))!=- 1 )&#123;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">buffer1.flip();</span><br><span class="line">buffer2.flip();</span><br><span class="line">System.out.println(&quot;buffer1:&quot;+new</span><br><span class="line">String(buffer1.array(), 0 ,buffer1.limit()));</span><br><span class="line">System.out.println(&quot;buffer2:&quot;+new</span><br><span class="line">String(buffer2.array(), 0 ,buffer2.limit()));</span><br><span class="line">file.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="-15"><a href="#-15" class="headerlink" title></a></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">package com.qf.channel.scatterandgather;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import java.io.FileNotFoundException;</span><br><span class="line">import java.io.RandomAccessFile;</span><br><span class="line">import java.nio.ByteBuffer;</span><br><span class="line">import java.nio.channels.FileChannel;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 聚集</span><br><span class="line">* @author htt</span><br><span class="line">* doublepeach</span><br><span class="line">*/</span><br><span class="line">public class Demo2 &#123;</span><br></pre></td></tr></table></figure>
<h5 id="-16"><a href="#-16" class="headerlink" title></a></h5><h1 id="四、NIO-Buffer详解"><a href="#四、NIO-Buffer详解" class="headerlink" title="四、NIO-Buffer详解"></a>四、NIO-Buffer详解</h1><h2 id="1-Buffer概述"><a href="#1-Buffer概述" class="headerlink" title="1.Buffer概述"></a>1.Buffer概述</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">//创建随机访问流</span><br><span class="line">RandomAccessFile file = new</span><br><span class="line">RandomAccessFile(&quot;5.txt&quot;,&quot;rw&quot;);</span><br><span class="line">//获得FileChannel</span><br><span class="line">FileChannel fileChannel = file.getChannel();</span><br><span class="line">//创建 2 个buffer对象</span><br><span class="line">ByteBuffer byteBuffer1 = ByteBuffer.allocate( 1024 );</span><br><span class="line">ByteBuffer byteBuffer2 = ByteBuffer.allocate( 1024 );</span><br><span class="line">//数据 1</span><br><span class="line">String data1 = &quot;hello buffer1 channel&quot;;</span><br><span class="line">//存入buffer1</span><br><span class="line">byteBuffer1.put(data1.getBytes());</span><br><span class="line">//翻转buffer1</span><br><span class="line">byteBuffer1.flip();</span><br><span class="line">//数据 1</span><br><span class="line">String data2 = &quot;hello buffer2 channel&quot;;</span><br><span class="line">//存入buffer1</span><br><span class="line">byteBuffer2.put(data2.getBytes());</span><br><span class="line">//翻转buffer1</span><br><span class="line">byteBuffer2.flip();</span><br><span class="line">//fileChannel写数据到文件</span><br><span class="line">fileChannel.write(new ByteBuffer[]</span><br><span class="line">&#123;byteBuffer1,byteBuffer2&#125;);</span><br><span class="line">//关闭</span><br><span class="line">fileChannel.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="-17"><a href="#-17" class="headerlink" title></a></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">܉᲋රᙙJavaරᎸᴺ ̓ݩռلဳىJavaຝ຅຾̈́ӥ᫹ಅํ᧞ᑕդᎱ᧞կ݊ૡٍ ᦏದ๞ࢧ୭๜ᧆํጱᕍᶉѺ</span><br></pre></td></tr></table></figure>

<h2 id="1-Buffer概述-1"><a href="#1-Buffer概述-1" class="headerlink" title="1.Buffer概述"></a>1.Buffer概述</h2><h4 id="Buffer缓冲区实际上是内存中开辟的一块数组空间，用于存放数据。Java-NIO中的"><a href="#Buffer缓冲区实际上是内存中开辟的一块数组空间，用于存放数据。Java-NIO中的" class="headerlink" title="Buffer缓冲区实际上是内存中开辟的一块数组空间，用于存放数据。Java NIO中的"></a>Buffer缓冲区实际上是内存中开辟的一块数组空间，用于存放数据。Java NIO中的</h4><h4 id="buffer类提供了对这块数组缓冲区的基本操作。"><a href="#buffer类提供了对这块数组缓冲区的基本操作。" class="headerlink" title="buffer类提供了对这块数组缓冲区的基本操作。"></a>buffer类提供了对这块数组缓冲区的基本操作。</h4><h4 id="IO流的操作面向的是流对象，而NIO操作的数据都是面向Buffer缓冲区的。也就是"><a href="#IO流的操作面向的是流对象，而NIO操作的数据都是面向Buffer缓冲区的。也就是" class="headerlink" title="IO流的操作面向的是流对象，而NIO操作的数据都是面向Buffer缓冲区的。也就是"></a>IO流的操作面向的是流对象，而NIO操作的数据都是面向Buffer缓冲区的。也就是</h4><h4 id="说，读取数据是通过通道将数据存入到buffer中。写数据是将buffer缓冲区中的数据"><a href="#说，读取数据是通过通道将数据存入到buffer中。写数据是将buffer缓冲区中的数据" class="headerlink" title="说，读取数据是通过通道将数据存入到buffer中。写数据是将buffer缓冲区中的数据"></a>说，读取数据是通过通道将数据存入到buffer中。写数据是将buffer缓冲区中的数据</h4><h4 id="通过通道写到文件中。"><a href="#通过通道写到文件中。" class="headerlink" title="通过通道写到文件中。"></a>通过通道写到文件中。</h4><h4 id="Java-NIO提供了所有缓冲区的抽象基类Buffer。Buffer的具体实现类有很多，比如"><a href="#Java-NIO提供了所有缓冲区的抽象基类Buffer。Buffer的具体实现类有很多，比如" class="headerlink" title="Java NIO提供了所有缓冲区的抽象基类Buffer。Buffer的具体实现类有很多，比如"></a>Java NIO提供了所有缓冲区的抽象基类Buffer。Buffer的具体实现类有很多，比如</h4><h4 id="ByteBuffer、IntBuffer、LongBuffer、CharBuffer、DoubleBuffer、FloatBuffer、"><a href="#ByteBuffer、IntBuffer、LongBuffer、CharBuffer、DoubleBuffer、FloatBuffer、" class="headerlink" title="ByteBuffer、IntBuffer、LongBuffer、CharBuffer、DoubleBuffer、FloatBuffer、"></a>ByteBuffer、IntBuffer、LongBuffer、CharBuffer、DoubleBuffer、FloatBuffer、</h4><h4 id="HeapByteBuffer、MappedByteBuffer等等，这些具体的实现类实际上是依据Buffer数"><a href="#HeapByteBuffer、MappedByteBuffer等等，这些具体的实现类实际上是依据Buffer数" class="headerlink" title="HeapByteBuffer、MappedByteBuffer等等，这些具体的实现类实际上是依据Buffer数"></a>HeapByteBuffer、MappedByteBuffer等等，这些具体的实现类实际上是依据Buffer数</h4><h4 id="组中存放数据的数据类型来决定，比如ByteBuffer中存放的是字节数据、LongBuffer"><a href="#组中存放数据的数据类型来决定，比如ByteBuffer中存放的是字节数据、LongBuffer" class="headerlink" title="组中存放数据的数据类型来决定，比如ByteBuffer中存放的是字节数据、LongBuffer"></a>组中存放数据的数据类型来决定，比如ByteBuffer中存放的是字节数据、LongBuffer</h4><h4 id="中存放的long类型的数据。"><a href="#中存放的long类型的数据。" class="headerlink" title="中存放的long类型的数据。"></a>中存放的long类型的数据。</h4><h2 id="2-Buffer的关键属性"><a href="#2-Buffer的关键属性" class="headerlink" title="2.Buffer的关键属性"></a>2.Buffer的关键属性</h2><h4 id="Buffer的三大关键属性：capactity、limit、position。"><a href="#Buffer的三大关键属性：capactity、limit、position。" class="headerlink" title="Buffer的三大关键属性：capactity、limit、position。"></a>Buffer的三大关键属性：capactity、limit、position。</h4><h4 id="capacity"><a href="#capacity" class="headerlink" title="capacity:"></a>capacity:</h4><h4 id="缓冲区的容量是它包含的元素数。缓冲区的容量永远不会为负，也永远不会改"><a href="#缓冲区的容量是它包含的元素数。缓冲区的容量永远不会为负，也永远不会改" class="headerlink" title="缓冲区的容量是它包含的元素数。缓冲区的容量永远不会为负，也永远不会改"></a>缓冲区的容量是它包含的元素数。缓冲区的容量永远不会为负，也永远不会改</h4><h4 id="变。"><a href="#变。" class="headerlink" title="变。"></a>变。</h4><h4 id="limit"><a href="#limit" class="headerlink" title="limit:"></a>limit:</h4><h4 id="缓冲区的限制是不应读取或写入的第一个元素的索引。缓冲区的限制永远不会"><a href="#缓冲区的限制是不应读取或写入的第一个元素的索引。缓冲区的限制永远不会" class="headerlink" title="缓冲区的限制是不应读取或写入的第一个元素的索引。缓冲区的限制永远不会"></a>缓冲区的限制是不应读取或写入的第一个元素的索引。缓冲区的限制永远不会</h4><h4 id="为负，也永远不会大于其容量。"><a href="#为负，也永远不会大于其容量。" class="headerlink" title="为负，也永远不会大于其容量。"></a>为负，也永远不会大于其容量。</h4><h4 id="写数据时：limit与capacity相同"><a href="#写数据时：limit与capacity相同" class="headerlink" title="写数据时：limit与capacity相同"></a>写数据时：limit与capacity相同</h4><h4 id="读数据时：limit表示可读的数据位置，因此在上次写操作后需要通过flip方"><a href="#读数据时：limit表示可读的数据位置，因此在上次写操作后需要通过flip方" class="headerlink" title="读数据时：limit表示可读的数据位置，因此在上次写操作后需要通过flip方"></a>读数据时：limit表示可读的数据位置，因此在上次写操作后需要通过flip方</h4><h4 id="法，将position值赋给limit。"><a href="#法，将position值赋给limit。" class="headerlink" title="法，将position值赋给limit。"></a>法，将position值赋给limit。</h4><h4 id="position"><a href="#position" class="headerlink" title="position:"></a>position:</h4><h4 id="返回值类型-方法名-描述"><a href="#返回值类型-方法名-描述" class="headerlink" title="返回值类型 方法名 描述"></a>返回值类型 方法名 描述</h4><h4 id="abstract"><a href="#abstract" class="headerlink" title="abstract"></a>abstract</h4><h4 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h4><h4 id="array-返回缓冲区中的数组"><a href="#array-返回缓冲区中的数组" class="headerlink" title="array() 返回缓冲区中的数组"></a>array() 返回缓冲区中的数组</h4><h4 id="abstract-1"><a href="#abstract-1" class="headerlink" title="abstract"></a>abstract</h4><h4 id="int"><a href="#int" class="headerlink" title="int"></a>int</h4><h4 id="arrayOffset"><a href="#arrayOffset" class="headerlink" title="arrayOffset()"></a>arrayOffset()</h4><h4 id="返回缓冲区中数组的第一个元素"><a href="#返回缓冲区中数组的第一个元素" class="headerlink" title="返回缓冲区中数组的第一个元素"></a>返回缓冲区中数组的第一个元素</h4><h4 id="的位置"><a href="#的位置" class="headerlink" title="的位置"></a>的位置</h4><h4 id="int-capacity-返回缓冲区的容量"><a href="#int-capacity-返回缓冲区的容量" class="headerlink" title="int capacity() 返回缓冲区的容量"></a>int capacity() 返回缓冲区的容量</h4><h4 id="Buffer-clear-清空缓冲区中的内容"><a href="#Buffer-clear-清空缓冲区中的内容" class="headerlink" title="Buffer clear() 清空缓冲区中的内容"></a>Buffer clear() 清空缓冲区中的内容</h4><h4 id="Buffer-flip-翻转缓冲区"><a href="#Buffer-flip-翻转缓冲区" class="headerlink" title="Buffer flip() 翻转缓冲区"></a>Buffer flip() 翻转缓冲区</h4><h4 id="abstract-2"><a href="#abstract-2" class="headerlink" title="abstract"></a>abstract</h4><h4 id="boolean"><a href="#boolean" class="headerlink" title="boolean"></a>boolean</h4><h4 id="hasArray-是否缓冲区中有可访问的数组"><a href="#hasArray-是否缓冲区中有可访问的数组" class="headerlink" title="hasArray() 是否缓冲区中有可访问的数组"></a>hasArray() 是否缓冲区中有可访问的数组</h4><h4 id="boolean-hasRemaining"><a href="#boolean-hasRemaining" class="headerlink" title="boolean hasRemaining()"></a>boolean hasRemaining()</h4><h4 id="缓冲区中的position和limit之间"><a href="#缓冲区中的position和limit之间" class="headerlink" title="缓冲区中的position和limit之间"></a>缓冲区中的position和limit之间</h4><h4 id="是还存在元素"><a href="#是还存在元素" class="headerlink" title="是还存在元素"></a>是还存在元素</h4><h4 id="abstract-3"><a href="#abstract-3" class="headerlink" title="abstract"></a>abstract</h4><h4 id="boolean-1"><a href="#boolean-1" class="headerlink" title="boolean"></a>boolean</h4><h4 id="isDirect-此缓冲区是否是直接缓冲区"><a href="#isDirect-此缓冲区是否是直接缓冲区" class="headerlink" title="isDirect() 此缓冲区是否是直接缓冲区"></a>isDirect() 此缓冲区是否是直接缓冲区</h4><h4 id="abstract-4"><a href="#abstract-4" class="headerlink" title="abstract"></a>abstract</h4><h4 id="boolean-2"><a href="#boolean-2" class="headerlink" title="boolean"></a>boolean</h4><h4 id="isReadOnly-此缓冲区是否是只读缓冲区"><a href="#isReadOnly-此缓冲区是否是只读缓冲区" class="headerlink" title="isReadOnly() 此缓冲区是否是只读缓冲区"></a>isReadOnly() 此缓冲区是否是只读缓冲区</h4><h4 id="int-limit-返回此缓冲区的limit属性值"><a href="#int-limit-返回此缓冲区的limit属性值" class="headerlink" title="int limit() 返回此缓冲区的limit属性值"></a>int limit() 返回此缓冲区的limit属性值</h4><h4 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h4><h4 id="limit-int"><a href="#limit-int" class="headerlink" title="limit(int"></a>limit(int</h4><h4 id="newLimit"><a href="#newLimit" class="headerlink" title="newLimit)"></a>newLimit)</h4><h4 id="设置此缓冲区的limit属性值"><a href="#设置此缓冲区的limit属性值" class="headerlink" title="设置此缓冲区的limit属性值"></a>设置此缓冲区的limit属性值</h4><h4 id="缓冲区的位置是要读取或写入的下一个元素的索引。缓冲器的位置永远不会为"><a href="#缓冲区的位置是要读取或写入的下一个元素的索引。缓冲器的位置永远不会为" class="headerlink" title="缓冲区的位置是要读取或写入的下一个元素的索引。缓冲器的位置永远不会为"></a>缓冲区的位置是要读取或写入的下一个元素的索引。缓冲器的位置永远不会为</h4><h4 id="负，也永远不会大于其极限。"><a href="#负，也永远不会大于其极限。" class="headerlink" title="负，也永远不会大于其极限。"></a>负，也永远不会大于其极限。</h4><h2 id="3-Buffer的方法"><a href="#3-Buffer的方法" class="headerlink" title="3.Buffer的方法"></a>3.Buffer的方法</h2><h4 id="Buffer中的方法如下："><a href="#Buffer中的方法如下：" class="headerlink" title="Buffer中的方法如下："></a>Buffer中的方法如下：</h4><h4 id="Buffer-mark-标记当前缓冲区的position值"><a href="#Buffer-mark-标记当前缓冲区的position值" class="headerlink" title="Buffer mark() 标记当前缓冲区的position值"></a>Buffer mark() 标记当前缓冲区的position值</h4><h4 id="int-position-返回此缓冲区的position属性值"><a href="#int-position-返回此缓冲区的position属性值" class="headerlink" title="int position() 返回此缓冲区的position属性值"></a>int position() 返回此缓冲区的position属性值</h4><h4 id="Buffer-1"><a href="#Buffer-1" class="headerlink" title="Buffer"></a>Buffer</h4><h4 id="position-int"><a href="#position-int" class="headerlink" title="position(int"></a>position(int</h4><h4 id="newPosition"><a href="#newPosition" class="headerlink" title="newPosition)"></a>newPosition)</h4><h4 id="设置此缓冲区的position属性值"><a href="#设置此缓冲区的position属性值" class="headerlink" title="设置此缓冲区的position属性值"></a>设置此缓冲区的position属性值</h4><h4 id="int-remaining"><a href="#int-remaining" class="headerlink" title="int remaining()"></a>int remaining()</h4><h4 id="返回缓冲区中position和limit之"><a href="#返回缓冲区中position和limit之" class="headerlink" title="返回缓冲区中position和limit之"></a>返回缓冲区中position和limit之</h4><h4 id="间元素的个数"><a href="#间元素的个数" class="headerlink" title="间元素的个数"></a>间元素的个数</h4><h4 id="Buffer-reset"><a href="#Buffer-reset" class="headerlink" title="Buffer reset()"></a>Buffer reset()</h4><h4 id="重置缓冲区中position的值为之"><a href="#重置缓冲区中position的值为之" class="headerlink" title="重置缓冲区中position的值为之"></a>重置缓冲区中position的值为之</h4><h4 id="前mark的值"><a href="#前mark的值" class="headerlink" title="前mark的值"></a>前mark的值</h4><h4 id="Buffer-rewind-将position设置-0-，limit不变"><a href="#Buffer-rewind-将position设置-0-，limit不变" class="headerlink" title="Buffer rewind() 将position设置 0 ，limit不变"></a>Buffer rewind() 将position设置 0 ，limit不变</h4><h2 id="4-Buffer实现类的常用方法"><a href="#4-Buffer实现类的常用方法" class="headerlink" title="4.Buffer实现类的常用方法"></a>4.Buffer实现类的常用方法</h2><h4 id="以ByteBuffer为例，分类介绍ByteBuffer的常用方法。"><a href="#以ByteBuffer为例，分类介绍ByteBuffer的常用方法。" class="headerlink" title="以ByteBuffer为例，分类介绍ByteBuffer的常用方法。"></a>以ByteBuffer为例，分类介绍ByteBuffer的常用方法。</h4><h4 id="创建Buffer"><a href="#创建Buffer" class="headerlink" title="创建Buffer"></a>创建Buffer</h4><h4 id="ByteBuffer提供了allocate静态方法用来创建带有初始化数组的Buffer缓冲区。"><a href="#ByteBuffer提供了allocate静态方法用来创建带有初始化数组的Buffer缓冲区。" class="headerlink" title="ByteBuffer提供了allocate静态方法用来创建带有初始化数组的Buffer缓冲区。"></a>ByteBuffer提供了allocate静态方法用来创建带有初始化数组的Buffer缓冲区。</h4><h4 id="向Buffer中写数据"><a href="#向Buffer中写数据" class="headerlink" title="向Buffer中写数据"></a>向Buffer中写数据</h4><h4 id="将数据写入到buffer中有三种方式："><a href="#将数据写入到buffer中有三种方式：" class="headerlink" title="将数据写入到buffer中有三种方式："></a>将数据写入到buffer中有三种方式：</h4><h4 id="put-数据-：-将数据存入到buffer，此时position随之变化。"><a href="#put-数据-：-将数据存入到buffer，此时position随之变化。" class="headerlink" title="put(数据)： 将数据存入到buffer，此时position随之变化。"></a>put(数据)： 将数据存入到buffer，此时position随之变化。</h4><h4 id="wrap-数据-：将数据存入数据并返回buffer，此时position为-0-，limit为数据"><a href="#wrap-数据-：将数据存入数据并返回buffer，此时position为-0-，limit为数据" class="headerlink" title="wrap(数据)：将数据存入数据并返回buffer，此时position为 0 ，limit为数据"></a>wrap(数据)：将数据存入数据并返回buffer，此时position为 0 ，limit为数据</h4><h4 id="的⻓度"><a href="#的⻓度" class="headerlink" title="的⻓度"></a>的⻓度</h4><h4 id="channel-read-buffer-：将数据读入到buffer中。"><a href="#channel-read-buffer-：将数据读入到buffer中。" class="headerlink" title="channel.read(buffer)：将数据读入到buffer中。"></a>channel.read(buffer)：将数据读入到buffer中。</h4><h4 id="从Buffer中读取数据"><a href="#从Buffer中读取数据" class="headerlink" title="从Buffer中读取数据"></a>从Buffer中读取数据</h4><h4 id="从Buffer中读取数据有以下几种方式："><a href="#从Buffer中读取数据有以下几种方式：" class="headerlink" title="从Buffer中读取数据有以下几种方式："></a>从Buffer中读取数据有以下几种方式：</h4><h4 id="get相关的方法：获得当前position或指定position的数据"><a href="#get相关的方法：获得当前position或指定position的数据" class="headerlink" title="get相关的方法：获得当前position或指定position的数据"></a>get相关的方法：获得当前position或指定position的数据</h4><h4 id="array-：返回整个数组内容"><a href="#array-：返回整个数组内容" class="headerlink" title="array()：返回整个数组内容"></a>array()：返回整个数组内容</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 ByteBuffer buffer = ByteBuffer.allocate(1024);</span><br></pre></td></tr></table></figure>

<h4 id="channel-write-buffer-：使用channel获得buffer中的内容并写入到指定目标"><a href="#channel-write-buffer-：使用channel获得buffer中的内容并写入到指定目标" class="headerlink" title="channel.write(buffer)：使用channel获得buffer中的内容并写入到指定目标"></a>channel.write(buffer)：使用channel获得buffer中的内容并写入到指定目标</h4><h2 id="5-缓冲区分类"><a href="#5-缓冲区分类" class="headerlink" title="5.缓冲区分类"></a>5.缓冲区分类</h2><h4 id="子缓冲区"><a href="#子缓冲区" class="headerlink" title="子缓冲区"></a>子缓冲区</h4><h4 id="可以为Buffer创建子缓冲区，在现有缓冲区上分割出一块空间作为新的缓冲区。原"><a href="#可以为Buffer创建子缓冲区，在现有缓冲区上分割出一块空间作为新的缓冲区。原" class="headerlink" title="可以为Buffer创建子缓冲区，在现有缓冲区上分割出一块空间作为新的缓冲区。原"></a>可以为Buffer创建子缓冲区，在现有缓冲区上分割出一块空间作为新的缓冲区。原</h4><h4 id="缓冲区和子缓冲区共享同一片数据空间。"><a href="#缓冲区和子缓冲区共享同一片数据空间。" class="headerlink" title="缓冲区和子缓冲区共享同一片数据空间。"></a>缓冲区和子缓冲区共享同一片数据空间。</h4><h4 id="通过调用slice方法创建子缓冲区-。"><a href="#通过调用slice方法创建子缓冲区-。" class="headerlink" title="通过调用slice方法创建子缓冲区 。"></a>通过调用slice方法创建子缓冲区 。</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">package com.qf.channel.buffer;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import java.nio.ByteBuffer;</span><br><span class="line">import java.util.Arrays;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 子缓冲区</span><br><span class="line">* @author htt</span><br><span class="line">* doublepeach</span><br><span class="line">*/</span><br><span class="line">public class Demo1 &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">ByteBuffer buffer = ByteBuffer.wrap(new byte[]&#123; 1 , 2 , 3 , 4 ,</span><br><span class="line">5 , 6 , 7 , 8 , 9 &#125;);</span><br><span class="line">//设置position</span><br><span class="line">buffer.position( 4 );</span><br><span class="line">//设置limit</span><br><span class="line">buffer.limit( 8 );</span><br><span class="line">//获得子缓冲区</span><br><span class="line">ByteBuffer slice = buffer.slice();</span><br><span class="line">slice.put( 0 ,(byte) 50 );</span><br><span class="line">buffer.position( 0 );</span><br><span class="line">buffer.limit(buffer.capacity());</span><br><span class="line">byte[] array = buffer.array();</span><br></pre></td></tr></table></figure>
<h5 id="-18"><a href="#-18" class="headerlink" title></a></h5><h4 id="只读缓冲区"><a href="#只读缓冲区" class="headerlink" title="只读缓冲区"></a>只读缓冲区</h4><h4 id="通过buffer的asReadOnlyBuffer-方法获得一个新的只读缓冲区，所谓的只读缓冲区"><a href="#通过buffer的asReadOnlyBuffer-方法获得一个新的只读缓冲区，所谓的只读缓冲区" class="headerlink" title="通过buffer的asReadOnlyBuffer()方法获得一个新的只读缓冲区，所谓的只读缓冲区"></a>通过buffer的asReadOnlyBuffer()方法获得一个新的只读缓冲区，所谓的只读缓冲区</h4><h4 id="就是只能读不能写。只读缓冲区与原缓冲区共享同一片数据空间，原缓冲区数据发"><a href="#就是只能读不能写。只读缓冲区与原缓冲区共享同一片数据空间，原缓冲区数据发" class="headerlink" title="就是只能读不能写。只读缓冲区与原缓冲区共享同一片数据空间，原缓冲区数据发"></a>就是只能读不能写。只读缓冲区与原缓冲区共享同一片数据空间，原缓冲区数据发</h4><h4 id="生改变，只读缓冲区也能看到变化后的数据，因为它们共享同一片存储空间。"><a href="#生改变，只读缓冲区也能看到变化后的数据，因为它们共享同一片存储空间。" class="headerlink" title="生改变，只读缓冲区也能看到变化后的数据，因为它们共享同一片存储空间。"></a>生改变，只读缓冲区也能看到变化后的数据，因为它们共享同一片存储空间。</h4><h4 id="直接缓冲区"><a href="#直接缓冲区" class="headerlink" title="直接缓冲区"></a>直接缓冲区</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(&quot;buffer:&quot;+ Arrays.toString(array));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="-19"><a href="#-19" class="headerlink" title></a></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">package com.qf.channel.buffer;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import java.nio.ByteBuffer;</span><br><span class="line">import java.util.Arrays;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 只读缓冲区</span><br><span class="line">* @author htt</span><br><span class="line">* doublepeach</span><br><span class="line">*/</span><br><span class="line">public class Demo2 &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">ByteBuffer buffer = ByteBuffer.wrap(new byte[]&#123; 1 , 2 , 3 , 4 ,</span><br><span class="line">5 , 6 , 7 , 8 , 9 &#125;);</span><br><span class="line">ByteBuffer readOnlyBuffer = buffer.asReadOnlyBuffer();</span><br><span class="line">buffer.put( 4 ,(byte) 50 );</span><br><span class="line">while(readOnlyBuffer.hasRemaining())&#123;</span><br><span class="line">System.out.println(readOnlyBuffer.get());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="-20"><a href="#-20" class="headerlink" title></a></h5><h4 id="直接缓冲区，Java虚拟机将尽最大努力直接对其执行本机I-x2F-O操作。也就是说，它将"><a href="#直接缓冲区，Java虚拟机将尽最大努力直接对其执行本机I-x2F-O操作。也就是说，它将" class="headerlink" title="直接缓冲区，Java虚拟机将尽最大努力直接对其执行本机I&#x2F;O操作。也就是说，它将"></a>直接缓冲区，Java虚拟机将尽最大努力直接对其执行本机I&#x2F;O操作。也就是说，它将</h4><h4 id="试图避免在每次调用底层操作系统的本机I-x2F-O操作之前（或之后），将缓冲区的内容"><a href="#试图避免在每次调用底层操作系统的本机I-x2F-O操作之前（或之后），将缓冲区的内容" class="headerlink" title="试图避免在每次调用底层操作系统的本机I&#x2F;O操作之前（或之后），将缓冲区的内容"></a>试图避免在每次调用底层操作系统的本机I&#x2F;O操作之前（或之后），将缓冲区的内容</h4><h4 id="复制到中间缓冲区（或从中间缓冲区复制）。"><a href="#复制到中间缓冲区（或从中间缓冲区复制）。" class="headerlink" title="复制到中间缓冲区（或从中间缓冲区复制）。"></a>复制到中间缓冲区（或从中间缓冲区复制）。</h4><h4 id="可以通过调用此类的allocateDirect工厂方法来创建直接字节缓冲区。此方法返回的"><a href="#可以通过调用此类的allocateDirect工厂方法来创建直接字节缓冲区。此方法返回的" class="headerlink" title="可以通过调用此类的allocateDirect工厂方法来创建直接字节缓冲区。此方法返回的"></a>可以通过调用此类的allocateDirect工厂方法来创建直接字节缓冲区。此方法返回的</h4><h4 id="缓冲区通常比非直接缓冲区具有更高的分配和释放成本。直接缓冲区的内容可能位"><a href="#缓冲区通常比非直接缓冲区具有更高的分配和释放成本。直接缓冲区的内容可能位" class="headerlink" title="缓冲区通常比非直接缓冲区具有更高的分配和释放成本。直接缓冲区的内容可能位"></a>缓冲区通常比非直接缓冲区具有更高的分配和释放成本。直接缓冲区的内容可能位</h4><h4 id="于正常垃圾收集堆之外，因此它们对应用程序内存占用的影响可能不明显。"><a href="#于正常垃圾收集堆之外，因此它们对应用程序内存占用的影响可能不明显。" class="headerlink" title="于正常垃圾收集堆之外，因此它们对应用程序内存占用的影响可能不明显。"></a>于正常垃圾收集堆之外，因此它们对应用程序内存占用的影响可能不明显。</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">package com.qf.channel.buffer;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileNotFoundException;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.nio.ByteBuffer;</span><br><span class="line">import java.nio.channels.FileChannel;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 直接缓冲区</span><br><span class="line">* @author htt</span><br><span class="line">* doublepeach</span><br><span class="line">*/</span><br><span class="line">public class Demo3 &#123;</span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">FileInputStream fis = new FileInputStream(&quot;1.txt&quot;);</span><br><span class="line">FileChannel fisChannel = fis.getChannel();</span><br><span class="line">FileOutputStream fos = new FileOutputStream(&quot;7.txt&quot;);</span><br><span class="line">FileChannel fosChannel = fos.getChannel();</span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocateDirect( 1024 );</span><br><span class="line">int len = 0 ;</span><br><span class="line">while((len = fisChannel.read(buffer))&gt; 0 )&#123;</span><br><span class="line">buffer.flip();</span><br><span class="line">fosChannel.write(buffer);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;复制完毕&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="-21"><a href="#-21" class="headerlink" title></a></h5><h4 id="基于内存映射的Buffer"><a href="#基于内存映射的Buffer" class="headerlink" title="基于内存映射的Buffer"></a>基于内存映射的Buffer</h4><h4 id="MappedByteBuffer采用direct-buffer的方式读写文件内容-这种方式就是内存映射。"><a href="#MappedByteBuffer采用direct-buffer的方式读写文件内容-这种方式就是内存映射。" class="headerlink" title="MappedByteBuffer采用direct buffer的方式读写文件内容,这种方式就是内存映射。"></a>MappedByteBuffer采用direct buffer的方式读写文件内容,这种方式就是内存映射。</h4><h4 id="这种方式直接调用系统底层的缓存-没有JVM和系统之间的复制操作，所以效率非常"><a href="#这种方式直接调用系统底层的缓存-没有JVM和系统之间的复制操作，所以效率非常" class="headerlink" title="这种方式直接调用系统底层的缓存,没有JVM和系统之间的复制操作，所以效率非常"></a>这种方式直接调用系统底层的缓存,没有JVM和系统之间的复制操作，所以效率非常</h4><h4 id="高，主要用于操作大文件。"><a href="#高，主要用于操作大文件。" class="headerlink" title="高，主要用于操作大文件。"></a>高，主要用于操作大文件。</h4><h4 id="通过FileChannel的map方法得到MappedByteBuffer，MappedByteBuffer把磁盘中文"><a href="#通过FileChannel的map方法得到MappedByteBuffer，MappedByteBuffer把磁盘中文" class="headerlink" title="通过FileChannel的map方法得到MappedByteBuffer，MappedByteBuffer把磁盘中文"></a>通过FileChannel的map方法得到MappedByteBuffer，MappedByteBuffer把磁盘中文</h4><h4 id="件的内容映射到计算机的虚拟内存中，操作MappedByteBuffer直接操作内存中的数"><a href="#件的内容映射到计算机的虚拟内存中，操作MappedByteBuffer直接操作内存中的数" class="headerlink" title="件的内容映射到计算机的虚拟内存中，操作MappedByteBuffer直接操作内存中的数"></a>件的内容映射到计算机的虚拟内存中，操作MappedByteBuffer直接操作内存中的数</h4><h4 id="据，而无需每次通过IO来读取物理磁盘中的文件，效率极高。"><a href="#据，而无需每次通过IO来读取物理磁盘中的文件，效率极高。" class="headerlink" title="据，而无需每次通过IO来读取物理磁盘中的文件，效率极高。"></a>据，而无需每次通过IO来读取物理磁盘中的文件，效率极高。</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">package com.qf.channel.buffer;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.RandomAccessFile;</span><br><span class="line">import java.nio.ByteBuffer;</span><br><span class="line">import java.nio.MappedByteBuffer;</span><br><span class="line">import java.nio.channels.FileChannel;</span><br><span class="line">import java.util.Arrays;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 内存映射缓冲区</span><br><span class="line">* @author htt</span><br><span class="line">* doublepeach</span><br><span class="line">*/</span><br><span class="line">public class Demo4 &#123;</span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">File file = new File(&quot;1.txt&quot;);</span><br><span class="line">RandomAccessFile fis = new RandomAccessFile(file,&quot;rw&quot;);</span><br><span class="line">FileChannel fisChannel = fis.getChannel();</span><br><span class="line">MappedByteBuffer mappedByteBuffer =</span><br><span class="line">fisChannel.map(FileChannel.MapMode.READ_ONLY, 0 ,file.length());</span><br><span class="line">while(mappedByteBuffer.hasRemaining())&#123;</span><br><span class="line">System.out.print((char)mappedByteBuffer.get());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="-22"><a href="#-22" class="headerlink" title></a></h5><h1 id="五、NIO-Selector详解"><a href="#五、NIO-Selector详解" class="headerlink" title="五、NIO-Selector详解"></a>五、NIO-Selector详解</h1><h2 id="1-Selector概述"><a href="#1-Selector概述" class="headerlink" title="1.Selector概述"></a>1.Selector概述</h2><h4 id="Selector选择器，也可以称为多路复用器。它是Java-NIO的核心组件之一，用于检查"><a href="#Selector选择器，也可以称为多路复用器。它是Java-NIO的核心组件之一，用于检查" class="headerlink" title="Selector选择器，也可以称为多路复用器。它是Java NIO的核心组件之一，用于检查"></a>Selector选择器，也可以称为多路复用器。它是Java NIO的核心组件之一，用于检查</h4><h4 id="一个或多个Channel的状态是否处于可读、可写、可连接、可接收等。通过一个"><a href="#一个或多个Channel的状态是否处于可读、可写、可连接、可接收等。通过一个" class="headerlink" title="一个或多个Channel的状态是否处于可读、可写、可连接、可接收等。通过一个"></a>一个或多个Channel的状态是否处于可读、可写、可连接、可接收等。通过一个</h4><h4 id="Selector选择器管理多个Channel，可以实现一个线程管理多个Channel对应的网络"><a href="#Selector选择器管理多个Channel，可以实现一个线程管理多个Channel对应的网络" class="headerlink" title="Selector选择器管理多个Channel，可以实现一个线程管理多个Channel对应的网络"></a>Selector选择器管理多个Channel，可以实现一个线程管理多个Channel对应的网络</h4><h4 id="连接。使用单线程管理多个Channel可以避免多线程的线程上下文切换带来的额外"><a href="#连接。使用单线程管理多个Channel可以避免多线程的线程上下文切换带来的额外" class="headerlink" title="连接。使用单线程管理多个Channel可以避免多线程的线程上下文切换带来的额外"></a>连接。使用单线程管理多个Channel可以避免多线程的线程上下文切换带来的额外</h4><h4 id="开销。"><a href="#开销。" class="headerlink" title="开销。"></a>开销。</h4><h2 id="2-SelectableChannel可选择通道"><a href="#2-SelectableChannel可选择通道" class="headerlink" title="2.SelectableChannel可选择通道"></a>2.SelectableChannel可选择通道</h2><h4 id="只有SelectableChannel才能被Selector管理，比如所有的Socket通道。而FileChannel"><a href="#只有SelectableChannel才能被Selector管理，比如所有的Socket通道。而FileChannel" class="headerlink" title="只有SelectableChannel才能被Selector管理，比如所有的Socket通道。而FileChannel"></a>只有SelectableChannel才能被Selector管理，比如所有的Socket通道。而FileChannel</h4><h4 id="并没有继承SelectableChannel，因此不能被Selector管理。"><a href="#并没有继承SelectableChannel，因此不能被Selector管理。" class="headerlink" title="并没有继承SelectableChannel，因此不能被Selector管理。"></a>并没有继承SelectableChannel，因此不能被Selector管理。</h4><h2 id="3-Channel注册到Selector上"><a href="#3-Channel注册到Selector上" class="headerlink" title="3.Channel注册到Selector上"></a>3.Channel注册到Selector上</h2><h5 id="27"><a href="#27" class="headerlink" title="27 }"></a>27 }</h5><h5 id="28"><a href="#28" class="headerlink" title="28"></a>28</h5><h4 id="Channel通过注册的方式关联Selector。一个Channel可以注册到多个Selector上，但"><a href="#Channel通过注册的方式关联Selector。一个Channel可以注册到多个Selector上，但" class="headerlink" title="Channel通过注册的方式关联Selector。一个Channel可以注册到多个Selector上，但"></a>Channel通过注册的方式关联Selector。一个Channel可以注册到多个Selector上，但</h4><h4 id="在某一个Selector上只能注册一次。注册时需要告知Selector，Selector需要对通道"><a href="#在某一个Selector上只能注册一次。注册时需要告知Selector，Selector需要对通道" class="headerlink" title="在某一个Selector上只能注册一次。注册时需要告知Selector，Selector需要对通道"></a>在某一个Selector上只能注册一次。注册时需要告知Selector，Selector需要对通道</h4><h4 id="的哪个操作感兴趣。"><a href="#的哪个操作感兴趣。" class="headerlink" title="的哪个操作感兴趣。"></a>的哪个操作感兴趣。</h4><h4 id="通道的操作如下："><a href="#通道的操作如下：" class="headerlink" title="通道的操作如下："></a>通道的操作如下：</h4><h4 id="可读：SelectionKey-OP-READ"><a href="#可读：SelectionKey-OP-READ" class="headerlink" title="可读：SelectionKey.OP_READ"></a>可读：SelectionKey.OP_READ</h4><h4 id="可写：SelectionKey-OP-WRITE"><a href="#可写：SelectionKey-OP-WRITE" class="headerlink" title="可写：SelectionKey.OP_WRITE"></a>可写：SelectionKey.OP_WRITE</h4><h4 id="可连接：SelectionKey-OP-CONNECT"><a href="#可连接：SelectionKey-OP-CONNECT" class="headerlink" title="可连接：SelectionKey.OP_CONNECT"></a>可连接：SelectionKey.OP_CONNECT</h4><h4 id="可接收：SelectionKey-OP-ACCEPT"><a href="#可接收：SelectionKey-OP-ACCEPT" class="headerlink" title="可接收：SelectionKey.OP_ACCEPT"></a>可接收：SelectionKey.OP_ACCEPT</h4><h4 id="比如channel调用register方法进行注册到Selector，并告知Selector对哪个操作感兴"><a href="#比如channel调用register方法进行注册到Selector，并告知Selector对哪个操作感兴" class="headerlink" title="比如channel调用register方法进行注册到Selector，并告知Selector对哪个操作感兴"></a>比如channel调用register方法进行注册到Selector，并告知Selector对哪个操作感兴</h4><h4 id="趣："><a href="#趣：" class="headerlink" title="趣："></a>趣：</h4><h4 id="也可以同时注册多个操作："><a href="#也可以同时注册多个操作：" class="headerlink" title="也可以同时注册多个操作："></a>也可以同时注册多个操作：</h4><h4 id="选择器会查询每个一个channel的操作事件，如果是该channel注册的操作已就绪，"><a href="#选择器会查询每个一个channel的操作事件，如果是该channel注册的操作已就绪，" class="headerlink" title="选择器会查询每个一个channel的操作事件，如果是该channel注册的操作已就绪，"></a>选择器会查询每个一个channel的操作事件，如果是该channel注册的操作已就绪，</h4><h4 id="则进行响应。注意，这里channel的操作指的是channel完成某个操作的条件，表示"><a href="#则进行响应。注意，这里channel的操作指的是channel完成某个操作的条件，表示" class="headerlink" title="则进行响应。注意，这里channel的操作指的是channel完成某个操作的条件，表示"></a>则进行响应。注意，这里channel的操作指的是channel完成某个操作的条件，表示</h4><h4 id="该channel对于该操作已处于就绪状态。比如ServerSocketChannel已准备好接收新"><a href="#该channel对于该操作已处于就绪状态。比如ServerSocketChannel已准备好接收新" class="headerlink" title="该channel对于该操作已处于就绪状态。比如ServerSocketChannel已准备好接收新"></a>该channel对于该操作已处于就绪状态。比如ServerSocketChannel已准备好接收新</h4><h4 id="的连接，那么它注册的SelectionKey-OP-ACCEPT操作就处于就绪状态。又比如"><a href="#的连接，那么它注册的SelectionKey-OP-ACCEPT操作就处于就绪状态。又比如" class="headerlink" title="的连接，那么它注册的SelectionKey.OP_ACCEPT操作就处于就绪状态。又比如"></a>的连接，那么它注册的SelectionKey.OP_ACCEPT操作就处于就绪状态。又比如</h4><h4 id="SocketChannel已准备好去连接Server服务器，那么它注册的"><a href="#SocketChannel已准备好去连接Server服务器，那么它注册的" class="headerlink" title="SocketChannel已准备好去连接Server服务器，那么它注册的"></a>SocketChannel已准备好去连接Server服务器，那么它注册的</h4><h4 id="SelectionKey-OP-CONNECT操作就处于就绪状态。于是Selector就可以触发之后"><a href="#SelectionKey-OP-CONNECT操作就处于就绪状态。于是Selector就可以触发之后" class="headerlink" title="SelectionKey.OP_CONNECT操作就处于就绪状态。于是Selector就可以触发之后"></a>SelectionKey.OP_CONNECT操作就处于就绪状态。于是Selector就可以触发之后</h4><h4 id="的动作。"><a href="#的动作。" class="headerlink" title="的动作。"></a>的动作。</h4><h2 id="4-SelectionKey选择键"><a href="#4-SelectionKey选择键" class="headerlink" title="4.SelectionKey选择键"></a>4.SelectionKey选择键</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public final SelectionKey register(Selector sel, int ops)</span><br><span class="line">throws ClosedChannelException</span><br><span class="line">&#123;</span><br><span class="line">return register(sel, ops, null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="-23"><a href="#-23" class="headerlink" title></a></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 channel.register(selector,SelectionKey.OP_READ);</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">channel.register(selector,SelectionKey.OP_READ |</span><br><span class="line">SelectionKey.OP_WRITE);</span><br></pre></td></tr></table></figure>
<h5 id="-24"><a href="#-24" class="headerlink" title></a></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">܉᲋රᙙJavaරᎸᴺ ̓ݩռلဳىJavaຝ຅຾̈́ӥ᫹ಅํ᧞ᑕդᎱ᧞կ݊ૡٍ ᦏದ๞ࢧ୭๜ᧆํጱᕍᶉѺ</span><br></pre></td></tr></table></figure>

<h2 id="4-SelectionKey选择键-1"><a href="#4-SelectionKey选择键-1" class="headerlink" title="4.SelectionKey选择键"></a>4.SelectionKey选择键</h2><h4 id="SelectionKey封装了Channel和注册的操作。"><a href="#SelectionKey封装了Channel和注册的操作。" class="headerlink" title="SelectionKey封装了Channel和注册的操作。"></a>SelectionKey封装了Channel和注册的操作。</h4><h4 id="当Selector调用select-方法时，会轮询所有注册在它身上的Channel，查看是否有处"><a href="#当Selector调用select-方法时，会轮询所有注册在它身上的Channel，查看是否有处" class="headerlink" title="当Selector调用select()方法时，会轮询所有注册在它身上的Channel，查看是否有处"></a>当Selector调用select()方法时，会轮询所有注册在它身上的Channel，查看是否有处</h4><h4 id="于某个操作（已注册到selector上的）就绪状态的Channel，把这些Channel放入到"><a href="#于某个操作（已注册到selector上的）就绪状态的Channel，把这些Channel放入到" class="headerlink" title="于某个操作（已注册到selector上的）就绪状态的Channel，把这些Channel放入到"></a>于某个操作（已注册到selector上的）就绪状态的Channel，把这些Channel放入到</h4><h4 id="SelectionKey的集合中。"><a href="#SelectionKey的集合中。" class="headerlink" title="SelectionKey的集合中。"></a>SelectionKey的集合中。</h4><h2 id="5-Selector的使用"><a href="#5-Selector的使用" class="headerlink" title="5.Selector的使用"></a>5.Selector的使用</h2><h4 id="创建Selector"><a href="#创建Selector" class="headerlink" title="创建Selector"></a>创建Selector</h4><h4 id="通过Selector的open方法创建Selector对象。"><a href="#通过Selector的open方法创建Selector对象。" class="headerlink" title="通过Selector的open方法创建Selector对象。"></a>通过Selector的open方法创建Selector对象。</h4><h4 id="Channel注册到Selector上"><a href="#Channel注册到Selector上" class="headerlink" title="Channel注册到Selector上"></a>Channel注册到Selector上</h4><h4 id="Channel必须处于非阻塞模式才能注册到Selector上。"><a href="#Channel必须处于非阻塞模式才能注册到Selector上。" class="headerlink" title="Channel必须处于非阻塞模式才能注册到Selector上。"></a>Channel必须处于非阻塞模式才能注册到Selector上。</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//创建Selector</span><br><span class="line">Selector selector = Selector.open();</span><br></pre></td></tr></table></figure>
<h5 id="-25"><a href="#-25" class="headerlink" title></a></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">package com.qf.selector;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line">import java.net.InetSocketAddress;</span><br><span class="line">import java.nio.channels.SelectionKey;</span><br><span class="line">import java.nio.channels.Selector;</span><br><span class="line">import java.nio.channels.ServerSocketChannel;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* Selector的使用</span><br><span class="line">* @author htt</span><br><span class="line">* doublepeach</span><br><span class="line">*/</span><br><span class="line">public class Demo1 &#123;</span><br><span class="line">public static void main(String[] args) throws IOException &#123;</span><br></pre></td></tr></table></figure>
<h5 id="-26"><a href="#-26" class="headerlink" title></a></h5><h4 id="Selector轮询就绪状态的Channel"><a href="#Selector轮询就绪状态的Channel" class="headerlink" title="Selector轮询就绪状态的Channel"></a>Selector轮询就绪状态的Channel</h4><h4 id="Selector通过调用select方法轮询已就绪的通道操作。select方法是阻塞的，直到至"><a href="#Selector通过调用select方法轮询已就绪的通道操作。select方法是阻塞的，直到至" class="headerlink" title="Selector通过调用select方法轮询已就绪的通道操作。select方法是阻塞的，直到至"></a>Selector通过调用select方法轮询已就绪的通道操作。select方法是阻塞的，直到至</h4><h4 id="少有一个通道的注册操作已就绪。当完成select方法调用后，被选中的已就绪的所"><a href="#少有一个通道的注册操作已就绪。当完成select方法调用后，被选中的已就绪的所" class="headerlink" title="少有一个通道的注册操作已就绪。当完成select方法调用后，被选中的已就绪的所"></a>少有一个通道的注册操作已就绪。当完成select方法调用后，被选中的已就绪的所</h4><h4 id="有channel通过Selector的selectedKeys-方法获得，该方法获得的是一个"><a href="#有channel通过Selector的selectedKeys-方法获得，该方法获得的是一个" class="headerlink" title="有channel通过Selector的selectedKeys()方法获得，该方法获得的是一个"></a>有channel通过Selector的selectedKeys()方法获得，该方法获得的是一个</h4><h4 id="SelectionKey集合，其中每一个SelectionKey都表示一个Channel。于是可以根据"><a href="#SelectionKey集合，其中每一个SelectionKey都表示一个Channel。于是可以根据" class="headerlink" title="SelectionKey集合，其中每一个SelectionKey都表示一个Channel。于是可以根据"></a>SelectionKey集合，其中每一个SelectionKey都表示一个Channel。于是可以根据</h4><h4 id="SelectionKey的注册操作来做具体的业务处理。"><a href="#SelectionKey的注册操作来做具体的业务处理。" class="headerlink" title="SelectionKey的注册操作来做具体的业务处理。"></a>SelectionKey的注册操作来做具体的业务处理。</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//创建Selector</span><br><span class="line">Selector selector = Selector.open();</span><br><span class="line">//创建ServerSocketChannel</span><br><span class="line">ServerSocketChannel serverSocketChannel =</span><br><span class="line">ServerSocketChannel.open();</span><br><span class="line">//设置为非阻塞模式</span><br><span class="line">serverSocketChannel.configureBlocking(false);</span><br><span class="line">//绑定端口</span><br><span class="line">serverSocketChannel.bind(new InetSocketAddress( 9001 ));</span><br><span class="line">//注册channel并指明注册的操作</span><br><span class="line">SelectionKey selectionKey =</span><br><span class="line">serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="-27"><a href="#-27" class="headerlink" title></a></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">package com.qf.selector;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line">import java.net.InetSocketAddress;</span><br><span class="line">import java.nio.channels.SelectionKey;</span><br><span class="line">import java.nio.channels.Selector;</span><br><span class="line">import java.nio.channels.ServerSocketChannel;</span><br><span class="line">import java.util.Iterator;</span><br><span class="line">import java.util.Set;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* @author htt</span><br><span class="line">* doublepeach</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<h5 id="-28"><a href="#-28" class="headerlink" title></a></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public class Demo2 &#123;</span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">//创建Selector</span><br><span class="line">Selector selector = Selector.open();</span><br><span class="line">//创建ServerSocketChannel</span><br><span class="line">ServerSocketChannel serverSocketChannel =</span><br><span class="line">ServerSocketChannel.open();</span><br><span class="line">//设置为非阻塞模式</span><br><span class="line">serverSocketChannel.configureBlocking(false);</span><br><span class="line">//绑定端口</span><br><span class="line">serverSocketChannel.bind(new InetSocketAddress( 9001 ));</span><br><span class="line">//注册channel并指明注册的操作</span><br><span class="line">SelectionKey selectionKey =</span><br><span class="line">serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">while(true)&#123;</span><br><span class="line">//阻塞等待某个操作就绪状态的Channel</span><br><span class="line">selector.select();</span><br><span class="line">//获得这一次发生操作的多个channel的集合</span><br><span class="line">Set&lt;SelectionKey&gt; selectionKeys =</span><br><span class="line">selector.selectedKeys();</span><br><span class="line">//获得集合的迭代器</span><br><span class="line">Iterator&lt;SelectionKey&gt; iterator =</span><br><span class="line">selectionKeys.iterator();</span><br><span class="line">//遍历集合</span><br><span class="line">while(iterator.hasNext())&#123;</span><br><span class="line">SelectionKey key = iterator.next();</span><br><span class="line">if(key.isReadable())&#123;</span><br><span class="line">//处理读状态的业务</span><br><span class="line">&#125;else if(key.isWritable())&#123;</span><br><span class="line">//处理写状态的业务</span><br><span class="line">&#125;else if(key.isAcceptable())&#123;</span><br><span class="line">//处理接收状态的业务</span><br><span class="line">&#125;else if(key.isConnectable())&#123;</span><br><span class="line">//处理连接状态的业务</span><br><span class="line">&#125;</span><br><span class="line">//保证下次channel就绪可以再被选中</span><br><span class="line">iterator.remove();</span><br></pre></td></tr></table></figure>
<h5 id="-29"><a href="#-29" class="headerlink" title></a></h5><h2 id="6-Selector示例"><a href="#6-Selector示例" class="headerlink" title="6.Selector示例"></a>6.Selector示例</h2><h4 id="实现NIO通信的客户端"><a href="#实现NIO通信的客户端" class="headerlink" title="实现NIO通信的客户端"></a>实现NIO通信的客户端</h4><h5 id="-30"><a href="#-30" class="headerlink" title></a></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">package com.qf.selector;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line">import java.net.InetSocketAddress;</span><br><span class="line">import java.nio.ByteBuffer;</span><br><span class="line">import java.nio.channels.SocketChannel;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 客户端实现</span><br><span class="line">* @author htt</span><br><span class="line">* doublepeach</span><br><span class="line">*/</span><br><span class="line">public class NIOClient &#123;</span><br><span class="line">public static void main(String[] args) throws IOException &#123;</span><br><span class="line">//创建Channel</span><br></pre></td></tr></table></figure>
<h5 id="-31"><a href="#-31" class="headerlink" title></a></h5><h4 id="实现NIO通信的服务端"><a href="#实现NIO通信的服务端" class="headerlink" title="实现NIO通信的服务端"></a>实现NIO通信的服务端</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">SocketChannel socketChannel = SocketChannel.open(new</span><br><span class="line">InetSocketAddress(&quot;127.0.0.1&quot;, 9001 ));</span><br><span class="line">//设置非阻塞模式</span><br><span class="line">socketChannel.configureBlocking(false);</span><br><span class="line">//创建buffer</span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate( 1024 );</span><br><span class="line">//buffer中写入数据</span><br><span class="line">buffer.put(&quot;hello selector&quot;.getBytes());</span><br><span class="line">//将buffer中的数据写入通道</span><br><span class="line">buffer.flip();</span><br><span class="line">socketChannel.write(buffer);</span><br><span class="line">//关闭</span><br><span class="line">socketChannel.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="-32"><a href="#-32" class="headerlink" title></a></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">package com.qf.selector;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line">import java.net.InetSocketAddress;</span><br><span class="line">import java.nio.ByteBuffer;</span><br><span class="line">import java.nio.channels.*;</span><br><span class="line">import java.util.Iterator;</span><br><span class="line">import java.util.Set;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 服务端</span><br><span class="line">* @author htt</span><br><span class="line">* doublepeach</span><br><span class="line">*/</span><br><span class="line">public class NIOServer &#123;</span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">//获得Channel</span><br><span class="line">ServerSocketChannel serverSocketChannel =</span><br><span class="line">ServerSocketChannel.open();</span><br></pre></td></tr></table></figure>
<h5 id="-33"><a href="#-33" class="headerlink" title></a></h5><h5 id="x2F-x2F-设置成非阻塞的模式"><a href="#x2F-x2F-设置成非阻塞的模式" class="headerlink" title="&#x2F;&#x2F;设置成非阻塞的模式"></a>&#x2F;&#x2F;设置成非阻塞的模式</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">serverSocketChannel.configureBlocking(false);</span><br><span class="line">//绑定端口号</span><br><span class="line">serverSocketChannel.bind(new InetSocketAddress( 9001 ));</span><br><span class="line">//获得selector</span><br><span class="line">Selector selector = Selector.open();</span><br><span class="line">//注册channel到selector上</span><br><span class="line">serverSocketChannel.register(selector,</span><br><span class="line">SelectionKey.OP_ACCEPT);</span><br><span class="line">//选择器轮询监听</span><br><span class="line">while(true)&#123;</span><br><span class="line">//阻塞等待通道就绪</span><br><span class="line">selector.select();</span><br><span class="line">Set&lt;SelectionKey&gt; selectionKeys =</span><br><span class="line">selector.selectedKeys();</span><br><span class="line">//遍历selectionKeys</span><br><span class="line">Iterator&lt;SelectionKey&gt; iterator =</span><br><span class="line">selectionKeys.iterator();</span><br><span class="line">while(iterator.hasNext())&#123;</span><br><span class="line">SelectionKey key = iterator.next();</span><br><span class="line">if(key.isAcceptable())&#123;</span><br><span class="line">//准备好接收客户端的连接</span><br><span class="line">//通过key获得channel，并且强转成</span><br><span class="line">ServerSocketChannel</span><br><span class="line">ServerSocketChannel channel =</span><br><span class="line">(ServerSocketChannel) key.channel();</span><br><span class="line">//调用channel的accept方法获得SocketChannel</span><br><span class="line">SocketChannel socketChannel =</span><br><span class="line">channel.accept();</span><br><span class="line">//设置成非阻塞</span><br><span class="line">socketChannel.configureBlocking(false);</span><br><span class="line">//将channel注册到selector上，并让selector对读感兴</span><br><span class="line">趣，为下次读数据做准备</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">socketChannel.register(selector,SelectionKey.OP_READ);</span><br><span class="line">&#125;else if(key.isReadable())&#123;</span><br><span class="line">//准备好读取数据</span><br></pre></td></tr></table></figure>
<h5 id="-34"><a href="#-34" class="headerlink" title></a></h5><h1 id="六、NIO包中的其他类"><a href="#六、NIO包中的其他类" class="headerlink" title="六、NIO包中的其他类"></a>六、NIO包中的其他类</h1><h2 id="1-Pipe"><a href="#1-Pipe" class="headerlink" title="1.Pipe"></a>1.Pipe</h2><h4 id="Java-NIO包中提供了Pipe类，用来实现两个线程之间的单向数据连接。Pipe类中有"><a href="#Java-NIO包中提供了Pipe类，用来实现两个线程之间的单向数据连接。Pipe类中有" class="headerlink" title="Java NIO包中提供了Pipe类，用来实现两个线程之间的单向数据连接。Pipe类中有"></a>Java NIO包中提供了Pipe类，用来实现两个线程之间的单向数据连接。Pipe类中有</h4><h4 id="两个Channel，分别是Sink-Channel和Source-Channel。"><a href="#两个Channel，分别是Sink-Channel和Source-Channel。" class="headerlink" title="两个Channel，分别是Sink Channel和Source Channel。"></a>两个Channel，分别是Sink Channel和Source Channel。</h4><h4 id="Sink-Channel：线程将数据写入到Sink-Channel"><a href="#Sink-Channel：线程将数据写入到Sink-Channel" class="headerlink" title="Sink Channel：线程将数据写入到Sink Channel"></a>Sink Channel：线程将数据写入到Sink Channel</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//通过key获得channel，并且强转成SocketChannel</span><br><span class="line">SocketChannel socketChannel = (SocketChannel)</span><br><span class="line">key.channel();</span><br><span class="line">//设置成非阻塞</span><br><span class="line">socketChannel.configureBlocking(false);</span><br><span class="line">//创建Buffer</span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate( 1024 );</span><br><span class="line">//读数据</span><br><span class="line">int len = 0 ;</span><br><span class="line">while((len = socketChannel.read(buffer))&gt; 0 )&#123;</span><br><span class="line">buffer.flip();</span><br><span class="line">System.out.println(new</span><br><span class="line">String(buffer.array(), 0 ,len));</span><br><span class="line">buffer.clear();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//删除key</span><br><span class="line">iterator.remove();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="-35"><a href="#-35" class="headerlink" title></a></h5><h4 id="Source-Channel：线程从Source-Channel中获取数据"><a href="#Source-Channel：线程从Source-Channel中获取数据" class="headerlink" title="Source Channel：线程从Source Channel中获取数据"></a>Source Channel：线程从Source Channel中获取数据</h4><h4 id="具体的两个线程通过Pipe管道实现数据传输的例子如下："><a href="#具体的两个线程通过Pipe管道实现数据传输的例子如下：" class="headerlink" title="具体的两个线程通过Pipe管道实现数据传输的例子如下："></a>具体的两个线程通过Pipe管道实现数据传输的例子如下：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">package com.qf.other;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line">import java.nio.ByteBuffer;</span><br><span class="line">import java.nio.channels.Pipe;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* @author htt</span><br><span class="line">* doublepeach</span><br><span class="line">*/</span><br><span class="line">public class PipeDemo &#123;</span><br><span class="line">public static void main(String[] args) throws IOException &#123;</span><br><span class="line">//获得pipe</span><br><span class="line">Pipe pipe = Pipe.open();</span><br><span class="line">//负责写的线程</span><br><span class="line">Thread t1 = new Thread1(pipe);</span><br><span class="line">//负责读的线程</span><br><span class="line">Thread t2 = new Thread2(pipe);</span><br><span class="line">//开启线程</span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class Thread1 extends Thread&#123;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private Pipe pipe;</span><br><span class="line">public Thread1(Pipe pipe)&#123;</span><br><span class="line">this.pipe = pipe;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">try &#123;</span><br></pre></td></tr></table></figure>
<h5 id="-36"><a href="#-36" class="headerlink" title></a></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//创建Buffer</span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate( 1024 );</span><br><span class="line">buffer.put(&quot;hello pipe&quot;.getBytes());</span><br><span class="line">buffer.flip();</span><br><span class="line">//获得SinkChannel</span><br><span class="line">Pipe.SinkChannel sinkChannel = pipe.sink();</span><br><span class="line">//将数据写入SinkChannel</span><br><span class="line">sinkChannel.write(buffer);</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class Thread2 extends Thread&#123;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private Pipe pipe;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public Thread2(Pipe pipe) &#123;</span><br><span class="line">this.pipe = pipe;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">try &#123;</span><br><span class="line">//获得SourceChannel</span><br><span class="line">Pipe.SourceChannel sourceChannel = pipe.source();</span><br><span class="line">//创建buffer</span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate( 1024 );</span><br><span class="line">int len = 0 ;</span><br><span class="line">while((len = sourceChannel.read(buffer))&gt; 0 )&#123;</span><br><span class="line">buffer.flip();</span><br><span class="line">//显示buffer中的数据</span><br><span class="line">System.out.println(new</span><br><span class="line">String(buffer.array(), 0 ,len));</span><br><span class="line">&#125;</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br></pre></td></tr></table></figure>
<h5 id="-37"><a href="#-37" class="headerlink" title></a></h5><h2 id="2-FileLock"><a href="#2-FileLock" class="headerlink" title="2.FileLock"></a>2.FileLock</h2><h4 id="FileLock表示文件锁，通过JVM进程对要操作的文件上锁，在同一时间只允许一个进"><a href="#FileLock表示文件锁，通过JVM进程对要操作的文件上锁，在同一时间只允许一个进" class="headerlink" title="FileLock表示文件锁，通过JVM进程对要操作的文件上锁，在同一时间只允许一个进"></a>FileLock表示文件锁，通过JVM进程对要操作的文件上锁，在同一时间只允许一个进</h4><h4 id="程访问上锁的文件。FileLock文件锁是进程级别，在同一个进程中的多个线程可以"><a href="#程访问上锁的文件。FileLock文件锁是进程级别，在同一个进程中的多个线程可以" class="headerlink" title="程访问上锁的文件。FileLock文件锁是进程级别，在同一个进程中的多个线程可以"></a>程访问上锁的文件。FileLock文件锁是进程级别，在同一个进程中的多个线程可以</h4><h4 id="同时对文件进行操作。"><a href="#同时对文件进行操作。" class="headerlink" title="同时对文件进行操作。"></a>同时对文件进行操作。</h4><h4 id="FileLock文件锁又分成了排它锁和共享锁。"><a href="#FileLock文件锁又分成了排它锁和共享锁。" class="headerlink" title="FileLock文件锁又分成了排它锁和共享锁。"></a>FileLock文件锁又分成了排它锁和共享锁。</h4><h4 id="排它锁：只有获得锁的进程能读写文件。"><a href="#排它锁：只有获得锁的进程能读写文件。" class="headerlink" title="排它锁：只有获得锁的进程能读写文件。"></a>排它锁：只有获得锁的进程能读写文件。</h4><h4 id="共享锁：获得锁的线程可以读文件，但不能写文件。"><a href="#共享锁：获得锁的线程可以读文件，但不能写文件。" class="headerlink" title="共享锁：获得锁的线程可以读文件，但不能写文件。"></a>共享锁：获得锁的线程可以读文件，但不能写文件。</h4><h4 id="具体的实现案例："><a href="#具体的实现案例：" class="headerlink" title="具体的实现案例："></a>具体的实现案例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="-38"><a href="#-38" class="headerlink" title></a></h5><h5 id="x2F-x2F-获得排它锁方式一：阻塞方式获得锁，如果锁被其他进程持有则阻塞"><a href="#x2F-x2F-获得排它锁方式一：阻塞方式获得锁，如果锁被其他进程持有则阻塞" class="headerlink" title="&#x2F;&#x2F;获得排它锁方式一：阻塞方式获得锁，如果锁被其他进程持有则阻塞"></a>&#x2F;&#x2F;获得排它锁方式一：阻塞方式获得锁，如果锁被其他进程持有则阻塞</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">FileLock fileLock = fisChannel.lock();</span><br><span class="line">//获得排它锁方式二：参数1:锁文件的具体哪一部分内容的起始位置，参数2:⻓度，</span><br><span class="line">参数3:是否共享</span><br><span class="line">fisChannel.lock( 0 ,file.length(),false);</span><br><span class="line">//获得排它锁方式三：非阻塞的方式获得锁，如果锁被其他进程持有则直接返回</span><br><span class="line">null，不阻塞</span><br><span class="line">FileLock fileLock = fisChannel.tryLock();</span><br><span class="line">//获得排它锁方式四：非阻塞的方式获得锁</span><br><span class="line">FileLock fileLock = fisChannel.tryLock( 0 ,file.length(),false);</span><br></pre></td></tr></table></figure>
<h5 id="1-2-3-4-5-6-7-8"><a href="#1-2-3-4-5-6-7-8" class="headerlink" title="1 2 3 4 5 6 7 8"></a>1 2 3 4 5 6 7 8</h5><h5 id="x2F-x2F-获得共享锁方，参数1-锁文件的具体哪一部分内容的起始位置，参数2-⻓度，参数"><a href="#x2F-x2F-获得共享锁方，参数1-锁文件的具体哪一部分内容的起始位置，参数2-⻓度，参数" class="headerlink" title="&#x2F;&#x2F;获得共享锁方，参数1:锁文件的具体哪一部分内容的起始位置，参数2:⻓度，参数"></a>&#x2F;&#x2F;获得共享锁方，参数1:锁文件的具体哪一部分内容的起始位置，参数2:⻓度，参数</h5><h5 id="3-是否共享"><a href="#3-是否共享" class="headerlink" title="3:是否共享"></a>3:是否共享</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fisChannel.lock( 0 ,file.length(),true)</span><br><span class="line">//获得排它锁方式三：非阻塞的方式获得锁，如果锁被其他进程持有则直接返回</span><br><span class="line">null，不阻塞</span><br><span class="line">FileLock fileLock = fisChannel.tryLock( 0 ,file.length(),true);</span><br></pre></td></tr></table></figure>
<h5 id="-39"><a href="#-39" class="headerlink" title></a></h5><h4 id="进程一：获得锁后阻塞"><a href="#进程一：获得锁后阻塞" class="headerlink" title="进程一：获得锁后阻塞"></a>进程一：获得锁后阻塞</h4><h4 id="进程二：尝试获得锁并写数据"><a href="#进程二：尝试获得锁并写数据" class="headerlink" title="进程二：尝试获得锁并写数据"></a>进程二：尝试获得锁并写数据</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">package com.qf.other;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileNotFoundException;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.nio.channels.FileChannel;</span><br><span class="line">import java.nio.channels.FileLock;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* FileLock文件锁</span><br><span class="line">* @author htt</span><br><span class="line">* doublepeach</span><br><span class="line">*/</span><br><span class="line">public class FileLockDemo1 &#123;</span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">File file = new File(&quot;1.txt&quot;);</span><br><span class="line">FileOutputStream fis = new FileOutputStream(file);</span><br><span class="line">//获得FileChannel</span><br><span class="line">FileChannel fisChannel = fis.getChannel();</span><br><span class="line">//获得拍它锁</span><br><span class="line">FileLock fileLock = fisChannel.lock();</span><br><span class="line">Thread.sleep(100000l);</span><br><span class="line">fileLock.release();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="-40"><a href="#-40" class="headerlink" title></a></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">package com.qf.other;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.nio.ByteBuffer;</span><br></pre></td></tr></table></figure>
<h5 id="-41"><a href="#-41" class="headerlink" title></a></h5><h2 id="3-Path"><a href="#3-Path" class="headerlink" title="3.Path"></a>3.Path</h2><h4 id="Path类在JDK7中已经加入到NIO包内，Path表示文件系统中的路径，和java的io包下"><a href="#Path类在JDK7中已经加入到NIO包内，Path表示文件系统中的路径，和java的io包下" class="headerlink" title="Path类在JDK7中已经加入到NIO包内，Path表示文件系统中的路径，和java的io包下"></a>Path类在JDK7中已经加入到NIO包内，Path表示文件系统中的路径，和java的io包下</h4><h4 id="的File类十分相似。"><a href="#的File类十分相似。" class="headerlink" title="的File类十分相似。"></a>的File类十分相似。</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import java.nio.channels.FileChannel;</span><br><span class="line">import java.nio.channels.FileLock;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* FileLock文件锁</span><br><span class="line">* @author htt</span><br><span class="line">* doublepeach</span><br><span class="line">*/</span><br><span class="line">public class FileLockDemo2 &#123;</span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">File file = new File(&quot;1.txt&quot;);</span><br><span class="line">FileOutputStream fis = new FileOutputStream(file);</span><br><span class="line">//获得FileChannel</span><br><span class="line">FileChannel fisChannel = fis.getChannel();</span><br><span class="line">//获得拍它锁</span><br><span class="line">FileLock fileLock = fisChannel.lock();</span><br><span class="line">fisChannel.write(ByteBuffer.wrap(&quot;hello</span><br><span class="line">lock&quot;.getBytes()));</span><br><span class="line">System.out.println(&quot;写入完毕&quot;);</span><br><span class="line">//释放锁</span><br><span class="line">fileLock.release();</span><br><span class="line">fisChannel.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="-42"><a href="#-42" class="headerlink" title></a></h5><h4 id="Path可以表示绝对路径，即盘符在内的完整路径。Path也可以表示相对路径，即相"><a href="#Path可以表示绝对路径，即盘符在内的完整路径。Path也可以表示相对路径，即相" class="headerlink" title="Path可以表示绝对路径，即盘符在内的完整路径。Path也可以表示相对路径，即相"></a>Path可以表示绝对路径，即盘符在内的完整路径。Path也可以表示相对路径，即相</h4><h4 id="对于其他路径的文件或目录的路径。"><a href="#对于其他路径的文件或目录的路径。" class="headerlink" title="对于其他路径的文件或目录的路径。"></a>对于其他路径的文件或目录的路径。</h4><h2 id="4-Files"><a href="#4-Files" class="headerlink" title="4.Files"></a>4.Files</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">package com.qf.other;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import java.nio.file.Path;</span><br><span class="line">import java.nio.file.Paths;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* Path</span><br><span class="line">* @author htt</span><br><span class="line">* doublepeach</span><br><span class="line">*/</span><br><span class="line">public class PathDemo &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">//创建相对路径</span><br><span class="line">Path path = Paths.get(&quot;1.txt&quot;);</span><br><span class="line">//判断是否是绝对路径</span><br><span class="line">System.out.println(path.isAbsolute());</span><br><span class="line">Path path1 = Paths.get(&quot;/Documents/io-demo/1.txt&quot;);</span><br><span class="line">System.out.println(path1.isAbsolute());</span><br><span class="line">//创建Path的另一种方式</span><br><span class="line">Path path2 = Paths.get(&quot;/Documents/io-demo/&quot;, &quot;2.txt&quot;);</span><br><span class="line">System.out.println(path2.isAbsolute());</span><br><span class="line">//获得父文件夹路径</span><br><span class="line">System.out.println(path1.getParent());</span><br><span class="line">//获得文件名</span><br><span class="line">System.out.println(path1.getFileName());</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="-43"><a href="#-43" class="headerlink" title></a></h5><h4 id="NIO包中的Files类提供了操作文件及目录的一些常用方法。Files需要和Path一起使"><a href="#NIO包中的Files类提供了操作文件及目录的一些常用方法。Files需要和Path一起使" class="headerlink" title="NIO包中的Files类提供了操作文件及目录的一些常用方法。Files需要和Path一起使"></a>NIO包中的Files类提供了操作文件及目录的一些常用方法。Files需要和Path一起使</h4><h4 id="用。"><a href="#用。" class="headerlink" title="用。"></a>用。</h4><h4 id="创建目录的方法：createDirectory"><a href="#创建目录的方法：createDirectory" class="headerlink" title="创建目录的方法：createDirectory()"></a>创建目录的方法：createDirectory()</h4><h4 id="根据Path对象创建一个新目录"><a href="#根据Path对象创建一个新目录" class="headerlink" title="根据Path对象创建一个新目录"></a>根据Path对象创建一个新目录</h4><h4 id="拷⻉文件：copy"><a href="#拷⻉文件：copy" class="headerlink" title="拷⻉文件：copy()"></a>拷⻉文件：copy()</h4><h4 id="实现拷⻉文件的功能，可以通过可选的参数实现文件的覆盖。"><a href="#实现拷⻉文件的功能，可以通过可选的参数实现文件的覆盖。" class="headerlink" title="实现拷⻉文件的功能，可以通过可选的参数实现文件的覆盖。"></a>实现拷⻉文件的功能，可以通过可选的参数实现文件的覆盖。</h4><h4 id="移动文件：move"><a href="#移动文件：move" class="headerlink" title="移动文件：move()"></a>移动文件：move()</h4><h4 id="将文件移动到另一个目录内，如果移动到了同级目录，则为重命名的效果。"><a href="#将文件移动到另一个目录内，如果移动到了同级目录，则为重命名的效果。" class="headerlink" title="将文件移动到另一个目录内，如果移动到了同级目录，则为重命名的效果。"></a>将文件移动到另一个目录内，如果移动到了同级目录，则为重命名的效果。</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">Path path = Paths.get(&quot;myDir&quot;);</span><br><span class="line">//创建目录</span><br><span class="line">Files.createDirectory(path);</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="-44"><a href="#-44" class="headerlink" title></a></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">Path srcPath = Paths.get(&quot;1.txt&quot;);</span><br><span class="line">Path destPath = Paths.get(&quot;9.txt&quot;);</span><br><span class="line">// Files.copy(srcPath,destPath);</span><br><span class="line">//覆盖已存在的文件</span><br><span class="line">Files.copy(srcPath,destPath,</span><br><span class="line">StandardCopyOption.REPLACE_EXISTING);</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="-45"><a href="#-45" class="headerlink" title></a></h5><h4 id="删除文件：delete"><a href="#删除文件：delete" class="headerlink" title="删除文件：delete()"></a>删除文件：delete()</h4><h4 id="删除指定文件。"><a href="#删除指定文件。" class="headerlink" title="删除指定文件。"></a>删除指定文件。</h4><h4 id="遍历目录：walkFileTree"><a href="#遍历目录：walkFileTree" class="headerlink" title="遍历目录：walkFileTree()"></a>遍历目录：walkFileTree()</h4><h4 id="通过walkFileTree-Path-path-FileVisitor-fv-方法可以实现目录的遍历，"><a href="#通过walkFileTree-Path-path-FileVisitor-fv-方法可以实现目录的遍历，" class="headerlink" title="通过walkFileTree(Path path,FileVisitor fv)方法可以实现目录的遍历，"></a>通过walkFileTree(Path path,FileVisitor fv)方法可以实现目录的遍历，</h4><h4 id="通过提供FileVisitor接口的实现类对象来告知遍历文件的具体措施。其中通过返回的"><a href="#通过提供FileVisitor接口的实现类对象来告知遍历文件的具体措施。其中通过返回的" class="headerlink" title="通过提供FileVisitor接口的实现类对象来告知遍历文件的具体措施。其中通过返回的"></a>通过提供FileVisitor接口的实现类对象来告知遍历文件的具体措施。其中通过返回的</h4><h4 id="FileVisitResult告知遍历每一个文件时的具体下一步动作是什么，比如：继续"><a href="#FileVisitResult告知遍历每一个文件时的具体下一步动作是什么，比如：继续" class="headerlink" title="FileVisitResult告知遍历每一个文件时的具体下一步动作是什么，比如：继续"></a>FileVisitResult告知遍历每一个文件时的具体下一步动作是什么，比如：继续</h4><h4 id="（CONTINUE）、终止（TERMINATE）、跳过同级（SKIP-SIBLING）、跳过子级"><a href="#（CONTINUE）、终止（TERMINATE）、跳过同级（SKIP-SIBLING）、跳过子级" class="headerlink" title="（CONTINUE）、终止（TERMINATE）、跳过同级（SKIP_SIBLING）、跳过子级"></a>（CONTINUE）、终止（TERMINATE）、跳过同级（SKIP_SIBLING）、跳过子级</h4><h4 id="（SKIP-SUBTREE）。"><a href="#（SKIP-SUBTREE）。" class="headerlink" title="（SKIP_SUBTREE）。"></a>（SKIP_SUBTREE）。</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">Path srcPath = Paths.get(&quot;1.txt&quot;);</span><br><span class="line">Path destPath = Paths.get(&quot;11.txt&quot;);</span><br><span class="line">Files.move(srcPath,destPath);</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="-46"><a href="#-46" class="headerlink" title></a></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">Path path = Paths.get(&quot;11.txt&quot;);</span><br><span class="line">Files.delete(path);</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="-47"><a href="#-47" class="headerlink" title></a></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Path path = Paths.get(&quot;myDir&quot;);</span><br><span class="line">Files.walkFileTree(path,new SimpleFileVisitor&lt;Path&gt;()&#123;</span><br><span class="line">//具体的遍历操作</span><br><span class="line">@Override</span><br><span class="line">public FileVisitResult visitFile(Path file,</span><br><span class="line">BasicFileAttributes attrs) throws IOException &#123;</span><br><span class="line">//获得当前文件的文件名</span><br><span class="line">String fileName = file.getFileName().toString();</span><br><span class="line">if(&quot;2.txt&quot;.equals(fileName))&#123;</span><br><span class="line">//如果找到则返回文件的绝对路径</span><br></pre></td></tr></table></figure>
<h5 id="-48"><a href="#-48" class="headerlink" title></a></h5><h2 id="5-AsynchronousFileChannel"><a href="#5-AsynchronousFileChannel" class="headerlink" title="5.AsynchronousFileChannel"></a>5.AsynchronousFileChannel</h2><h4 id="在Java7中加入了支持异步操作的文件通道AsynchronousFileChannel，首先要理解"><a href="#在Java7中加入了支持异步操作的文件通道AsynchronousFileChannel，首先要理解" class="headerlink" title="在Java7中加入了支持异步操作的文件通道AsynchronousFileChannel，首先要理解"></a>在Java7中加入了支持异步操作的文件通道AsynchronousFileChannel，首先要理解</h4><h4 id="什么是异步操作。所谓的异步，就是在对文件读写的过程中，程序不需要等待文件"><a href="#什么是异步操作。所谓的异步，就是在对文件读写的过程中，程序不需要等待文件" class="headerlink" title="什么是异步操作。所谓的异步，就是在对文件读写的过程中，程序不需要等待文件"></a>什么是异步操作。所谓的异步，就是在对文件读写的过程中，程序不需要等待文件</h4><h4 id="读写完毕，就可以直接执行之后的代码。可以设置监听程序执行读写完毕之后的操"><a href="#读写完毕，就可以直接执行之后的代码。可以设置监听程序执行读写完毕之后的操" class="headerlink" title="读写完毕，就可以直接执行之后的代码。可以设置监听程序执行读写完毕之后的操"></a>读写完毕，就可以直接执行之后的代码。可以设置监听程序执行读写完毕之后的操</h4><h4 id="作。"><a href="#作。" class="headerlink" title="作。"></a>作。</h4><h4 id="创建异步文件通道"><a href="#创建异步文件通道" class="headerlink" title="创建异步文件通道"></a>创建异步文件通道</h4><h4 id="第一个参数是要异步操作的文件路径，第二个参数是指明使用读操作。"><a href="#第一个参数是要异步操作的文件路径，第二个参数是指明使用读操作。" class="headerlink" title="第一个参数是要异步操作的文件路径，第二个参数是指明使用读操作。"></a>第一个参数是要异步操作的文件路径，第二个参数是指明使用读操作。</h4><h4 id="读取数据的方式一：获得Future的读"><a href="#读取数据的方式一：获得Future的读" class="headerlink" title="读取数据的方式一：获得Future的读"></a>读取数据的方式一：获得Future的读</h4><h4 id="通过异步的读数据，返回Future对象，读数据过程中立即返回Future对象，即时读"><a href="#通过异步的读数据，返回Future对象，读数据过程中立即返回Future对象，即时读" class="headerlink" title="通过异步的读数据，返回Future对象，读数据过程中立即返回Future对象，即时读"></a>通过异步的读数据，返回Future对象，读数据过程中立即返回Future对象，即时读</h4><h4 id="操作还未完成。可以通过Future对象中的isDone-方法得知读操作是否已完成。"><a href="#操作还未完成。可以通过Future对象中的isDone-方法得知读操作是否已完成。" class="headerlink" title="操作还未完成。可以通过Future对象中的isDone()方法得知读操作是否已完成。"></a>操作还未完成。可以通过Future对象中的isDone()方法得知读操作是否已完成。</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(&quot;find</span><br><span class="line">2.txt:&quot;+file.toAbsolutePath());</span><br><span class="line">//终止遍历</span><br><span class="line">return FileVisitResult.TERMINATE;</span><br><span class="line">&#125;</span><br><span class="line">//继续遍历</span><br><span class="line">return FileVisitResult.CONTINUE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h5 id="-49"><a href="#-49" class="headerlink" title></a></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Path path = Paths.get(&quot;7.txt&quot;);</span><br><span class="line">AsynchronousFileChannel asyncFileChannel =</span><br><span class="line">AsynchronousFileChannel.open(path, StandardOpenOption.READ);</span><br></pre></td></tr></table></figure>
<h5 id="-50"><a href="#-50" class="headerlink" title></a></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">package com.qf.other;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line">import java.nio.ByteBuffer;</span><br><span class="line">import java.nio.channels.AsynchronousFileChannel;</span><br><span class="line">import java.nio.file.Path;</span><br></pre></td></tr></table></figure>
<h5 id="-51"><a href="#-51" class="headerlink" title></a></h5><h4 id="读取数据的方式二：使用异步监听的方式"><a href="#读取数据的方式二：使用异步监听的方式" class="headerlink" title="读取数据的方式二：使用异步监听的方式"></a>读取数据的方式二：使用异步监听的方式</h4><h4 id="当读取完成后，会调用CompletionHandler对象的completed方法，在方法中做读取"><a href="#当读取完成后，会调用CompletionHandler对象的completed方法，在方法中做读取" class="headerlink" title="当读取完成后，会调用CompletionHandler对象的completed方法，在方法中做读取"></a>当读取完成后，会调用CompletionHandler对象的completed方法，在方法中做读取</h4><h4 id="数据完毕后的操作。"><a href="#数据完毕后的操作。" class="headerlink" title="数据完毕后的操作。"></a>数据完毕后的操作。</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import java.nio.file.Paths;</span><br><span class="line">import java.nio.file.StandardOpenOption;</span><br><span class="line">import java.util.concurrent.Future;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* AsynchronousFileChannel</span><br><span class="line">* @author htt</span><br><span class="line">* doublepeach</span><br><span class="line">*/</span><br><span class="line">public class AsyncFileChannelDemo &#123;</span><br><span class="line">public static void main(String[] args) throws IOException &#123;</span><br><span class="line">//创建AsynchronousFileChannel</span><br><span class="line">Path path = Paths.get(&quot;7.txt&quot;);</span><br><span class="line">AsynchronousFileChannel asyncFileChannel =</span><br><span class="line">AsynchronousFileChannel.open(path, StandardOpenOption.READ);</span><br><span class="line">//创建buffer</span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate( 1024 );</span><br><span class="line">//读取数据到buffer中</span><br><span class="line">Future&lt;Integer&gt; future = asyncFileChannel.read(buffer, 0 );</span><br><span class="line">//循环等待，直到读完为止，这也是异步的体现</span><br><span class="line">while(!future.isDone());</span><br><span class="line">//翻转buffer</span><br><span class="line">buffer.flip();</span><br><span class="line">//打印数据</span><br><span class="line">System.out.println(new String(buffer.array()));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="-52"><a href="#-52" class="headerlink" title></a></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">package com.qf.other;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line">import java.nio.ByteBuffer;</span><br><span class="line">import java.nio.channels.AsynchronousFileChannel;</span><br></pre></td></tr></table></figure>
<h5 id="-53"><a href="#-53" class="headerlink" title></a></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import java.nio.channels.CompletionHandler;</span><br><span class="line">import java.nio.file.Path;</span><br><span class="line">import java.nio.file.Paths;</span><br><span class="line">import java.nio.file.StandardOpenOption;</span><br><span class="line">import java.util.concurrent.Future;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* AsynchronousFileChannel</span><br><span class="line">* @author htt</span><br><span class="line">* doublepeach</span><br><span class="line">*/</span><br><span class="line">public class AsyncFileChannelDemo2 &#123;</span><br><span class="line">public static void main(String[] args) throws IOException &#123;</span><br><span class="line">//创建AsynchronousFileChannel</span><br><span class="line">Path path = Paths.get(&quot;9.txt&quot;);</span><br><span class="line">AsynchronousFileChannel asyncFileChannel =</span><br><span class="line">AsynchronousFileChannel.open(path, StandardOpenOption.READ);</span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate( 1024 );</span><br><span class="line">asyncFileChannel.read(buffer, 0 , buffer, new</span><br><span class="line">CompletionHandler&lt;Integer, ByteBuffer&gt;() &#123;</span><br><span class="line">@Override</span><br><span class="line">public void completed(Integer result, ByteBuffer</span><br><span class="line">attachment) &#123;</span><br><span class="line">//返回读取的字节个数</span><br><span class="line">System.out.println(&quot;result:&quot;+result);</span><br><span class="line">//打印读取内容</span><br><span class="line">attachment.flip();</span><br><span class="line">System.out.println(new</span><br><span class="line">String(attachment.array()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void failed(Throwable exc, ByteBuffer</span><br><span class="line">attachment) &#123;</span><br><span class="line">System.out.println(&quot;failed&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h5 id="-54"><a href="#-54" class="headerlink" title></a></h5><h4 id="写入数据的方式一：获得Future的写"><a href="#写入数据的方式一：获得Future的写" class="headerlink" title="写入数据的方式一：获得Future的写"></a>写入数据的方式一：获得Future的写</h4><h4 id="通过异步的写数据，返回Future对象，写数据过程中立即返回Future对象，即时写"><a href="#通过异步的写数据，返回Future对象，写数据过程中立即返回Future对象，即时写" class="headerlink" title="通过异步的写数据，返回Future对象，写数据过程中立即返回Future对象，即时写"></a>通过异步的写数据，返回Future对象，写数据过程中立即返回Future对象，即时写</h4><h4 id="操作还未完成。可以通过Future对象中的isDone-方法得知写操作是否已完成。"><a href="#操作还未完成。可以通过Future对象中的isDone-方法得知写操作是否已完成。" class="headerlink" title="操作还未完成。可以通过Future对象中的isDone()方法得知写操作是否已完成。"></a>操作还未完成。可以通过Future对象中的isDone()方法得知写操作是否已完成。</h4><h5 id="x2F-x2F-为了查看效果，让程序等待异步的执行结果"><a href="#x2F-x2F-为了查看效果，让程序等待异步的执行结果" class="headerlink" title="&#x2F;&#x2F;为了查看效果，让程序等待异步的执行结果"></a>&#x2F;&#x2F;为了查看效果，让程序等待异步的执行结果</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">Thread.sleep(10000l);</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="-55"><a href="#-55" class="headerlink" title></a></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">package com.qf.other;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line">import java.nio.ByteBuffer;</span><br><span class="line">import java.nio.channels.AsynchronousFileChannel;</span><br><span class="line">import java.nio.file.Path;</span><br><span class="line">import java.nio.file.Paths;</span><br><span class="line">import java.nio.file.StandardOpenOption;</span><br><span class="line">import java.util.concurrent.Future;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* AsynchronousFileChannel的写</span><br><span class="line">* @author htt</span><br><span class="line">* doublepeach</span><br><span class="line">*/</span><br><span class="line">public class AsyncFileChannelDemo3 &#123;</span><br><span class="line">public static void main(String[] args) throws IOException &#123;</span><br><span class="line">//创建AsynchronousFileChannel,注意，文件必须存在</span><br><span class="line">Path path = Paths.get(&quot;11.txt&quot;);</span><br><span class="line">AsynchronousFileChannel asyncFileChannel =</span><br><span class="line">AsynchronousFileChannel.open(path, StandardOpenOption.WRITE);</span><br><span class="line">//创建buffer</span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate( 1024 );</span><br></pre></td></tr></table></figure>
<h5 id="-56"><a href="#-56" class="headerlink" title></a></h5><h4 id="写入数据的方式二：使用异步监听的方式"><a href="#写入数据的方式二：使用异步监听的方式" class="headerlink" title="写入数据的方式二：使用异步监听的方式"></a>写入数据的方式二：使用异步监听的方式</h4><h4 id="当写数据完成后，会调用CompletionHandler对象的completed方法，在方法中做写"><a href="#当写数据完成后，会调用CompletionHandler对象的completed方法，在方法中做写" class="headerlink" title="当写数据完成后，会调用CompletionHandler对象的completed方法，在方法中做写"></a>当写数据完成后，会调用CompletionHandler对象的completed方法，在方法中做写</h4><h4 id="数据完毕后的操作。-1"><a href="#数据完毕后的操作。-1" class="headerlink" title="数据完毕后的操作。"></a>数据完毕后的操作。</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">buffer.put(&quot;hello async file channel&quot;.getBytes());</span><br><span class="line">buffer.flip();</span><br><span class="line">//写数据</span><br><span class="line">Future&lt;Integer&gt; future = asyncFileChannel.write(buffer,</span><br><span class="line">0 );</span><br><span class="line">//循环等待，直到写完为止，这也是异步的体现</span><br><span class="line">while(!future.isDone());</span><br><span class="line">System.out.println(&quot;写入完成&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">package com.qf.other;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line">import java.nio.ByteBuffer;</span><br><span class="line">import java.nio.channels.AsynchronousFileChannel;</span><br><span class="line">import java.nio.channels.CompletionHandler;</span><br><span class="line">import java.nio.file.Path;</span><br><span class="line">import java.nio.file.Paths;</span><br><span class="line">import java.nio.file.StandardOpenOption;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* AsynchronousFileChannel</span><br><span class="line">* @author htt</span><br><span class="line">* doublepeach</span><br><span class="line">*/</span><br><span class="line">public class AsyncFileChannelDemo4 &#123;</span><br><span class="line">public static void main(String[] args) throws IOException &#123;</span><br><span class="line">//创建AsynchronousFileChannel</span><br><span class="line">Path path = Paths.get(&quot;11.txt&quot;);</span><br><span class="line">AsynchronousFileChannel asyncFileChannel =</span><br><span class="line">AsynchronousFileChannel.open(path, StandardOpenOption.WRITE);</span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate( 1024 );</span><br></pre></td></tr></table></figure>
<h5 id="-57"><a href="#-57" class="headerlink" title></a></h5><h1 id="七、NIO综合案例-聊天室"><a href="#七、NIO综合案例-聊天室" class="headerlink" title="七、NIO综合案例-聊天室"></a>七、NIO综合案例-聊天室</h1><h2 id="1-聊天室服务端编写"><a href="#1-聊天室服务端编写" class="headerlink" title="1.聊天室服务端编写"></a>1.聊天室服务端编写</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">buffer.put(&quot;hello file channel async&quot;.getBytes());</span><br><span class="line">buffer.flip();</span><br><span class="line">asyncFileChannel.write(buffer, 0 , buffer, new</span><br><span class="line">CompletionHandler&lt;Integer, ByteBuffer&gt;() &#123;</span><br><span class="line">@Override</span><br><span class="line">public void completed(Integer result, ByteBuffer</span><br><span class="line">attachment) &#123;</span><br><span class="line">//返回写入的字节个数</span><br><span class="line">System.out.println(&quot;result:&quot;+result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void failed(Throwable exc, ByteBuffer</span><br><span class="line">attachment) &#123;</span><br><span class="line">System.out.println(&quot;failed&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">//为了查看效果，让程序等待异步的执行结果</span><br><span class="line">try &#123;</span><br><span class="line">Thread.sleep(10000l);</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">܉᲋රᙙJavaරᎸᴺ ̓ݩռلဳىJavaຝ຅຾̈́ӥ᫹ಅํ᧞ᑕդᎱ᧞կ݊ૡٍ ᦏದ๞ࢧ୭๜ᧆํጱᕍᶉѺ</span><br></pre></td></tr></table></figure>

<h2 id="1-聊天室服务端编写-1"><a href="#1-聊天室服务端编写-1" class="headerlink" title="1.聊天室服务端编写"></a>1.聊天室服务端编写</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">package com.qf.chat.server;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line">import java.net.InetSocketAddress;</span><br><span class="line">import java.nio.ByteBuffer;</span><br><span class="line">import java.nio.channels.*;</span><br><span class="line">import java.nio.charset.StandardCharsets;</span><br><span class="line">import java.util.Iterator;</span><br><span class="line">import java.util.Set;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* @author htt</span><br><span class="line">* doublepeach</span><br><span class="line">*/</span><br><span class="line">public class ChatServer &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">//创建ServerSocketChannel</span><br><span class="line">ServerSocketChannel serverSocketChannel =</span><br><span class="line">ServerSocketChannel.open();</span><br><span class="line">//绑定端口</span><br><span class="line">serverSocketChannel.bind(new</span><br><span class="line">InetSocketAddress( 9001 ));</span><br><span class="line">//设置成非阻塞模式</span><br><span class="line">serverSocketChannel.configureBlocking(false);</span><br><span class="line">//获得Selector</span><br><span class="line">Selector selector = Selector.open();</span><br><span class="line">//注册Channel到Selector上,并让Selector对接收操作感兴趣</span><br><span class="line">serverSocketChannel.register(selector,</span><br><span class="line">SelectionKey.OP_ACCEPT);</span><br><span class="line">System.out.println(&quot;聊天室服务器已启动&quot;);</span><br><span class="line">//循环等待新客户端的连接</span><br><span class="line">while(true)&#123;</span><br><span class="line">//获得当前已处于就绪状态的Channel的数量</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">int select = selector.select();</span><br><span class="line">if(select== 0 )&#123;</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">//获得就绪状态的Channel集合</span><br><span class="line">Set&lt;SelectionKey&gt; selectionKeys =</span><br><span class="line">selector.selectedKeys();</span><br><span class="line">//遍历Channel集合</span><br><span class="line">Iterator&lt;SelectionKey&gt; iterator =</span><br><span class="line">selectionKeys.iterator();</span><br><span class="line">while(iterator.hasNext())&#123;</span><br><span class="line">SelectionKey key = iterator.next();</span><br><span class="line">//判断channel属于哪个就绪动作</span><br><span class="line">if(key.isAcceptable())&#123;</span><br><span class="line">//有客户端发送连接请求,处理连接请求</span><br><span class="line">handleAccept(key);</span><br><span class="line">&#125;</span><br><span class="line">if(key.isReadable())&#123;</span><br><span class="line">//有客户端向服务端写数据，读取数据</span><br><span class="line">handleRead(key);</span><br><span class="line">&#125;</span><br><span class="line">//移除当前key</span><br><span class="line">iterator.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="-58"><a href="#-58" class="headerlink" title="}"></a>}</h5><h5 id="x2F-1"><a href="#x2F-1" class="headerlink" title="&#x2F;**"></a>&#x2F;**</h5><h5 id="处理客户端写数据的请求——服务端处于读操作的就绪状态"><a href="#处理客户端写数据的请求——服务端处于读操作的就绪状态" class="headerlink" title="* 处理客户端写数据的请求——服务端处于读操作的就绪状态"></a>* 处理客户端写数据的请求——服务端处于读操作的就绪状态</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* @param key</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">private static void handleRead(SelectionKey key) &#123;</span><br><span class="line">//获得SocketChannel</span><br><span class="line">SocketChannel socketChannel = (SocketChannel)</span><br><span class="line">key.channel();</span><br><span class="line">//获得Selector</span><br><span class="line">Selector selector = key.selector();</span><br><span class="line">//创建Buffer</span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate( 1024 );</span><br><span class="line">try &#123;</span><br><span class="line">//读取数据到buffer中</span><br><span class="line">int len = 0 ;</span><br><span class="line">String message = &quot;&quot;;</span><br><span class="line">while((len = socketChannel.read(buffer))&gt; 0 )&#123;</span><br><span class="line">buffer.flip();</span><br><span class="line">//封装message</span><br><span class="line">message += new</span><br><span class="line">String(buffer.array(), 0 ,len,StandardCharsets.UTF_8);</span><br><span class="line">&#125;</span><br><span class="line">//把客户端发送的消息，广播给所有客户端</span><br><span class="line">if(message.length()&gt; 0 )&#123;</span><br><span class="line">//服务端本地打印消息</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(socketChannel.getRemoteAddress()+&quot;:&quot;+message)</span><br><span class="line">;</span><br><span class="line">//广播消息</span><br><span class="line">handleMessage(message,key);</span><br><span class="line">&#125;</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 广播消息给其他客户端</span><br><span class="line">* @param message</span><br></pre></td></tr></table></figure>
<h5 id="-59"><a href="#-59" class="headerlink" title></a></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">* @param key</span><br><span class="line">*/</span><br><span class="line">private static void handleMessage(String message,</span><br><span class="line">SelectionKey key) &#123;</span><br><span class="line">//获得selector</span><br><span class="line">Selector selector = key.selector();</span><br><span class="line">//获得所有注册的channel</span><br><span class="line">Set&lt;SelectionKey&gt; keys = selector.keys();</span><br><span class="line">//遍历</span><br><span class="line">for (SelectionKey selectionKey : keys) &#123;</span><br><span class="line">//获得channel</span><br><span class="line">SelectableChannel channel = selectionKey.channel();</span><br><span class="line">//不发给自己</span><br><span class="line">if(channel != key.channel() &amp;&amp; channel instanceof</span><br><span class="line">SocketChannel)&#123;</span><br><span class="line">SocketChannel socketChannel = (SocketChannel)</span><br><span class="line">channel;</span><br><span class="line">try &#123;</span><br><span class="line">//发送消息</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">socketChannel.write(ByteBuffer.wrap(message.getBytes(StandardCha</span><br><span class="line">rsets.UTF_8)));</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 处理客户端的连接请求</span><br><span class="line">* @param key</span><br><span class="line">*/</span><br><span class="line">private static void handleAccept(SelectionKey key) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">//获得ServerSocketChannel</span><br></pre></td></tr></table></figure>
<h5 id="-60"><a href="#-60" class="headerlink" title></a></h5><h2 id="2-聊天室客户端编写"><a href="#2-聊天室客户端编写" class="headerlink" title="2.聊天室客户端编写"></a>2.聊天室客户端编写</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ServerSocketChannel channel = (ServerSocketChannel)</span><br><span class="line">key.channel();</span><br><span class="line">//获得selector</span><br><span class="line">Selector selector = key.selector();</span><br><span class="line">//获得SocketChannel</span><br><span class="line">SocketChannel socketChannel = channel.accept();</span><br><span class="line">//设置成非阻塞</span><br><span class="line">socketChannel.configureBlocking(false);</span><br><span class="line">//注册到selector上,并让Selector对读操作感兴趣</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">socketChannel.register(selector,SelectionKey.OP_READ);</span><br><span class="line">//服务端向客户端回复消息</span><br><span class="line">socketChannel.write(ByteBuffer.wrap(&quot;欢迎进入千锋聊天</span><br><span class="line">室&quot;.getBytes(StandardCharsets.UTF_8)));</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="-61"><a href="#-61" class="headerlink" title></a></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">package com.qf.chat.client;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line">import java.net.InetSocketAddress;</span><br><span class="line">import java.nio.ByteBuffer;</span><br><span class="line">import java.nio.channels.SelectionKey;</span><br><span class="line">import java.nio.channels.Selector;</span><br><span class="line">import java.nio.channels.SocketChannel;</span><br><span class="line">import java.nio.charset.StandardCharsets;</span><br><span class="line">import java.nio.file.StandardOpenOption;</span><br><span class="line">import java.util.Iterator;</span><br><span class="line">import java.util.Scanner;</span><br></pre></td></tr></table></figure>
<h5 id="-62"><a href="#-62" class="headerlink" title></a></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Set;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 客户端程序</span><br><span class="line">* 1.发送数据到服务端</span><br><span class="line">* 2.接收服务端发来的消息</span><br><span class="line">* @author htt</span><br><span class="line">* doublepeach</span><br><span class="line">*/</span><br><span class="line">public class ChatClient &#123;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 启动客户端的方法</span><br><span class="line">* @param name 聊天室昵称</span><br><span class="line">*/</span><br><span class="line">public void start(String name)&#123;</span><br><span class="line">try &#123;</span><br><span class="line">//创建Channel</span><br><span class="line">SocketChannel socketChannel = SocketChannel.open(new</span><br><span class="line">InetSocketAddress(&quot;127.0.0.1&quot;, 9001 ));</span><br><span class="line">//设置成非阻塞</span><br><span class="line">socketChannel.configureBlocking(false);</span><br><span class="line">//获得Selector</span><br><span class="line">Selector selector = Selector.open();</span><br><span class="line">//注册channel到selector上，让selector对其读操作感兴趣,用于</span><br><span class="line">读取服务端发送来的消息</span><br><span class="line">socketChannel.register(selector,</span><br><span class="line">SelectionKey.OP_READ);</span><br><span class="line">//创建线程，专⻔负责发送消息</span><br><span class="line">new SendMessageThread(socketChannel,name).start();</span><br><span class="line">//循环selector</span><br><span class="line">while(true)&#123;</span><br><span class="line">//获得这次就绪状态的channel的数量</span><br><span class="line">int select = selector.select();</span><br><span class="line">if(select == 0 )&#123;</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="-63"><a href="#-63" class="headerlink" title></a></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">//获得所有的就绪状态的channel</span><br><span class="line">Set&lt;SelectionKey&gt; selectionKeys =</span><br><span class="line">selector.selectedKeys();</span><br><span class="line">Iterator&lt;SelectionKey&gt; iterator =</span><br><span class="line">selectionKeys.iterator();</span><br><span class="line">//遍历</span><br><span class="line">while(iterator.hasNext())&#123;</span><br><span class="line">SelectionKey key = iterator.next();</span><br><span class="line">if(key.isReadable())&#123;</span><br><span class="line">//如果是读操作就绪，说明服务端广播数据了</span><br><span class="line">//获得channel</span><br><span class="line">SocketChannel channel = (SocketChannel)</span><br><span class="line">key.channel();</span><br><span class="line">//创建buffer</span><br><span class="line">ByteBuffer buffer =</span><br><span class="line">ByteBuffer.allocate( 1024 );</span><br><span class="line">//读取</span><br><span class="line">int len = 0 ;</span><br><span class="line">String message = &quot;&quot;;</span><br><span class="line">while((len = channel.read(buffer))&gt; 0 )&#123;</span><br><span class="line">buffer.flip();</span><br><span class="line">//封装message</span><br><span class="line">message += new</span><br><span class="line">String(buffer.array(), 0 ,len, StandardCharsets.UTF_8);</span><br><span class="line">&#125;</span><br><span class="line">//打印消息</span><br><span class="line">System.out.println(message);</span><br><span class="line">//把channel再次注册到selector上，并让</span><br><span class="line">selector对读感兴趣额</span><br><span class="line">channel.register(selector,</span><br><span class="line">SelectionKey.OP_READ);</span><br><span class="line">&#125;</span><br><span class="line">//移除key</span><br><span class="line">iterator.remove();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="-64"><a href="#-64" class="headerlink" title></a></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="-65"><a href="#-65" class="headerlink" title="}"></a>}</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class SendMessageThread extends Thread&#123;</span><br><span class="line">//要发消息的socketchannel</span><br><span class="line">private SocketChannel socketChannel;</span><br><span class="line">//自己的昵称</span><br><span class="line">private String name;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public SendMessageThread(SocketChannel socketChannel, String</span><br><span class="line">name) &#123;</span><br><span class="line">this.socketChannel = socketChannel;</span><br><span class="line">this.name = name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">//控制台输入</span><br><span class="line">Scanner scanner = new Scanner(System.in);</span><br><span class="line">while(scanner.hasNextLine())&#123;</span><br><span class="line">String message = scanner.nextLine();</span><br><span class="line">//带上名字</span><br><span class="line">String sendMessage = name + &quot;:&quot; + message;</span><br><span class="line">//发消息到channel</span><br><span class="line">if(message.length()&gt; 0 )&#123;</span><br><span class="line">try &#123;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">socketChannel.write(ByteBuffer.wrap(sendMessage.getBytes(Standar</span><br><span class="line">dCharsets.UTF_8)));</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br></pre></td></tr></table></figure>
<h5 id="-66"><a href="#-66" class="headerlink" title></a></h5><h1 id="八、Java-AIO"><a href="#八、Java-AIO" class="headerlink" title="八、Java-AIO"></a>八、Java-AIO</h1><h2 id="1-AIO概述"><a href="#1-AIO概述" class="headerlink" title="1.AIO概述"></a>1.AIO概述</h2><h4 id="Asynchronous-IO也称为AIO，即异步非阻塞IO。Java7提供了改进版的NIO，引入了-1"><a href="#Asynchronous-IO也称为AIO，即异步非阻塞IO。Java7提供了改进版的NIO，引入了-1" class="headerlink" title="Asynchronous IO也称为AIO，即异步非阻塞IO。Java7提供了改进版的NIO，引入了"></a>Asynchronous IO也称为AIO，即异步非阻塞IO。Java7提供了改进版的NIO，引入了</h4><h4 id="异步非阻塞的IO，由操作系统完成后回调通知服务端程序启动线程去处理。一般适"><a href="#异步非阻塞的IO，由操作系统完成后回调通知服务端程序启动线程去处理。一般适" class="headerlink" title="异步非阻塞的IO，由操作系统完成后回调通知服务端程序启动线程去处理。一般适"></a>异步非阻塞的IO，由操作系统完成后回调通知服务端程序启动线程去处理。一般适</h4><h4 id="用于连接数较多且连接时间较⻓的应用。"><a href="#用于连接数较多且连接时间较⻓的应用。" class="headerlink" title="用于连接数较多且连接时间较⻓的应用。"></a>用于连接数较多且连接时间较⻓的应用。</h4><h2 id="2-AIO具体实现"><a href="#2-AIO具体实现" class="headerlink" title="2.AIO具体实现"></a>2.AIO具体实现</h2><h4 id="服务端实现"><a href="#服务端实现" class="headerlink" title="服务端实现"></a>服务端实现</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">package com.qf.aio;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line">import java.net.InetSocketAddress;</span><br><span class="line">import java.nio.ByteBuffer;</span><br><span class="line">import java.nio.channels.AsynchronousServerSocketChannel;</span><br><span class="line">import java.nio.channels.AsynchronousSocketChannel;</span><br><span class="line">import java.nio.channels.CompletionHandler;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* AIO</span><br><span class="line">* @author htt</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">* doublepeach</span><br><span class="line">*/</span><br><span class="line">public class AIOServer &#123;</span><br><span class="line">public static void main(String[] args) throws IOException,</span><br><span class="line">InterruptedException &#123;</span><br><span class="line">//创建异步的Server Socket Channel</span><br><span class="line">AsynchronousServerSocketChannel serverSocketChannel =</span><br><span class="line">AsynchronousServerSocketChannel.open();</span><br><span class="line">//绑定端口</span><br><span class="line">serverSocketChannel.bind(new InetSocketAddress( 9001 ));</span><br><span class="line">//异步接收</span><br><span class="line">serverSocketChannel.accept(null, new</span><br><span class="line">CompletionHandler&lt;AsynchronousSocketChannel, Object&gt;() &#123;</span><br><span class="line">/**</span><br><span class="line">* 当有连接发生时调用的方法</span><br><span class="line">*/</span><br><span class="line">@Override</span><br><span class="line">public void completed(AsynchronousSocketChannel</span><br><span class="line">socketChannel, Object attachment) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">//开启接收</span><br><span class="line">serverSocketChannel.accept(attachment,this);</span><br><span class="line">System.out.println(&quot;消息来自</span><br><span class="line">于：&quot;+socketChannel.getRemoteAddress());</span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate( 1024 );</span><br><span class="line">socketChannel.read(buffer, buffer, new</span><br><span class="line">CompletionHandler&lt;Integer, ByteBuffer&gt;() &#123;</span><br><span class="line">@Override</span><br><span class="line">public void completed(Integer result,</span><br><span class="line">ByteBuffer byteBuffer) &#123;</span><br><span class="line">byteBuffer.flip();</span><br><span class="line">//打印收到的消息</span><br><span class="line">System.out.println(new</span><br><span class="line">String(buffer.array(), 0 ,result));</span><br><span class="line">//向客户端返回消息</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socketChannel.write(ByteBuffer.wrap(&quot;hello client&quot;.getBytes()));</span><br></pre></td></tr></table></figure>

<h4 id="客户端实现"><a href="#客户端实现" class="headerlink" title="客户端实现"></a>客户端实现</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void failed(Throwable exc,</span><br><span class="line">ByteBuffer attachment) &#123;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 当连接失败时调用的方法</span><br><span class="line">*/</span><br><span class="line">@Override</span><br><span class="line">public void failed(Throwable exc, Object attachment) &#123;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(&quot;main thread&quot;);</span><br><span class="line">Thread.sleep(Integer.MAX_VALUE);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">package com.qf.aio;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line">import java.net.InetSocketAddress;</span><br><span class="line">import java.nio.ByteBuffer;</span><br><span class="line">import java.nio.channels.AsynchronousSocketChannel;</span><br></pre></td></tr></table></figure>
<h5 id="-67"><a href="#-67" class="headerlink" title></a></h5><h5 id="x2F-2"><a href="#x2F-2" class="headerlink" title="&#x2F;**"></a>&#x2F;**</h5><h5 id="AIO客户端"><a href="#AIO客户端" class="headerlink" title="* AIO客户端"></a>* AIO客户端</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">* @author htt</span><br><span class="line">* doublepeach</span><br><span class="line">*/</span><br><span class="line">public class AIOClient &#123;</span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">AsynchronousSocketChannel socketChannel =</span><br><span class="line">AsynchronousSocketChannel.open();</span><br><span class="line">//调用get方法完成连接</span><br><span class="line">socketChannel.connect(new</span><br><span class="line">InetSocketAddress(&quot;127.0.0.1&quot;, 9001 )).get();</span><br><span class="line">//发送数据</span><br><span class="line">socketChannel.write(ByteBuffer.wrap(&quot;hello</span><br><span class="line">server&quot;.getBytes()));</span><br><span class="line">//获得返回的数据</span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate( 1024 );</span><br><span class="line">int len = 0 ;</span><br><span class="line">//调用get方法实现同步</span><br><span class="line">while((len = socketChannel.read(buffer).get())&gt; 0 )&#123;</span><br><span class="line">System.out.println(&quot;服务端返回的消息：&quot;+new</span><br><span class="line">String(buffer.array(), 0 ,len));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="3-BIO、NIO、AIO对比"><a href="#3-BIO、NIO、AIO对比" class="headerlink" title="3.BIO、NIO、AIO对比"></a>3.BIO、NIO、AIO对比</h2><h5 id="BIONIOAIO"><a href="#BIONIOAIO" class="headerlink" title="BIO				NIO					AIO"></a>BIO				NIO					AIO</h5><p>IO模型			同步阻塞		同步非阻塞		异步非阻塞</p>
<p>编程难度		简单				复杂					复杂</p>
<p>可靠性			查					好						好</p>
<p>吞吐量			低					高						高</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://doublepeach.gitee.io">DoublePeach</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://github.com/DoublePeach/myblog/2023/07/09/NIO%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%88%86%E4%BA%AB/">https://github.com/DoublePeach/myblog/2023/07/09/NIO%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%88%86%E4%BA%AB/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://github.com/DoublePeach/myblog" target="_blank">读万卷书的桃</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/DoublePeach/myblog/tags/Java/">Java</a></div><div class="post_share"><div class="social-share" data-image="/DoublePeach/myblog/img/HuLi.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/DoublePeach/myblog/img/weChat.jpg" target="_blank"><img class="post-qr-code-img" src="/DoublePeach/myblog/img/weChat.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/DoublePeach/myblog/img/payBao.jpg" target="_blank"><img class="post-qr-code-img" src="/DoublePeach/myblog/img/payBao.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/DoublePeach/myblog/2023/11/15/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E7%A5%9E%E7%A7%98%E6%8A%A5%E9%94%99/"><img class="prev-cover" src="/DoublePeach/myblog/img/HuLi.jpg" onerror="onerror=null;src='/DoublePeach/myblog/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">记录一次数据库的神秘报错</div></div></a></div><div class="next-post pull-right"><a href="/DoublePeach/myblog/2023/06/29/%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E5%A4%96%E9%83%A8Javaweb%E3%80%81SSM%E3%80%81SpringBoot%E9%A1%B9%E7%9B%AE%E7%9A%84%E7%BB%8F%E9%AA%8C%E5%B0%8F%E8%AE%B0/"><img class="next-cover" src="/DoublePeach/myblog/img/HuLi.jpg" onerror="onerror=null;src='/DoublePeach/myblog/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">本地部署外部Javaweb、SSM、SpringBoot项目的经验小记</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/DoublePeach/myblog/img/headPic.jpg" onerror="this.onerror=null;this.src='/DoublePeach/myblog/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">DoublePeach</div><div class="author-info__description">愿你像阳光，明媚不忧伤————桃</div></div><div class="card-info-data site-data is-center"><a href="/DoublePeach/myblog/archives/"><div class="headline">文章</div><div class="length-num">24</div></a><a href="/DoublePeach/myblog/tags/"><div class="headline">标签</div><div class="length-num">14</div></a><a href="/DoublePeach/myblog/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://gitee.com/Doublepeach"><i class="fab fa-github"></i><span>访问我的gitee</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/DoublePeach" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:2389242270@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://gitee.com/Doublepeach/Doublepeach/blob/main/img/meQ.jpg" target="_blank" title="QQ"><i class="fa-brands fa-qq"></i></a><a class="social-icon" href="https://gitee.com/Doublepeach/Doublepeach/blob/main/img/meV.jpg" target="_blank" title="微信"><i class="fa-brands fa-weixin"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">嗨！我是桃！欢迎来到我的博客！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">一、概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8BIO%E6%A8%A1%E5%9E%8B%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.1.</span> <span class="toc-text">1.网络编程IO模型介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%EF%BC%89Blocking-IO"><span class="toc-number">1.2.</span> <span class="toc-text">1 ）Blocking IO</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Blocking-IO%E4%B9%9F%E7%A7%B0%E4%B8%BABIO%EF%BC%8C%E5%8D%B3%E5%90%8C%E6%AD%A5%E9%98%BB%E5%A1%9EIO%E3%80%82Java%E7%9A%84io%E5%8C%85%E5%9F%BA%E4%BA%8E%E6%B5%81%E6%A8%A1%E5%9E%8B%E5%AE%9E%E7%8E%B0%EF%BC%8C%E6%8F%90%E4%BE%9B%E4%BA%86File%E3%80%81"><span class="toc-number">1.2.0.1.</span> <span class="toc-text">Blocking IO也称为BIO，即同步阻塞IO。Java的io包基于流模型实现，提供了File、</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FileInputStream%E3%80%81FileOutputStream%E7%AD%89%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81%E7%9A%84%E5%8A%9F%E8%83%BD%E3%80%82Java%E7%9A%84io%E5%8C%85%E4%B8%8B%E6%8F%90%E4%BE%9B%E7%9A%84%E6%B5%81%E6%93%8D"><span class="toc-number">1.2.0.2.</span> <span class="toc-text">FileInputStream、FileOutputStream等输入输出流的功能。Java的io包下提供的流操</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%9C%EF%BC%8C%E4%BA%A4%E4%BA%92%E6%96%B9%E5%BC%8F%E6%98%AF%E5%90%8C%E6%AD%A5%E4%B8%94%E9%98%BB%E5%A1%9E%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%8C%E5%9C%A8%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81%E7%9A%84%E6%93%8D%E4%BD%9C%E8%BF%9B%E8%A1%8C%E8%AF%BB%E3%80%81%E5%86%99%E5%8A%A8%E4%BD%9C%E5%AE%8C%E6%88%90%E4%B9%8B"><span class="toc-number">1.2.0.3.</span> <span class="toc-text">作，交互方式是同步且阻塞的方式，在输入输出流的操作进行读、写动作完成之</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%EF%BC%8C%E7%BA%BF%E7%A8%8B%E4%BC%9A%E4%B8%80%E7%9B%B4%E9%98%BB%E5%A1%9E%E3%80%82%E5%9B%A0%E6%AD%A4io%E5%8C%85%E4%B8%AD%E5%AF%B9%E6%B5%81%E7%9A%84%E6%93%8D%E4%BD%9C%E5%AE%B9%E6%98%93%E9%80%A0%E6%88%90%E6%80%A7%E8%83%BD%E7%9A%84%E7%93%B6%E9%A2%88%E3%80%82"><span class="toc-number">1.2.0.4.</span> <span class="toc-text">前，线程会一直阻塞。因此io包中对流的操作容易造成性能的瓶颈。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E6%A0%B7%E7%9A%84%EF%BC%8C%E5%9C%A8java-net%E5%8C%85%E4%B8%8B%E6%8F%90%E4%BE%9B%E7%9A%84%E9%83%A8%E5%88%86%E7%BD%91%E7%BB%9CAPI%EF%BC%8C%E5%A6%82Socket%E3%80%81ServerSocket%E3%80%81"><span class="toc-number">1.2.0.5.</span> <span class="toc-text">同样的，在java.net包下提供的部分网络API，如Socket、ServerSocket、</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HttpURLConnection%E7%AD%89%EF%BC%8C%E8%BF%9B%E8%A1%8C%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E6%97%B6%EF%BC%8C%E4%B9%9F%E7%94%A8%E5%88%B0%E4%BA%86java-io%E5%8C%85%E4%B8%8B%E7%9A%84%E6%B5%81%E6%93%8D%E4%BD%9C%EF%BC%8C%E5%9B%A0%E6%AD%A4%E4%B9%9F%E5%B1%9E"><span class="toc-number">1.2.0.6.</span> <span class="toc-text">HttpURLConnection等，进行网络通信时，也用到了java.io包下的流操作，因此也属</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8E%E5%90%8C%E6%AD%A5%E4%B8%94%E9%98%BB%E5%A1%9E%E7%9A%84IO%E8%A1%8C%E4%B8%BA%E3%80%82"><span class="toc-number">1.2.0.7.</span> <span class="toc-text">于同步且阻塞的IO行为。</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%EF%BC%89Non-Blocking-IO"><span class="toc-number">1.3.</span> <span class="toc-text">2 ）Non Blocking IO</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Non-Blocking-IO%E4%B9%9F%E7%A7%B0%E4%B8%BANIO%EF%BC%8C%E5%8D%B3%E5%90%8C%E6%AD%A5%E9%9D%9E%E9%98%BB%E5%A1%9EIO%E3%80%82Java1-4%E4%B8%AD%E5%BC%95%E5%85%A5%E4%BA%86NIO%E6%A1%86%E6%9E%B6%EF%BC%8C%E5%9C%A8"><span class="toc-number">1.3.0.1.</span> <span class="toc-text">Non Blocking IO也称为NIO，即同步非阻塞IO。Java1.4中引入了NIO框架，在</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#java-nio%E5%8C%85%E4%B8%AD%E6%8F%90%E4%BE%9B%E4%BA%86Channel%E3%80%81Selector%E3%80%81Buffer%E7%AD%89%E6%8A%BD%E8%B1%A1%E7%B1%BB%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%BF%AB%E9%80%9F%E6%9E%84%E5%BB%BA%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E7%9A%84"><span class="toc-number">1.3.0.2.</span> <span class="toc-text">java.nio包中提供了Channel、Selector、Buffer等抽象类，可以快速构建多路复用的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IO%E7%A8%8B%E5%BA%8F%EF%BC%8C%E7%94%A8%E4%BA%8E%E6%8F%90%E4%BE%9B%E6%9B%B4%E6%8E%A5%E8%BF%91%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BA%95%E5%B1%82%E7%9A%84%E9%AB%98%E6%80%A7%E8%83%BD%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E6%96%B9%E5%BC%8F%E3%80%82"><span class="toc-number">1.3.0.3.</span> <span class="toc-text">IO程序，用于提供更接近操作系统底层的高性能数据操作方式。</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%EF%BC%89Asynchronous-IO"><span class="toc-number">1.4.</span> <span class="toc-text">3 ）Asynchronous IO</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Asynchronous-IO%E4%B9%9F%E7%A7%B0%E4%B8%BAAIO%EF%BC%8C%E5%8D%B3%E5%BC%82%E6%AD%A5%E9%9D%9E%E9%98%BB%E5%A1%9EIO%E3%80%82Java7%E6%8F%90%E4%BE%9B%E4%BA%86%E6%94%B9%E8%BF%9B%E7%89%88%E7%9A%84NIO%EF%BC%8C%E5%BC%95%E5%85%A5%E4%BA%86"><span class="toc-number">1.4.0.1.</span> <span class="toc-text">Asynchronous IO也称为AIO，即异步非阻塞IO。Java7提供了改进版的NIO，引入了</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E9%9D%9E%E9%98%BB%E5%A1%9E%E7%9A%84IO%EF%BC%8C%E7%94%B1%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%8C%E6%88%90%E5%90%8E%E5%9B%9E%E8%B0%83%E9%80%9A%E7%9F%A5%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8%E7%BA%BF%E7%A8%8B%E5%8E%BB%E5%A4%84%E7%90%86%E3%80%82"><span class="toc-number">1.4.0.2.</span> <span class="toc-text">异步非阻塞的IO，由操作系统完成后回调通知服务端程序启动线程去处理。</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-BIO%E7%9A%84%E5%AE%9E%E7%8E%B0%E9%80%BB%E8%BE%91"><span class="toc-number">1.5.</span> <span class="toc-text">2.BIO的实现逻辑</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-BIO%E7%9A%84%E5%AE%9E%E7%8E%B0%E9%80%BB%E8%BE%91-1"><span class="toc-number">1.6.</span> <span class="toc-text">2.BIO的实现逻辑</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8BIO%E5%90%8C%E6%AD%A5%E9%98%BB%E5%A1%9E%E6%A8%A1%E5%9E%8B%E4%B8%8B%EF%BC%8C%E4%B8%80%E4%B8%AA%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%9A%84%E5%8F%AF%E4%BB%A5%E5%BC%80%E5%90%AF%E5%A4%9A%E4%B8%AA%E5%A4%84%E7%90%86%E7%BA%BF%E7%A8%8B%E6%9D%A5%E5%A4%84%E7%90%86%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E8%BF%9E"><span class="toc-number">1.6.0.1.</span> <span class="toc-text">在BIO同步阻塞模型下，一个服务端的可以开启多个处理线程来处理客户端的连</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%EF%BC%8C%E4%BD%86%E6%98%AF%E4%B8%80%E4%B8%AA%E5%A4%84%E7%90%86%E7%BA%BF%E7%A8%8B%E5%8F%AA%E8%83%BD%E5%AF%B9%E5%BA%94%E4%B8%80%E4%B8%AA%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E8%BF%9E%E6%8E%A5%E3%80%82"><span class="toc-number">1.6.0.2.</span> <span class="toc-text">接，但是一个处理线程只能对应一个客户端的连接。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.6.0.3.</span> <span class="toc-text">客户端的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-number">1.6.0.3.1.</span> <span class="toc-text"></span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.6.0.4.</span> <span class="toc-text">单线程服务端的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#x2F-x2F-%E8%BF%9E%E6%8E%A5%E6%9C%8D%E5%8A%A1%E7%AB%AF"><span class="toc-number">1.6.0.4.1.</span> <span class="toc-text">&#x2F;&#x2F;连接服务端</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#-1"><span class="toc-number">1.6.0.4.2.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#-2"><span class="toc-number">1.6.0.4.3.</span> <span class="toc-text"></span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.6.0.5.</span> <span class="toc-text">多线程服务端的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BA%86%E8%A7%A3%E5%86%B3%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%9A%84%E5%90%8C%E6%AD%A5%E9%98%BB%E5%A1%9E%E9%97%AE%E9%A2%98%EF%BC%8CBIO%E6%A8%A1%E5%9E%8B%E4%B8%8B%E5%8F%AF%E4%BB%A5%E8%AE%A9%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%9D%A5%E5%90%8C"><span class="toc-number">1.6.0.6.</span> <span class="toc-text">为了解决单线程服务端的同步阻塞问题，BIO模型下可以让服务端使用多线程来同</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E5%A4%84%E7%90%86%E5%A4%9A%E4%B8%AA%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E8%AF%B7%E6%B1%82%E3%80%82"><span class="toc-number">1.6.0.7.</span> <span class="toc-text">时处理多个客户端的请求。</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-BIO%E7%9A%84%E5%B1%80%E9%99%90"><span class="toc-number">1.7.</span> <span class="toc-text">3.BIO的局限</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E4%B8%8A%E9%9D%A2%E7%9A%84%E4%BE%8B%E5%AD%90%E4%B8%AD%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%87%BA%EF%BC%8CIO%E4%BB%A3%E7%A0%81%E9%87%8CRead%E6%93%8D%E4%BD%9C%E6%98%AF%E9%98%BB%E5%A1%9E%E6%93%8D%E4%BD%9C%EF%BC%8C%E5%A6%82%E6%9E%9C%E8%BF%9E%E6%8E%A5%E4%B8%8D%E5%81%9A%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%86%99"><span class="toc-number">1.7.0.1.</span> <span class="toc-text">在上面的例子中可以看出，IO代码里Read操作是阻塞操作，如果连接不做数据读写</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%EF%BC%8C%E4%BC%9A%E5%AF%BC%E8%87%B4%E7%BA%BF%E7%A8%8B%E9%98%BB%E5%A1%9E%EF%BC%8C%E6%B5%AA%E8%B4%B9%E7%BA%BF%E7%A8%8B%E8%B5%84%E6%BA%90%E3%80%82"><span class="toc-number">1.7.0.2.</span> <span class="toc-text">操作，会导致线程阻塞，浪费线程资源。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%99%A4%E6%AD%A4%E4%B9%8B%E5%A4%96%EF%BC%8C%E5%A6%82%E6%9E%9C%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%AF%B7%E6%B1%82%E8%BF%87%E5%A4%9A%EF%BC%8C%E5%B0%86%E4%BC%9A%E5%AF%BC%E8%87%B4%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%B8%8D%E6%96%AD%E5%88%9B%E5%BB%BA%E5%87%BA%E6%96%B0%E7%9A%84%E7%BA%BF%E7%A8%8B%EF%BC%8C%E5%AF%B9%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">1.7.0.3.</span> <span class="toc-text">除此之外，如果客户端请求过多，将会导致服务端不断创建出新的线程，对服务器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%A0%E6%88%90%E8%BF%87%E5%A4%A7%E5%8E%8B%E5%8A%9B%E3%80%82"><span class="toc-number">1.7.0.4.</span> <span class="toc-text">造成过大压力。</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-BIO%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.8.</span> <span class="toc-text">4.BIO的应用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#BIO%E6%96%B9%E5%BC%8F%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E7%BB%B4%E6%8A%A4%E7%9B%B8%E5%AF%B9%E6%AF%94%E8%BE%83%E7%AE%80%E5%8D%95%EF%BC%8C%E9%80%82%E7%94%A8%E4%BA%8E%E8%BE%83%E5%B0%8F%E4%B8%94%E5%9B%BA%E5%AE%9A%E7%9A%84%E5%BA%94%E7%94%A8%E6%A1%86%E6%9E%B6%E3%80%82"><span class="toc-number">1.8.0.1.</span> <span class="toc-text">BIO方式的使用和维护相对比较简单，适用于较小且固定的应用框架。</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81NIO%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B"><span class="toc-number">2.</span> <span class="toc-text">二、NIO快速开始</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-NIO%E6%A6%82%E8%BF%B0"><span class="toc-number">2.1.</span> <span class="toc-text">1.NIO概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#NIO%EF%BC%88Non-Blocking-IO%EF%BC%89%E6%98%AF%E5%90%8C%E6%AD%A5%E9%9D%9E%E9%98%BB%E5%A1%9E%E7%9A%84IO%EF%BC%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E6%9D%A5%E5%A4%84%E7%90%86%E5%A4%9A%E4%B8%AA"><span class="toc-number">2.1.0.1.</span> <span class="toc-text">NIO（Non Blocking IO）是同步非阻塞的IO，服务器可以使用一个线程来处理多个</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%AF%B7%E6%B1%82%EF%BC%8C%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%8F%91%E9%80%81%E7%9A%84%E8%AF%B7%E6%B1%82%E4%BC%9A%E6%B3%A8%E5%86%8C%E5%88%B0%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%99%A8Selector%E4%B8%8A%EF%BC%8C%E7%94%B1%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%99%A8"><span class="toc-number">2.1.0.2.</span> <span class="toc-text">客户端请求，客户端发送的请求会注册到多路复用器Selector上，由多路复用器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Selector%E8%BD%AE%E8%AF%A2%E5%90%84%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E8%AF%B7%E6%B1%82%E5%B9%B6%E8%BF%9B%E8%A1%8C%E5%A4%84%E7%90%86%E3%80%82"><span class="toc-number">2.1.0.3.</span> <span class="toc-text">Selector轮询各客户端的请求并进行处理。</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-NIO%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.2.</span> <span class="toc-text">2.NIO线程模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#NIO%E5%8C%85%E5%90%AB%E4%B8%89%E5%A4%A7%E7%BB%84%E4%BB%B6%EF%BC%9A"><span class="toc-number">2.2.0.1.</span> <span class="toc-text">NIO包含三大组件：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Channel%E9%80%9A%E9%81%93%EF%BC%9A%E6%AF%8F%E4%B8%AA%E9%80%9A%E9%81%93%E5%AF%B9%E5%BA%94%E4%B8%80%E4%B8%AAbuffer%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">2.2.0.2.</span> <span class="toc-text">Channel通道：每个通道对应一个buffer缓冲区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Buffer%E7%BC%93%E5%86%B2%E5%8C%BA%EF%BC%9Abuffer%E5%BA%95%E5%B1%82%E6%98%AF%E6%95%B0%E7%BB%84%EF%BC%8C%E7%B1%BB%E4%BC%BC%E4%BA%8E%E8%93%84%E6%B0%B4%E6%B1%A0%EF%BC%8Cchannel%E5%B0%B1%E6%98%AF%E6%B0%B4%E7%AE%A1"><span class="toc-number">2.2.0.3.</span> <span class="toc-text">Buffer缓冲区：buffer底层是数组，类似于蓄水池，channel就是水管</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Selector%E9%80%89%E6%8B%A9%E5%99%A8%EF%BC%9Aselector%E5%AF%B9%E5%BA%94%E4%B8%80%E4%B8%AA%E6%88%96%E5%A4%9A%E4%B8%AA%E7%BA%BF%E7%A8%8B%E3%80%82channel%E4%BC%9A%E6%B3%A8%E5%86%8C%E5%88%B0selector%E4%B8%8A%EF%BC%8C%E7%94%B1"><span class="toc-number">2.2.0.4.</span> <span class="toc-text">Selector选择器：selector对应一个或多个线程。channel会注册到selector上，由</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#selector%E6%A0%B9%E6%8D%AEchannel%E8%AF%BB%E5%86%99%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%8F%91%E7%94%9F%E4%BA%A4%E7%BB%99%E6%9F%90%E4%B8%AA%E7%A9%BA%E9%97%B2%E7%BA%BF%E7%A8%8B%E6%9D%A5%E6%89%A7%E8%A1%8C%E3%80%82"><span class="toc-number">2.2.0.5.</span> <span class="toc-text">selector根据channel读写事件的发生交给某个空闲线程来执行。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Buffer%E5%92%8CChannel%E9%83%BD%E6%98%AF%E6%97%A2%E5%8F%AF%E8%AF%BB%E4%B9%9F%E5%8F%AF%E5%86%99%E3%80%82"><span class="toc-number">2.2.0.6.</span> <span class="toc-text">Buffer和Channel都是既可读也可写。</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-NIO%E5%88%9D%E4%BD%93%E9%AA%8C"><span class="toc-number">2.3.</span> <span class="toc-text">3.NIO初体验</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%A8%8B%E5%BA%8F"><span class="toc-number">2.3.0.1.</span> <span class="toc-text">服务端程序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%A8%8B%E5%BA%8F"><span class="toc-number">2.3.0.2.</span> <span class="toc-text">客户端程序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E4%BF%A1%E9%80%BB%E8%BE%91"><span class="toc-number">2.3.0.3.</span> <span class="toc-text">通信逻辑</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81NIO-Channel%E8%AF%A6%E8%A7%A3"><span class="toc-number">3.</span> <span class="toc-text">三、NIO-Channel详解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Channel%E6%A6%82%E8%BF%B0"><span class="toc-number">3.1.</span> <span class="toc-text">1.Channel概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Channel%E5%8D%B3%E9%80%9A%E9%81%93%EF%BC%8C%E8%A1%A8%E7%A4%BA%E6%89%93%E5%BC%80IO%E8%AE%BE%E5%A4%87%E7%9A%84%E8%BF%9E%E6%8E%A5%EF%BC%8C%E6%AF%94%E5%A6%82%E6%89%93%E5%BC%80%E5%88%B0%E6%96%87%E4%BB%B6%E3%80%81Socket%E5%A5%97%E6%8E%A5%E5%AD%97%E7%9A%84%E8%BF%9E%E6%8E%A5%E3%80%82"><span class="toc-number">3.1.0.1.</span> <span class="toc-text">Channel即通道，表示打开IO设备的连接，比如打开到文件、Socket套接字的连接。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E4%BD%BF%E7%94%A8NIO%E6%97%B6%EF%BC%8C%E5%BF%85%E9%A1%BB%E8%A6%81%E8%8E%B7%E5%8F%96%E7%94%A8%E4%BA%8E%E8%BF%9E%E6%8E%A5IO%E8%AE%BE%E5%A4%87%E7%9A%84%E9%80%9A%E9%81%93%E4%BB%A5%E5%8F%8A%E7%94%A8%E4%BA%8E%E5%AE%B9%E7%BA%B3%E6%95%B0%E6%8D%AE%E7%9A%84%E7%BC%93%E5%86%B2%E5%8C%BA%E3%80%82%E9%80%9A"><span class="toc-number">3.1.0.2.</span> <span class="toc-text">在使用NIO时，必须要获取用于连接IO设备的通道以及用于容纳数据的缓冲区。通</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%87%E6%93%8D%E4%BD%9C%E7%BC%93%E5%86%B2%E5%8C%BA%EF%BC%8C%E5%AE%9E%E7%8E%B0%E5%AF%B9%E6%95%B0%E6%8D%AE%E7%9A%84%E5%A4%84%E7%90%86%E3%80%82%E4%B9%9F%E5%B0%B1%E6%98%AF%E8%AF%B4%E6%95%B0%E6%8D%AE%E6%98%AF%E4%BF%9D%E5%AD%98%E5%9C%A8buffer%E7%BC%93%E5%86%B2%E5%8C%BA%E4%B8%AD%E7%9A%84%EF%BC%8C%E9%9C%80"><span class="toc-number">3.1.0.3.</span> <span class="toc-text">过操作缓冲区，实现对数据的处理。也就是说数据是保存在buffer缓冲区中的，需</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A6%81%E9%80%9A%E8%BF%87Channel%E6%9D%A5%E6%93%8D%E4%BD%9C%E7%BC%93%E5%86%B2%E5%8C%BA%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E3%80%82"><span class="toc-number">3.1.0.4.</span> <span class="toc-text">要通过Channel来操作缓冲区中的数据。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Channel%E7%9B%B8%E6%AF%94IO%E6%B5%81%E4%B8%AD%E7%9A%84Stream%E6%9B%B4%E5%8A%A0%E9%AB%98%E6%95%88%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%BC%82%E6%AD%A5%E5%8F%8C%E5%90%91%E4%BC%A0%E8%BE%93%E3%80%82"><span class="toc-number">3.1.0.5.</span> <span class="toc-text">Channel相比IO流中的Stream更加高效，可以异步双向传输。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Channel%E7%9A%84%E4%B8%BB%E8%A6%81%E5%AE%9E%E7%8E%B0%E7%B1%BB%E6%9C%89%E4%BB%A5%E4%B8%8B%E5%87%A0%E4%B8%AA%EF%BC%9A"><span class="toc-number">3.1.0.6.</span> <span class="toc-text">Channel的主要实现类有以下几个：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FileChannel%EF%BC%9A%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6%E7%9A%84%E9%80%9A%E9%81%93"><span class="toc-number">3.1.0.7.</span> <span class="toc-text">FileChannel：读写文件的通道</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SocketChannel%EF%BC%9A%E8%AF%BB%E5%86%99TCP%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E7%9A%84%E9%80%9A%E9%81%93"><span class="toc-number">3.1.0.8.</span> <span class="toc-text">SocketChannel：读写TCP网络数据的通道</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ServerSocketChannel%EF%BC%9A%E5%83%8Fweb%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%80%E6%A0%B7%EF%BC%8C%E7%9B%91%E5%90%AC%E6%96%B0%E8%BF%9B%E6%9D%A5%E7%9A%84TCP%E8%BF%9E%E6%8E%A5%EF%BC%8C%E4%B8%BA%E8%BF%9E%E6%8E%A5%E5%88%9B%E5%BB%BA"><span class="toc-number">3.1.0.9.</span> <span class="toc-text">ServerSocketChannel：像web服务器一样，监听新进来的TCP连接，为连接创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SocketChannel"><span class="toc-number">3.1.0.10.</span> <span class="toc-text">SocketChannel</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DatagramChannel%EF%BC%9A%E8%AF%BB%E5%86%99UDP%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E7%9A%84%E9%80%9A%E9%81%93"><span class="toc-number">3.1.0.11.</span> <span class="toc-text">DatagramChannel：读写UDP网络数据的通道</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-FileChannel%E8%AF%A6%E8%A7%A3"><span class="toc-number">3.2.</span> <span class="toc-text">2.FileChannel详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#FileChannel%E4%BB%8B%E7%BB%8D"><span class="toc-number">3.2.1.</span> <span class="toc-text">FileChannel介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E4%BA%8E%E8%AF%BB%E5%8F%96%E3%80%81%E5%86%99%E5%85%A5%E3%80%81%E6%98%A0%E5%B0%84%E5%92%8C%E6%93%8D%E4%BD%9C%E6%96%87%E4%BB%B6%E7%9A%84%E9%80%9A%E9%81%93%E3%80%82"><span class="toc-number">3.2.1.1.</span> <span class="toc-text">用于读取、写入、映射和操作文件的通道。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E9%80%9A%E9%81%93%E6%98%AF%E8%BF%9E%E6%8E%A5%E5%88%B0%E6%96%87%E4%BB%B6%E7%9A%84%E5%8F%AF%E6%90%9C%E7%B4%A2%E5%AD%97%E8%8A%82%E9%80%9A%E9%81%93%E3%80%82%E5%AE%83%E5%9C%A8%E5%85%B6%E6%96%87%E4%BB%B6%E4%B8%AD%E6%9C%89%E4%B8%80%E4%B8%AA%E5%BD%93%E5%89%8D%E4%BD%8D%E7%BD%AE%EF%BC%8C%E5%8F%AF%E4%BB%A5%E6%9F%A5"><span class="toc-number">3.2.1.2.</span> <span class="toc-text">文件通道是连接到文件的可搜索字节通道。它在其文件中有一个当前位置，可以查</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%A2%E5%92%8C%E4%BF%AE%E6%94%B9%E3%80%82%E6%96%87%E4%BB%B6%E6%9C%AC%E8%BA%AB%E5%8C%85%E5%90%AB%E5%8F%AF%E5%8F%98%E2%BB%93%E5%BA%A6%E7%9A%84%E5%AD%97%E8%8A%82%E5%BA%8F%E5%88%97%EF%BC%8C%E5%8F%AF%E4%BB%A5%E8%AF%BB%E5%8F%96%E5%92%8C%E5%86%99%E5%85%A5%EF%BC%8C%E5%B9%B6%E4%B8%94%E5%8F%AF%E4%BB%A5%E6%9F%A5%E8%AF%A2%E5%85%B6"><span class="toc-number">3.2.1.3.</span> <span class="toc-text">询和修改。文件本身包含可变⻓度的字节序列，可以读取和写入，并且可以查询其</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BD%93%E5%89%8D%E5%A4%A7%E5%B0%8F%E3%80%82%E5%BD%93%E5%86%99%E5%85%A5%E7%9A%84%E5%AD%97%E8%8A%82%E8%B6%85%E8%BF%87%E5%85%B6%E5%BD%93%E5%89%8D%E5%A4%A7%E5%B0%8F%E6%97%B6%EF%BC%8C%E6%96%87%E4%BB%B6%E7%9A%84%E5%A4%A7%E5%B0%8F%E5%A2%9E%E5%8A%A0%EF%BC%9B%E6%96%87%E4%BB%B6%E8%A2%AB%E6%88%AA%E6%96%AD%E6%97%B6%EF%BC%8C%E5%85%B6"><span class="toc-number">3.2.1.4.</span> <span class="toc-text">当前大小。当写入的字节超过其当前大小时，文件的大小增加；文件被截断时，其</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%A7%E5%B0%8F%E4%BC%9A%E5%87%8F%E5%B0%8F%E3%80%82%E6%96%87%E4%BB%B6%E8%BF%98%E5%8F%AF%E8%83%BD%E5%85%B7%E6%9C%89%E4%B8%80%E4%BA%9B%E7%9B%B8%E5%85%B3%E8%81%94%E7%9A%84%E5%85%83%E6%95%B0%E6%8D%AE%EF%BC%8C%E5%A6%82%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E3%80%81%E5%86%85%E5%AE%B9%E7%B1%BB%E5%9E%8B%E5%92%8C%E4%B8%8A%E6%AC%A1"><span class="toc-number">3.2.1.5.</span> <span class="toc-text">大小会减小。文件还可能具有一些相关联的元数据，如访问权限、内容类型和上次</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E6%97%B6%E9%97%B4%EF%BC%9B%E6%AD%A4%E7%B1%BB%E4%B8%8D%E5%AE%9A%E4%B9%89%E5%85%83%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE%E7%9A%84%E6%96%B9%E6%B3%95%E3%80%82"><span class="toc-number">3.2.1.6.</span> <span class="toc-text">修改时间；此类不定义元数据访问的方法。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%99%A4%E4%BA%86%E7%86%9F%E6%82%89%E7%9A%84%E5%AD%97%E8%8A%82%E9%80%9A%E9%81%93%E8%AF%BB%E3%80%81%E5%86%99%E5%92%8C%E5%85%B3%E9%97%AD%E6%93%8D%E4%BD%9C%E5%A4%96%EF%BC%8C%E6%AD%A4%E7%B1%BB%E8%BF%98%E5%AE%9A%E4%B9%89%E4%BA%86%E4%BB%A5%E4%B8%8B%E6%96%87%E4%BB%B6%E7%89%B9%E5%AE%9A%E6%93%8D%E4%BD%9C%EF%BC%9A"><span class="toc-number">3.2.1.7.</span> <span class="toc-text">除了熟悉的字节通道读、写和关闭操作外，此类还定义了以下文件特定操作：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E5%8F%AF%E4%BB%A5%E4%BB%A5%E4%B8%8D%E5%BD%B1%E5%93%8D%E9%80%9A%E9%81%93%E5%BD%93%E5%89%8D%E4%BD%8D%E7%BD%AE%E7%9A%84%E6%96%B9%E5%BC%8F%E5%9C%A8%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E7%BB%9D%E5%AF%B9%E4%BD%8D%E7%BD%AE%E8%AF%BB%E5%8F%96%E6%88%96%E5%86%99%E5%85%A5%E3%80%82"><span class="toc-number">3.2.1.8.</span> <span class="toc-text">字节可以以不影响通道当前位置的方式在文件中的绝对位置读取或写入。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E5%8C%BA%E5%9F%9F%E5%8F%AF%E4%BB%A5%E7%9B%B4%E6%8E%A5%E6%98%A0%E5%B0%84%E5%88%B0%E5%AD%98%E5%82%A8%E5%99%A8%E4%B8%AD%EF%BC%9B%E5%AF%B9%E4%BA%8E%E5%A4%A7%E5%9E%8B%E6%96%87%E4%BB%B6%EF%BC%8C%E8%BF%99%E9%80%9A%E5%B8%B8%E6%AF%94%E8%B0%83%E7%94%A8%E9%80%9A%E5%B8%B8%E7%9A%84%E8%AF%BB"><span class="toc-number">3.2.1.9.</span> <span class="toc-text">文件的区域可以直接映射到存储器中；对于大型文件，这通常比调用通常的读</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%96%E5%86%99%E6%96%B9%E6%B3%95%E6%9B%B4%E6%9C%89%E6%95%88%E3%80%82"><span class="toc-number">3.2.1.10.</span> <span class="toc-text">或写方法更有效。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E6%96%87%E4%BB%B6%E8%BF%9B%E8%A1%8C%E7%9A%84%E6%9B%B4%E6%96%B0%E5%8F%AF%E8%83%BD%E4%BC%9A%E8%A2%AB%E5%BC%BA%E5%88%B6%E8%BE%93%E5%87%BA%E5%88%B0%E5%BA%95%E5%B1%82%E5%AD%98%E5%82%A8%E8%AE%BE%E5%A4%87%EF%BC%8C%E4%BB%A5%E7%A1%AE%E4%BF%9D%E5%9C%A8%E7%B3%BB%E7%BB%9F%E5%B4%A9%E6%BA%83%E6%97%B6%E6%95%B0"><span class="toc-number">3.2.1.11.</span> <span class="toc-text">对文件进行的更新可能会被强制输出到底层存储设备，以确保在系统崩溃时数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8D%AE%E4%B8%8D%E4%BC%9A%E4%B8%A2%E5%A4%B1%E3%80%82"><span class="toc-number">3.2.1.12.</span> <span class="toc-text">据不会丢失。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E5%8F%AF%E4%BB%A5%E4%BB%8E%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%E5%88%B0%E5%8F%A6%E4%B8%80%E4%B8%AA%E9%80%9A%E9%81%93%EF%BC%8C%E5%8F%8D%E4%B9%8B%E4%BA%A6%E7%84%B6%EF%BC%8C%E8%AE%B8%E5%A4%9A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%83%BD%E5%8F%AF%E4%BB%A5%E5%B0%86%E5%85%B6"><span class="toc-number">3.2.1.13.</span> <span class="toc-text">字节可以从一个文件传输到另一个通道，反之亦然，许多操作系统都可以将其</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E4%B8%BA%E7%9B%B4%E6%8E%A5%E4%BB%8E%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%BC%93%E5%AD%98%E8%BF%9B%E8%A1%8C%E9%9D%9E%E5%B8%B8%E5%BF%AB%E9%80%9F%E7%9A%84%E4%BC%A0%E8%BE%93%E3%80%82"><span class="toc-number">3.2.1.14.</span> <span class="toc-text">优化为直接从文件系统缓存进行非常快速的传输。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%80%E4%B8%AA%E5%8C%BA%E5%9F%9F%E5%8F%AF%E4%BB%A5%E8%A2%AB%E9%94%81%E5%AE%9A%E4%BB%A5%E9%98%B2%E6%AD%A2%E5%85%B6%E4%BB%96%E7%A8%8B%E5%BA%8F%E8%AE%BF%E9%97%AE%E3%80%82"><span class="toc-number">3.2.1.15.</span> <span class="toc-text">文件的一个区域可以被锁定以防止其他程序访问。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E4%B8%AA%E5%B9%B6%E5%8F%91%E7%BA%BF%E7%A8%8B%E4%BD%BF%E7%94%A8%E6%96%87%E4%BB%B6%E9%80%9A%E9%81%93%E6%98%AF%E5%AE%89%E5%85%A8%E7%9A%84%E3%80%82%E6%A0%B9%E6%8D%AE%E9%80%9A%E9%81%93%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%8C%87%E5%AE%9A%EF%BC%8C%E5%8F%AF%E4%BB%A5%E9%9A%8F%E6%97%B6%E8%B0%83%E7%94%A8close%E6%96%B9"><span class="toc-number">3.2.1.16.</span> <span class="toc-text">多个并发线程使用文件通道是安全的。根据通道接口的指定，可以随时调用close方</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%95%E3%80%82%E5%9C%A8%E4%BB%BB%E4%BD%95%E7%BB%99%E5%AE%9A%E6%97%B6%E9%97%B4%EF%BC%8C%E5%8F%AA%E6%9C%89%E4%B8%80%E4%B8%AA%E6%B6%89%E5%8F%8A%E9%80%9A%E9%81%93%E4%BD%8D%E7%BD%AE%E6%88%96%E5%8F%AF%E4%BB%A5%E6%94%B9%E5%8F%98%E5%85%B6%E6%96%87%E4%BB%B6%E5%A4%A7%E5%B0%8F%E7%9A%84%E6%93%8D%E4%BD%9C%E6%AD%A3%E5%9C%A8%E8%BF%9B"><span class="toc-number">3.2.1.17.</span> <span class="toc-text">法。在任何给定时间，只有一个涉及通道位置或可以改变其文件大小的操作正在进</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%8C%EF%BC%9B%E5%9C%A8%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%93%8D%E4%BD%9C%E4%BB%8D%E5%9C%A8%E8%BF%9B%E8%A1%8C%E6%97%B6%E5%B0%9D%E8%AF%95%E5%8F%91%E8%B5%B7%E7%AC%AC%E4%BA%8C%E4%B8%AA%E8%BF%99%E6%A0%B7%E7%9A%84%E6%93%8D%E4%BD%9C%E5%B0%86%E8%A2%AB%E9%98%BB%E6%AD%A2%EF%BC%8C%E7%9B%B4%E5%88%B0%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%93%8D"><span class="toc-number">3.2.1.18.</span> <span class="toc-text">行；在第一个操作仍在进行时尝试发起第二个这样的操作将被阻止，直到第一个操</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%9C%E5%AE%8C%E6%88%90%E3%80%82%E5%85%B6%E4%BB%96%E8%A1%8C%E5%8A%A8%EF%BC%8C%E7%89%B9%E5%88%AB%E6%98%AF%E9%87%87%E5%8F%96%E6%98%8E%E7%A1%AE%E7%AB%8B%E5%9C%BA%E7%9A%84%E8%A1%8C%E5%8A%A8%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%90%8C%E6%97%B6%E8%BF%9B%E8%A1%8C%EF%BC%9B%E5%AE%83%E4%BB%AC%E6%98%AF%E5%90%A6%E7%9C%9F%E7%9A%84%E8%BF%99"><span class="toc-number">3.2.1.19.</span> <span class="toc-text">作完成。其他行动，特别是采取明确立场的行动，可以同时进行；它们是否真的这</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B7%E5%81%9A%E5%8F%96%E5%86%B3%E4%BA%8E%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%EF%BC%8C%E5%9B%A0%E6%AD%A4%E6%B2%A1%E6%9C%89%E5%85%B7%E4%BD%93%E8%AF%B4%E6%98%8E%E3%80%82"><span class="toc-number">3.2.1.20.</span> <span class="toc-text">样做取决于底层实现，因此没有具体说明。</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#FileChannel%E7%A4%BA%E4%BE%8B"><span class="toc-number">3.3.</span> <span class="toc-text">FileChannel示例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#FileChannel%E8%AF%BB%E6%96%87%E4%BB%B6"><span class="toc-number">3.3.0.1.</span> <span class="toc-text">FileChannel读文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FileChannel%E5%86%99%E6%95%B0%E6%8D%AE"><span class="toc-number">3.3.0.2.</span> <span class="toc-text">FileChannel写数据</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-3-4-5-6-7"><span class="toc-number">3.3.0.2.1.</span> <span class="toc-text">1 2 3 4 5 6 7</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E9%81%93%E4%B9%8B%E9%97%B4%E4%BC%A0%E8%BE%93%E6%95%B0%E6%8D%AE%E4%B8%80"><span class="toc-number">3.3.0.3.</span> <span class="toc-text">通道之间传输数据一</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#x2F"><span class="toc-number">3.3.0.3.1.</span> <span class="toc-text">&#x2F;**</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E9%81%93%E4%B9%8B%E9%97%B4%E4%BC%A0%E8%BE%93%E6%95%B0%E6%8D%AE%E4%BA%8C"><span class="toc-number">3.3.0.4.</span> <span class="toc-text">通道之间传输数据二</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Socket%E9%80%9A%E9%81%93%E4%BB%8B%E7%BB%8D"><span class="toc-number">3.4.</span> <span class="toc-text">3.Socket通道介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E6%B5%81%E7%9A%84%E8%BF%9E%E6%8E%A5%E9%80%9A%E9%81%93%E3%80%82Socket%E9%80%9A%E9%81%93%E7%94%A8%E4%BA%8E%E7%AE%A1%E7%90%86socket%E5%92%8Csocket%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E9%81%93%E3%80%82Socket%E9%80%9A%E9%81%93%E5%85%B7"><span class="toc-number">3.4.0.1.</span> <span class="toc-text">面向流的连接通道。Socket通道用于管理socket和socket之间的通道。Socket通道具</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E4%BB%A5%E4%B8%8B%E7%89%B9%E7%82%B9%EF%BC%9A"><span class="toc-number">3.4.0.2.</span> <span class="toc-text">有以下特点：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0%E9%9D%9E%E9%98%BB%E5%A1%9E%EF%BC%8C%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%8F%AF%E4%BB%A5%E5%90%8C%E6%97%B6%E7%AE%A1%E7%90%86%E5%A4%9A%E4%B8%AASocket%E8%BF%9E%E6%8E%A5%EF%BC%8C%E6%8F%90%E5%8D%87%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%90%9E%E5%90%90"><span class="toc-number">3.4.0.3.</span> <span class="toc-text">可以实现非阻塞，一个线程可以同时管理多个Socket连接，提升系统的吞吐</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8F%E3%80%82"><span class="toc-number">3.4.0.4.</span> <span class="toc-text">量。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Socket%E9%80%9A%E9%81%93%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%B1%BB%EF%BC%88DatagramChannel%E3%80%81SocketChannel%E5%92%8C"><span class="toc-number">3.4.0.5.</span> <span class="toc-text">Socket通道的实现类（DatagramChannel、SocketChannel和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ServerSocketChannel%EF%BC%89%E5%9C%A8%E8%A2%AB%E5%AE%9E%E4%BE%8B%E5%8C%96%E6%97%B6%E4%BC%9A%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AF%B9%E7%AD%89%E7%9A%84Socket%E5%AF%B9%E8%B1%A1%EF%BC%8C%E4%B9%9F%E5%8F%AF%E4%BB%A5%E4%BB%8E"><span class="toc-number">3.4.0.6.</span> <span class="toc-text">ServerSocketChannel）在被实例化时会创建一个对等的Socket对象，也可以从</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Socket%E5%AF%B9%E8%B1%A1%E4%B8%AD%E9%80%9A%E8%BF%87getChannel-%E6%96%B9%E6%B3%95%E8%8E%B7%E5%BE%97%E5%AF%B9%E5%BA%94%E7%9A%84Channel%E3%80%82"><span class="toc-number">3.4.0.7.</span> <span class="toc-text">Socket对象中通过getChannel()方法获得对应的Channel。</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-ServerSocketChannel%E8%AF%A6%E8%A7%A3"><span class="toc-number">3.5.</span> <span class="toc-text">4.ServerSocketChannel详解</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#-3"><span class="toc-number">3.5.0.0.1.</span> <span class="toc-text"></span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ServerSocketChannel%E6%98%AF%E4%B8%80%E4%B8%AA%E5%9F%BA%E4%BA%8E%E9%80%9A%E9%81%93%E7%9A%84Socket%E7%9B%91%E5%90%AC%E5%99%A8%EF%BC%8C%E8%83%BD%E5%A4%9F%E5%AE%9E%E7%8E%B0%E9%9D%9E%E9%98%BB%E5%A1%9E%E6%A8%A1%E5%BC%8F%E3%80%82"><span class="toc-number">3.5.0.1.</span> <span class="toc-text">ServerSocketChannel是一个基于通道的Socket监听器，能够实现非阻塞模式。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ServerSocketChannel%E7%9A%84%E4%B8%BB%E8%A6%81%E4%BD%9C%E7%94%A8%E6%98%AF%E7%94%A8%E6%9D%A5%E7%9B%91%E5%90%AC%E7%AB%AF%E5%8F%A3%E7%9A%84%E8%BF%9E%E6%8E%A5%EF%BC%8C%E6%9D%A5%E5%88%9B%E5%BB%BASocketChannel%E3%80%82"><span class="toc-number">3.5.0.2.</span> <span class="toc-text">ServerSocketChannel的主要作用是用来监听端口的连接，来创建SocketChannel。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B9%9F%E5%B0%B1%E6%98%AF%E8%AF%B4%EF%BC%8C%E5%8F%AF%E4%BB%A5%E8%B0%83%E7%94%A8ServerSocketChannel%E7%9A%84accept%E6%96%B9%E6%B3%95%EF%BC%8C%E6%9D%A5%E5%88%9B%E5%BB%BASocketChannel%E5%AF%B9"><span class="toc-number">3.5.0.3.</span> <span class="toc-text">也就是说，可以调用ServerSocketChannel的accept方法，来创建SocketChannel对</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B1%A1%E3%80%82"><span class="toc-number">3.5.0.4.</span> <span class="toc-text">象。</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#-4"><span class="toc-number">3.5.0.4.1.</span> <span class="toc-text"></span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-SocketChannel%E8%AF%A6%E8%A7%A3"><span class="toc-number">3.6.</span> <span class="toc-text">5.SocketChannel详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SocketChannel%E4%BB%8B%E7%BB%8D"><span class="toc-number">3.6.1.</span> <span class="toc-text">SocketChannel介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#SocketChannel%E6%98%AF%E8%BF%9E%E6%8E%A5%E5%88%B0TCP%E7%BD%91%E7%BB%9C%E5%A5%97%E6%8E%A5%E5%AD%97%E7%9A%84%E9%80%9A%E9%81%93%EF%BC%8C%E6%9B%B4%E5%A4%9A%E4%BB%A3%E8%A1%A8%E7%9A%84%E6%98%AF%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E6%93%8D%E4%BD%9C%E3%80%82"><span class="toc-number">3.6.1.1.</span> <span class="toc-text">SocketChannel是连接到TCP网络套接字的通道，更多代表的是客户端的操作。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SocketChannel%E5%85%B7%E6%9C%89%E4%BB%A5%E4%B8%8B%E7%89%B9%E7%82%B9%EF%BC%9A"><span class="toc-number">3.6.1.2.</span> <span class="toc-text">SocketChannel具有以下特点：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SocketChannel%E8%BF%9E%E6%8E%A5%E7%9A%84%E6%98%AFSocket%E5%A5%97%E6%8E%A5%E5%AD%97%EF%BC%8C%E4%B9%9F%E5%B0%B1%E6%98%AF%E8%AF%B4%E9%80%9A%E9%81%93%E7%9A%84%E4%B8%A4%E8%BE%B9%E6%98%AFSocket%E5%A5%97%E6%8E%A5%E5%AD%97"><span class="toc-number">3.6.1.3.</span> <span class="toc-text">SocketChannel连接的是Socket套接字，也就是说通道的两边是Socket套接字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SocketChannel%E6%98%AF%E7%94%A8%E6%9D%A5%E5%A4%84%E7%90%86%E7%BD%91%E7%BB%9CIO%E7%9A%84%E9%80%9A%E9%81%93"><span class="toc-number">3.6.1.4.</span> <span class="toc-text">SocketChannel是用来处理网络IO的通道</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SocketChannel%E6%98%AF%E5%8F%AF%E9%80%89%E6%8B%A9%E7%9A%84%EF%BC%8C%E5%8F%AF%E4%BB%A5%E8%A2%AB%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="toc-number">3.6.1.5.</span> <span class="toc-text">SocketChannel是可选择的，可以被多路复用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SocketChannel%E5%9F%BA%E4%BA%8ETCP%E8%BF%9E%E6%8E%A5%E4%BC%A0%E8%BE%93"><span class="toc-number">3.6.1.6.</span> <span class="toc-text">SocketChannel基于TCP连接传输</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SocketChannel%E4%BD%BF%E7%94%A8%E7%BB%86%E8%8A%82"><span class="toc-number">3.6.2.</span> <span class="toc-text">SocketChannel使用细节</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#SocketChannel%E5%9C%A8%E4%BD%BF%E7%94%A8%E4%B8%8A%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E4%BB%A5%E4%B8%8B%E7%BB%86%E8%8A%82%EF%BC%9A"><span class="toc-number">3.6.2.1.</span> <span class="toc-text">SocketChannel在使用上需要注意以下细节：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E8%83%BD%E5%9C%A8%E5%B7%B2%E7%BB%8F%E5%AD%98%E5%9C%A8%E7%9A%84Socket%E4%B8%8A%E5%86%8D%E5%88%9B%E5%BB%BASocketChannel"><span class="toc-number">3.6.2.2.</span> <span class="toc-text">不能在已经存在的Socket上再创建SocketChannel</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SocketChannel%E9%9C%80%E8%A6%81%E6%8C%87%E6%98%8E%E5%85%B3%E8%81%94%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9C%B0%E5%9D%80%E5%8F%8A%E7%AB%AF%E5%8F%A3%E5%90%8E%E6%89%8D%E8%83%BD%E4%BD%BF%E7%94%A8"><span class="toc-number">3.6.2.3.</span> <span class="toc-text">SocketChannel需要指明关联的服务器地址及端口后才能使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%AA%E8%BF%9B%E8%A1%8C%E8%BF%9E%E6%8E%A5%E7%9A%84SocketChannel%E8%BF%9B%E8%A1%8CIO%E6%93%8D%E4%BD%9C%E6%97%B6%E5%B0%86%E6%8A%9B%E5%87%BANotYetConnectedException%E5%BC%82%E5%B8%B8"><span class="toc-number">3.6.2.4.</span> <span class="toc-text">未进行连接的SocketChannel进行IO操作时将抛出NotYetConnectedException异常</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#-5"><span class="toc-number">3.6.2.4.1.</span> <span class="toc-text"></span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E5%90%8D%E7%A7%B0-Description"><span class="toc-number">3.6.2.5.</span> <span class="toc-text">参数名称 Description</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SO-SNDBUF-Socket%E5%8F%91%E9%80%81%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="toc-number">3.6.2.6.</span> <span class="toc-text">SO_SNDBUF Socket发送缓冲区的大小</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SO-RCVBUF-Socket%E6%8E%A5%E5%8F%97%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="toc-number">3.6.2.7.</span> <span class="toc-text">SO_RCVBUF Socket接受缓冲区的大小</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SO-KEEPALIVE-%E4%BF%9D%E6%B4%BB%E8%BF%9E%E6%8E%A5"><span class="toc-number">3.6.2.8.</span> <span class="toc-text">SO_KEEPALIVE 保活连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SO-REUSEADDR-%E5%A4%8D%E7%94%A8%E5%9C%B0%E5%9D%80"><span class="toc-number">3.6.2.9.</span> <span class="toc-text">SO_REUSEADDR 复用地址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SO-LINGER-%E6%9C%89%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E6%97%B6%E5%BB%B6%E7%BC%93%E5%85%B3%E9%97%ADChannel-%E5%8F%AA%E5%9C%A8%E9%9D%9E%E9%98%BB%E5%A1%9E%E6%A8%A1%E5%BC%8F%E4%B8%8B%E4%BD%BF%E7%94%A8"><span class="toc-number">3.6.2.10.</span> <span class="toc-text">SO_LINGER 有数据传输时延缓关闭Channel (只在非阻塞模式下使用)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP-NODELAY-%E7%A6%81%E7%94%A8Nagle%E7%AE%97%E6%B3%95"><span class="toc-number">3.6.2.11.</span> <span class="toc-text">TCP_NODELAY 禁用Nagle算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SocketChannel%E6%94%AF%E6%8C%81%E9%98%BB%E5%A1%9E%E5%92%8C%E9%9D%9E%E9%98%BB%E5%A1%9E%E4%B8%A4%E7%A7%8D%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.6.2.12.</span> <span class="toc-text">SocketChannel支持阻塞和非阻塞两种模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SocketChannel%E6%94%AF%E6%8C%81%E5%BC%82%E6%AD%A5%E5%85%B3%E9%97%AD%E3%80%82"><span class="toc-number">3.6.2.13.</span> <span class="toc-text">SocketChannel支持异步关闭。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SocketChannel%E6%94%AF%E6%8C%81%E8%AE%BE%E5%AE%9A%E5%8F%82%E6%95%B0"><span class="toc-number">3.6.2.14.</span> <span class="toc-text">SocketChannel支持设定参数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SocketChannel%E7%A4%BA%E4%BE%8B"><span class="toc-number">3.6.3.</span> <span class="toc-text">SocketChannel示例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BASocketChannel"><span class="toc-number">3.6.3.1.</span> <span class="toc-text">创建SocketChannel</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E4%B8%80"><span class="toc-number">3.6.3.2.</span> <span class="toc-text">方式一</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E4%BA%8C"><span class="toc-number">3.6.3.3.</span> <span class="toc-text">方式二</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E7%8A%B6%E6%80%81%E6%A0%A1%E9%AA%8C"><span class="toc-number">3.6.3.4.</span> <span class="toc-text">连接状态校验</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#socketChannel-isOpen-%E5%88%A4%E6%96%ADSocketChannel%E6%98%AF%E5%90%A6%E4%B8%BAopen%E7%8A%B6%E6%80%81"><span class="toc-number">3.6.3.5.</span> <span class="toc-text">socketChannel.isOpen(): 判断SocketChannel是否为open状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#socketChannel-isConnected-%E5%88%A4%E6%96%ADSocketChannel%E6%98%AF%E5%90%A6%E5%B7%B2%E8%BF%9E%E6%8E%A5"><span class="toc-number">3.6.3.6.</span> <span class="toc-text">socketChannel.isConnected(): 判断SocketChannel是否已连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#socketChannel-isConnectionPending-%E5%88%A4%E6%96%ADSocketChannel%E6%98%AF%E5%90%A6%E6%AD%A3%E5%9C%A8%E8%BF%9B%E8%A1%8C%E8%BF%9E%E6%8E%A5"><span class="toc-number">3.6.3.7.</span> <span class="toc-text">socketChannel.isConnectionPending(): 判断SocketChannel是否正在进行连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#socketChannel-finishConnect-%E5%AE%8C%E6%88%90%E8%BF%9E%E6%8E%A5%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%AD%A4%E9%80%9A%E9%81%93%E5%B7%B2%E8%BF%9E%E6%8E%A5%EF%BC%8C%E5%88%99%E6%AD%A4%E6%96%B9%E6%B3%95%E5%B0%86"><span class="toc-number">3.6.3.8.</span> <span class="toc-text">socketChannel.finishConnect(): 完成连接，如果此通道已连接，则此方法将</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E4%BC%9A%E9%98%BB%E5%A1%9E%EF%BC%8C%E5%B9%B6%E5%B0%86%E7%AB%8B%E5%8D%B3%E8%BF%94%E5%9B%9Etrue%E3%80%82%E5%A6%82%E6%9E%9C%E6%AD%A4%E9%80%9A%E9%81%93%E5%A4%84%E4%BA%8E%E9%9D%9E%E9%98%BB%E5%A1%9E%E6%A8%A1%E5%BC%8F%EF%BC%8C%E5%88%99%E5%A6%82%E6%9E%9C%E8%BF%9E%E6%8E%A5%E8%BF%87"><span class="toc-number">3.6.3.9.</span> <span class="toc-text">不会阻塞，并将立即返回true。如果此通道处于非阻塞模式，则如果连接过</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1"><span class="toc-number">3.6.3.9.1.</span> <span class="toc-text">1</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1"><span class="toc-number">3.6.3.9.2.</span> <span class="toc-text">1</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2"><span class="toc-number">3.6.3.9.3.</span> <span class="toc-text">2</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E5%B0%9A%E6%9C%AA%E5%AE%8C%E6%88%90%EF%BC%8C%E5%88%99%E6%AD%A4%E6%96%B9%E6%B3%95%E5%B0%86%E8%BF%94%E5%9B%9Efalse%E3%80%82%E5%A6%82%E6%9E%9C%E6%AD%A4%E9%80%9A%E9%81%93%E5%A4%84%E4%BA%8E%E9%98%BB%E5%A1%9E%E6%A8%A1%E5%BC%8F%EF%BC%8C%E5%88%99%E6%AD%A4%E6%96%B9%E6%B3%95"><span class="toc-number">3.6.3.10.</span> <span class="toc-text">程尚未完成，则此方法将返回false。如果此通道处于阻塞模式，则此方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%86%E9%98%BB%E5%A1%9E%EF%BC%8C%E7%9B%B4%E5%88%B0%E8%BF%9E%E6%8E%A5%E5%AE%8C%E6%88%90%E6%88%96%E5%A4%B1%E8%B4%A5%EF%BC%8C%E5%B9%B6%E4%B8%94%E5%B0%86%E5%A7%8B%E7%BB%88%E8%BF%94%E5%9B%9Etrue%E6%88%96%E6%8A%9B%E5%87%BA%E4%B8%80%E4%B8%AA%E6%8F%8F%E8%BF%B0%E5%A4%B1%E8%B4%A5%E7%9A%84"><span class="toc-number">3.6.3.11.</span> <span class="toc-text">将阻塞，直到连接完成或失败，并且将始终返回true或抛出一个描述失败的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A3%80%E6%9F%A5%E5%BC%82%E5%B8%B8%E3%80%82"><span class="toc-number">3.6.3.12.</span> <span class="toc-text">检查异常。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9E"><span class="toc-number">3.6.3.13.</span> <span class="toc-text">阻塞与非阻塞</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E6%93%8D%E4%BD%9C"><span class="toc-number">3.6.3.14.</span> <span class="toc-text">读写操作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#x2F-x2F-%E8%AE%BE%E7%BD%AE%E9%9D%9E%E9%98%BB%E5%A1%9E"><span class="toc-number">3.6.3.14.1.</span> <span class="toc-text">&#x2F;&#x2F;设置非阻塞</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2"><span class="toc-number">3.6.3.14.2.</span> <span class="toc-text">1</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1"><span class="toc-number">3.6.3.14.3.</span> <span class="toc-text">2</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#-6"><span class="toc-number">3.6.3.14.4.</span> <span class="toc-text"></span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E5%8F%82%E6%95%B0"><span class="toc-number">3.6.3.15.</span> <span class="toc-text">设置参数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-DatagramChannel%E8%AF%A6%E8%A7%A3"><span class="toc-number">3.7.</span> <span class="toc-text">6.DatagramChannel详解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#DatagramChannel%E5%AF%B9%E8%B1%A1%E5%85%B3%E8%81%94%E7%9D%80%E4%B8%80%E4%B8%AADatagramSocket%E5%AF%B9%E8%B1%A1%E3%80%82"><span class="toc-number">3.7.0.1.</span> <span class="toc-text">DatagramChannel对象关联着一个DatagramSocket对象。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DatagramChannel%E5%9F%BA%E4%BA%8EUDP%E6%97%A0%E8%BF%9E%E6%8E%A5%E5%8D%8F%E8%AE%AE%EF%BC%8C%E6%AF%8F%E4%B8%AA%E6%95%B0%E6%8D%AE%E6%8A%A5%E9%83%BD%E6%98%AF%E4%B8%80%E4%B8%AA%E8%87%AA%E5%8C%85%E5%90%AB%E7%9A%84%E5%AE%9E%E4%BD%93%EF%BC%8C%E6%8B%A5%E6%9C%89"><span class="toc-number">3.7.0.2.</span> <span class="toc-text">DatagramChannel基于UDP无连接协议，每个数据报都是一个自包含的实体，拥有</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%83%E8%87%AA%E5%B7%B1%E7%9A%84%E7%9B%AE%E7%9A%84%E5%9C%B0%E5%9D%80%E5%8F%8A%E6%95%B0%E6%8D%AE%E8%B4%9F%E8%BD%BD%E3%80%82DatagramChannel%E5%8F%AF%E4%BB%A5%E5%8F%91%E9%80%81%E5%8D%95%E7%8B%AC%E7%9A%84%E6%95%B0%E6%8D%AE%E6%8A%A5%E7%BB%99%E4%B8%8D%E5%90%8C%E7%9A%84"><span class="toc-number">3.7.0.3.</span> <span class="toc-text">它自己的目的地址及数据负载。DatagramChannel可以发送单独的数据报给不同的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%AE%E7%9A%84%E5%9C%B0%EF%BC%8C%E5%90%8C%E6%A0%B7%E4%B9%9F%E5%8F%AF%E4%BB%A5%E6%8E%A5%E5%8F%97%E6%9D%A5%E8%87%AA%E4%BA%8E%E4%BB%BB%E6%84%8F%E5%9C%B0%E5%9D%80%E7%9A%84%E6%95%B0%E6%8D%AE%E6%8A%A5%E3%80%82"><span class="toc-number">3.7.0.4.</span> <span class="toc-text">目的地，同样也可以接受来自于任意地址的数据报。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E6%96%B9%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.7.0.5.</span> <span class="toc-text">发送方的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#-7"><span class="toc-number">3.7.0.5.1.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#x2F-x2F-%E8%AE%BE%E7%BD%AE%E5%8F%82%E6%95%B0"><span class="toc-number">3.7.0.5.2.</span> <span class="toc-text">&#x2F;&#x2F;设置参数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#-8"><span class="toc-number">3.7.0.5.3.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#-9"><span class="toc-number">3.7.0.5.4.</span> <span class="toc-text"></span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E6%94%B6%E6%96%B9%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.7.0.6.</span> <span class="toc-text">接收方的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8read%E5%92%8Cwrite%E6%9D%A5%E8%A1%A8%E7%A4%BA%E6%8E%A5%E6%94%B6%E5%92%8C%E5%8F%91%E9%80%81"><span class="toc-number">3.7.0.7.</span> <span class="toc-text">使用read和write来表示接收和发送</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DatagramChannel%E5%B9%B6%E4%B8%8D%E4%BC%9A%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E9%80%9A%E9%81%93%EF%BC%8C%E8%BF%99%E9%87%8C%E7%9A%84read%E5%92%8Cwrite%E6%96%B9%E6%B3%95%E6%98%AF%E5%9C%A8%E7%BC%93%E5%86%B2%E5%8C%BA%E4%B8%AD%E8%BF%9B%E8%A1%8C"><span class="toc-number">3.7.0.8.</span> <span class="toc-text">DatagramChannel并不会建立连接通道，这里的read和write方法是在缓冲区中进行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%EF%BC%8C%E6%9D%A5%E8%A1%A8%E8%BE%BE%E5%8F%91%E9%80%81%E5%92%8C%E6%8E%A5%E6%94%B6%E7%9A%84%E5%8A%A8%E4%BD%9C%E3%80%82"><span class="toc-number">3.7.0.9.</span> <span class="toc-text">读写，来表达发送和接收的动作。</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#-10"><span class="toc-number">3.7.0.9.1.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#-11"><span class="toc-number">3.7.0.9.2.</span> <span class="toc-text"></span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E5%88%86%E6%95%A3%E5%92%8C%E8%81%9A%E9%9B%86"><span class="toc-number">3.8.</span> <span class="toc-text">7.分散和聚集</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Java-NIO%E7%9A%84%E5%88%86%E6%95%A3Scatter%E5%92%8C%E8%81%9A%E9%9B%86Gather%E5%85%81%E8%AE%B8%E7%94%A8%E6%88%B7%E9%80%9A%E8%BF%87channel%E4%B8%80%E6%AC%A1%E8%AF%BB%E5%8F%96%E5%88%B0%E7%9A%84%E6%95%B0%E6%8D%AE%E5%AD%98%E5%85%A5%E5%88%B0"><span class="toc-number">3.8.0.1.</span> <span class="toc-text">Java NIO的分散Scatter和聚集Gather允许用户通过channel一次读取到的数据存入到</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E4%B8%AAbuffer%E4%B8%AD%EF%BC%8C%E6%88%96%E8%80%85%E4%B8%80%E6%AC%A1%E5%B0%86%E5%A4%9A%E4%B8%AAbuffer%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%86%99%E5%85%A5%E5%88%B0%E4%B8%80%E4%B8%AAChannel%E4%B8%AD%E3%80%82%E5%88%86%E6%95%A3%E5%92%8C%E8%81%9A%E9%9B%86"><span class="toc-number">3.8.0.2.</span> <span class="toc-text">多个buffer中，或者一次将多个buffer中的数据写入到一个Channel中。分散和聚集</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E5%8F%AF%E4%BB%A5%E6%98%AF%E5%B0%86%E6%95%B0%E6%8D%AE%E7%9A%84%E5%A4%9A%E4%B8%AA%E9%83%A8%E5%88%86%E5%AD%98%E6%94%BE%E5%9C%A8%E4%B8%8D%E5%90%8C%E7%9A%84buffer%E4%B8%AD%E6%9D%A5%E8%BF%9B%E8%A1%8C%E8%AF%BB%E5%86%99%E3%80%82"><span class="toc-number">3.8.0.3.</span> <span class="toc-text">的应用场景可以是将数据的多个部分存放在不同的buffer中来进行读写。</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#-12"><span class="toc-number">3.8.0.3.1.</span> <span class="toc-text">}</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#-13"><span class="toc-number">3.8.0.3.2.</span> <span class="toc-text"></span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%95%A3Scatter"><span class="toc-number">3.8.0.4.</span> <span class="toc-text">分散Scatter</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E4%B8%80%E4%B8%AAchannel%E4%B8%AD%E8%AF%BB%E5%8F%96%E7%9A%84%E6%95%B0%E6%8D%AE%E5%AD%98%E5%85%A5%E5%88%B0%E5%A4%9A%E4%B8%AAbuffer%E4%B8%AD%E3%80%82"><span class="toc-number">3.8.0.5.</span> <span class="toc-text">在一个channel中读取的数据存入到多个buffer中。</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#-14"><span class="toc-number">3.8.0.5.1.</span> <span class="toc-text"></span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%81%9A%E9%9B%86Gather"><span class="toc-number">3.8.0.6.</span> <span class="toc-text">聚集Gather</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E6%AC%A1%E5%B0%86%E5%A4%9A%E4%B8%AAbuffer%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E5%86%99%E5%85%A5%E5%88%B0%E4%B8%80%E4%B8%AAchannel%E4%B8%AD%E3%80%82"><span class="toc-number">3.8.0.7.</span> <span class="toc-text">一次将多个buffer中的数据写入到一个channel中。</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#-15"><span class="toc-number">3.8.0.7.1.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#-16"><span class="toc-number">3.8.0.7.2.</span> <span class="toc-text"></span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81NIO-Buffer%E8%AF%A6%E8%A7%A3"><span class="toc-number">4.</span> <span class="toc-text">四、NIO-Buffer详解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Buffer%E6%A6%82%E8%BF%B0"><span class="toc-number">4.1.</span> <span class="toc-text">1.Buffer概述</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#-17"><span class="toc-number">4.1.0.0.1.</span> <span class="toc-text"></span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Buffer%E6%A6%82%E8%BF%B0-1"><span class="toc-number">4.2.</span> <span class="toc-text">1.Buffer概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Buffer%E7%BC%93%E5%86%B2%E5%8C%BA%E5%AE%9E%E9%99%85%E4%B8%8A%E6%98%AF%E5%86%85%E5%AD%98%E4%B8%AD%E5%BC%80%E8%BE%9F%E7%9A%84%E4%B8%80%E5%9D%97%E6%95%B0%E7%BB%84%E7%A9%BA%E9%97%B4%EF%BC%8C%E7%94%A8%E4%BA%8E%E5%AD%98%E6%94%BE%E6%95%B0%E6%8D%AE%E3%80%82Java-NIO%E4%B8%AD%E7%9A%84"><span class="toc-number">4.2.0.1.</span> <span class="toc-text">Buffer缓冲区实际上是内存中开辟的一块数组空间，用于存放数据。Java NIO中的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#buffer%E7%B1%BB%E6%8F%90%E4%BE%9B%E4%BA%86%E5%AF%B9%E8%BF%99%E5%9D%97%E6%95%B0%E7%BB%84%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E3%80%82"><span class="toc-number">4.2.0.2.</span> <span class="toc-text">buffer类提供了对这块数组缓冲区的基本操作。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IO%E6%B5%81%E7%9A%84%E6%93%8D%E4%BD%9C%E9%9D%A2%E5%90%91%E7%9A%84%E6%98%AF%E6%B5%81%E5%AF%B9%E8%B1%A1%EF%BC%8C%E8%80%8CNIO%E6%93%8D%E4%BD%9C%E7%9A%84%E6%95%B0%E6%8D%AE%E9%83%BD%E6%98%AF%E9%9D%A2%E5%90%91Buffer%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84%E3%80%82%E4%B9%9F%E5%B0%B1%E6%98%AF"><span class="toc-number">4.2.0.3.</span> <span class="toc-text">IO流的操作面向的是流对象，而NIO操作的数据都是面向Buffer缓冲区的。也就是</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%EF%BC%8C%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE%E6%98%AF%E9%80%9A%E8%BF%87%E9%80%9A%E9%81%93%E5%B0%86%E6%95%B0%E6%8D%AE%E5%AD%98%E5%85%A5%E5%88%B0buffer%E4%B8%AD%E3%80%82%E5%86%99%E6%95%B0%E6%8D%AE%E6%98%AF%E5%B0%86buffer%E7%BC%93%E5%86%B2%E5%8C%BA%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="toc-number">4.2.0.4.</span> <span class="toc-text">说，读取数据是通过通道将数据存入到buffer中。写数据是将buffer缓冲区中的数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E9%80%9A%E9%81%93%E5%86%99%E5%88%B0%E6%96%87%E4%BB%B6%E4%B8%AD%E3%80%82"><span class="toc-number">4.2.0.5.</span> <span class="toc-text">通过通道写到文件中。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java-NIO%E6%8F%90%E4%BE%9B%E4%BA%86%E6%89%80%E6%9C%89%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84%E6%8A%BD%E8%B1%A1%E5%9F%BA%E7%B1%BBBuffer%E3%80%82Buffer%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0%E7%B1%BB%E6%9C%89%E5%BE%88%E5%A4%9A%EF%BC%8C%E6%AF%94%E5%A6%82"><span class="toc-number">4.2.0.6.</span> <span class="toc-text">Java NIO提供了所有缓冲区的抽象基类Buffer。Buffer的具体实现类有很多，比如</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ByteBuffer%E3%80%81IntBuffer%E3%80%81LongBuffer%E3%80%81CharBuffer%E3%80%81DoubleBuffer%E3%80%81FloatBuffer%E3%80%81"><span class="toc-number">4.2.0.7.</span> <span class="toc-text">ByteBuffer、IntBuffer、LongBuffer、CharBuffer、DoubleBuffer、FloatBuffer、</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HeapByteBuffer%E3%80%81MappedByteBuffer%E7%AD%89%E7%AD%89%EF%BC%8C%E8%BF%99%E4%BA%9B%E5%85%B7%E4%BD%93%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%B1%BB%E5%AE%9E%E9%99%85%E4%B8%8A%E6%98%AF%E4%BE%9D%E6%8D%AEBuffer%E6%95%B0"><span class="toc-number">4.2.0.8.</span> <span class="toc-text">HeapByteBuffer、MappedByteBuffer等等，这些具体的实现类实际上是依据Buffer数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%84%E4%B8%AD%E5%AD%98%E6%94%BE%E6%95%B0%E6%8D%AE%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%9D%A5%E5%86%B3%E5%AE%9A%EF%BC%8C%E6%AF%94%E5%A6%82ByteBuffer%E4%B8%AD%E5%AD%98%E6%94%BE%E7%9A%84%E6%98%AF%E5%AD%97%E8%8A%82%E6%95%B0%E6%8D%AE%E3%80%81LongBuffer"><span class="toc-number">4.2.0.9.</span> <span class="toc-text">组中存放数据的数据类型来决定，比如ByteBuffer中存放的是字节数据、LongBuffer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E5%AD%98%E6%94%BE%E7%9A%84long%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%95%B0%E6%8D%AE%E3%80%82"><span class="toc-number">4.2.0.10.</span> <span class="toc-text">中存放的long类型的数据。</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Buffer%E7%9A%84%E5%85%B3%E9%94%AE%E5%B1%9E%E6%80%A7"><span class="toc-number">4.3.</span> <span class="toc-text">2.Buffer的关键属性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Buffer%E7%9A%84%E4%B8%89%E5%A4%A7%E5%85%B3%E9%94%AE%E5%B1%9E%E6%80%A7%EF%BC%9Acapactity%E3%80%81limit%E3%80%81position%E3%80%82"><span class="toc-number">4.3.0.1.</span> <span class="toc-text">Buffer的三大关键属性：capactity、limit、position。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#capacity"><span class="toc-number">4.3.0.2.</span> <span class="toc-text">capacity:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84%E5%AE%B9%E9%87%8F%E6%98%AF%E5%AE%83%E5%8C%85%E5%90%AB%E7%9A%84%E5%85%83%E7%B4%A0%E6%95%B0%E3%80%82%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84%E5%AE%B9%E9%87%8F%E6%B0%B8%E8%BF%9C%E4%B8%8D%E4%BC%9A%E4%B8%BA%E8%B4%9F%EF%BC%8C%E4%B9%9F%E6%B0%B8%E8%BF%9C%E4%B8%8D%E4%BC%9A%E6%94%B9"><span class="toc-number">4.3.0.3.</span> <span class="toc-text">缓冲区的容量是它包含的元素数。缓冲区的容量永远不会为负，也永远不会改</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%98%E3%80%82"><span class="toc-number">4.3.0.4.</span> <span class="toc-text">变。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#limit"><span class="toc-number">4.3.0.5.</span> <span class="toc-text">limit:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84%E9%99%90%E5%88%B6%E6%98%AF%E4%B8%8D%E5%BA%94%E8%AF%BB%E5%8F%96%E6%88%96%E5%86%99%E5%85%A5%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%E7%9A%84%E7%B4%A2%E5%BC%95%E3%80%82%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84%E9%99%90%E5%88%B6%E6%B0%B8%E8%BF%9C%E4%B8%8D%E4%BC%9A"><span class="toc-number">4.3.0.6.</span> <span class="toc-text">缓冲区的限制是不应读取或写入的第一个元素的索引。缓冲区的限制永远不会</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E8%B4%9F%EF%BC%8C%E4%B9%9F%E6%B0%B8%E8%BF%9C%E4%B8%8D%E4%BC%9A%E5%A4%A7%E4%BA%8E%E5%85%B6%E5%AE%B9%E9%87%8F%E3%80%82"><span class="toc-number">4.3.0.7.</span> <span class="toc-text">为负，也永远不会大于其容量。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%99%E6%95%B0%E6%8D%AE%E6%97%B6%EF%BC%9Alimit%E4%B8%8Ecapacity%E7%9B%B8%E5%90%8C"><span class="toc-number">4.3.0.8.</span> <span class="toc-text">写数据时：limit与capacity相同</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E6%95%B0%E6%8D%AE%E6%97%B6%EF%BC%9Alimit%E8%A1%A8%E7%A4%BA%E5%8F%AF%E8%AF%BB%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BD%8D%E7%BD%AE%EF%BC%8C%E5%9B%A0%E6%AD%A4%E5%9C%A8%E4%B8%8A%E6%AC%A1%E5%86%99%E6%93%8D%E4%BD%9C%E5%90%8E%E9%9C%80%E8%A6%81%E9%80%9A%E8%BF%87flip%E6%96%B9"><span class="toc-number">4.3.0.9.</span> <span class="toc-text">读数据时：limit表示可读的数据位置，因此在上次写操作后需要通过flip方</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%95%EF%BC%8C%E5%B0%86position%E5%80%BC%E8%B5%8B%E7%BB%99limit%E3%80%82"><span class="toc-number">4.3.0.10.</span> <span class="toc-text">法，将position值赋给limit。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#position"><span class="toc-number">4.3.0.11.</span> <span class="toc-text">position:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC%E7%B1%BB%E5%9E%8B-%E6%96%B9%E6%B3%95%E5%90%8D-%E6%8F%8F%E8%BF%B0"><span class="toc-number">4.3.0.12.</span> <span class="toc-text">返回值类型 方法名 描述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#abstract"><span class="toc-number">4.3.0.13.</span> <span class="toc-text">abstract</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Object"><span class="toc-number">4.3.0.14.</span> <span class="toc-text">Object</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#array-%E8%BF%94%E5%9B%9E%E7%BC%93%E5%86%B2%E5%8C%BA%E4%B8%AD%E7%9A%84%E6%95%B0%E7%BB%84"><span class="toc-number">4.3.0.15.</span> <span class="toc-text">array() 返回缓冲区中的数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#abstract-1"><span class="toc-number">4.3.0.16.</span> <span class="toc-text">abstract</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#int"><span class="toc-number">4.3.0.17.</span> <span class="toc-text">int</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#arrayOffset"><span class="toc-number">4.3.0.18.</span> <span class="toc-text">arrayOffset()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E7%BC%93%E5%86%B2%E5%8C%BA%E4%B8%AD%E6%95%B0%E7%BB%84%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0"><span class="toc-number">4.3.0.19.</span> <span class="toc-text">返回缓冲区中数组的第一个元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9A%84%E4%BD%8D%E7%BD%AE"><span class="toc-number">4.3.0.20.</span> <span class="toc-text">的位置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#int-capacity-%E8%BF%94%E5%9B%9E%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84%E5%AE%B9%E9%87%8F"><span class="toc-number">4.3.0.21.</span> <span class="toc-text">int capacity() 返回缓冲区的容量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Buffer-clear-%E6%B8%85%E7%A9%BA%E7%BC%93%E5%86%B2%E5%8C%BA%E4%B8%AD%E7%9A%84%E5%86%85%E5%AE%B9"><span class="toc-number">4.3.0.22.</span> <span class="toc-text">Buffer clear() 清空缓冲区中的内容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Buffer-flip-%E7%BF%BB%E8%BD%AC%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">4.3.0.23.</span> <span class="toc-text">Buffer flip() 翻转缓冲区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#abstract-2"><span class="toc-number">4.3.0.24.</span> <span class="toc-text">abstract</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#boolean"><span class="toc-number">4.3.0.25.</span> <span class="toc-text">boolean</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#hasArray-%E6%98%AF%E5%90%A6%E7%BC%93%E5%86%B2%E5%8C%BA%E4%B8%AD%E6%9C%89%E5%8F%AF%E8%AE%BF%E9%97%AE%E7%9A%84%E6%95%B0%E7%BB%84"><span class="toc-number">4.3.0.26.</span> <span class="toc-text">hasArray() 是否缓冲区中有可访问的数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#boolean-hasRemaining"><span class="toc-number">4.3.0.27.</span> <span class="toc-text">boolean hasRemaining()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E5%8C%BA%E4%B8%AD%E7%9A%84position%E5%92%8Climit%E4%B9%8B%E9%97%B4"><span class="toc-number">4.3.0.28.</span> <span class="toc-text">缓冲区中的position和limit之间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%AF%E8%BF%98%E5%AD%98%E5%9C%A8%E5%85%83%E7%B4%A0"><span class="toc-number">4.3.0.29.</span> <span class="toc-text">是还存在元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#abstract-3"><span class="toc-number">4.3.0.30.</span> <span class="toc-text">abstract</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#boolean-1"><span class="toc-number">4.3.0.31.</span> <span class="toc-text">boolean</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#isDirect-%E6%AD%A4%E7%BC%93%E5%86%B2%E5%8C%BA%E6%98%AF%E5%90%A6%E6%98%AF%E7%9B%B4%E6%8E%A5%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">4.3.0.32.</span> <span class="toc-text">isDirect() 此缓冲区是否是直接缓冲区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#abstract-4"><span class="toc-number">4.3.0.33.</span> <span class="toc-text">abstract</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#boolean-2"><span class="toc-number">4.3.0.34.</span> <span class="toc-text">boolean</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#isReadOnly-%E6%AD%A4%E7%BC%93%E5%86%B2%E5%8C%BA%E6%98%AF%E5%90%A6%E6%98%AF%E5%8F%AA%E8%AF%BB%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">4.3.0.35.</span> <span class="toc-text">isReadOnly() 此缓冲区是否是只读缓冲区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#int-limit-%E8%BF%94%E5%9B%9E%E6%AD%A4%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84limit%E5%B1%9E%E6%80%A7%E5%80%BC"><span class="toc-number">4.3.0.36.</span> <span class="toc-text">int limit() 返回此缓冲区的limit属性值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Buffer"><span class="toc-number">4.3.0.37.</span> <span class="toc-text">Buffer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#limit-int"><span class="toc-number">4.3.0.38.</span> <span class="toc-text">limit(int</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#newLimit"><span class="toc-number">4.3.0.39.</span> <span class="toc-text">newLimit)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E6%AD%A4%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84limit%E5%B1%9E%E6%80%A7%E5%80%BC"><span class="toc-number">4.3.0.40.</span> <span class="toc-text">设置此缓冲区的limit属性值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84%E4%BD%8D%E7%BD%AE%E6%98%AF%E8%A6%81%E8%AF%BB%E5%8F%96%E6%88%96%E5%86%99%E5%85%A5%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%E7%9A%84%E7%B4%A2%E5%BC%95%E3%80%82%E7%BC%93%E5%86%B2%E5%99%A8%E7%9A%84%E4%BD%8D%E7%BD%AE%E6%B0%B8%E8%BF%9C%E4%B8%8D%E4%BC%9A%E4%B8%BA"><span class="toc-number">4.3.0.41.</span> <span class="toc-text">缓冲区的位置是要读取或写入的下一个元素的索引。缓冲器的位置永远不会为</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B4%9F%EF%BC%8C%E4%B9%9F%E6%B0%B8%E8%BF%9C%E4%B8%8D%E4%BC%9A%E5%A4%A7%E4%BA%8E%E5%85%B6%E6%9E%81%E9%99%90%E3%80%82"><span class="toc-number">4.3.0.42.</span> <span class="toc-text">负，也永远不会大于其极限。</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Buffer%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">4.4.</span> <span class="toc-text">3.Buffer的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Buffer%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%E5%A6%82%E4%B8%8B%EF%BC%9A"><span class="toc-number">4.4.0.1.</span> <span class="toc-text">Buffer中的方法如下：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Buffer-mark-%E6%A0%87%E8%AE%B0%E5%BD%93%E5%89%8D%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84position%E5%80%BC"><span class="toc-number">4.4.0.2.</span> <span class="toc-text">Buffer mark() 标记当前缓冲区的position值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#int-position-%E8%BF%94%E5%9B%9E%E6%AD%A4%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84position%E5%B1%9E%E6%80%A7%E5%80%BC"><span class="toc-number">4.4.0.3.</span> <span class="toc-text">int position() 返回此缓冲区的position属性值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Buffer-1"><span class="toc-number">4.4.0.4.</span> <span class="toc-text">Buffer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#position-int"><span class="toc-number">4.4.0.5.</span> <span class="toc-text">position(int</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#newPosition"><span class="toc-number">4.4.0.6.</span> <span class="toc-text">newPosition)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E6%AD%A4%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84position%E5%B1%9E%E6%80%A7%E5%80%BC"><span class="toc-number">4.4.0.7.</span> <span class="toc-text">设置此缓冲区的position属性值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#int-remaining"><span class="toc-number">4.4.0.8.</span> <span class="toc-text">int remaining()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E7%BC%93%E5%86%B2%E5%8C%BA%E4%B8%ADposition%E5%92%8Climit%E4%B9%8B"><span class="toc-number">4.4.0.9.</span> <span class="toc-text">返回缓冲区中position和limit之</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%B4%E5%85%83%E7%B4%A0%E7%9A%84%E4%B8%AA%E6%95%B0"><span class="toc-number">4.4.0.10.</span> <span class="toc-text">间元素的个数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Buffer-reset"><span class="toc-number">4.4.0.11.</span> <span class="toc-text">Buffer reset()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E7%BD%AE%E7%BC%93%E5%86%B2%E5%8C%BA%E4%B8%ADposition%E7%9A%84%E5%80%BC%E4%B8%BA%E4%B9%8B"><span class="toc-number">4.4.0.12.</span> <span class="toc-text">重置缓冲区中position的值为之</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8Dmark%E7%9A%84%E5%80%BC"><span class="toc-number">4.4.0.13.</span> <span class="toc-text">前mark的值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Buffer-rewind-%E5%B0%86position%E8%AE%BE%E7%BD%AE-0-%EF%BC%8Climit%E4%B8%8D%E5%8F%98"><span class="toc-number">4.4.0.14.</span> <span class="toc-text">Buffer rewind() 将position设置 0 ，limit不变</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Buffer%E5%AE%9E%E7%8E%B0%E7%B1%BB%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">4.5.</span> <span class="toc-text">4.Buffer实现类的常用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A5ByteBuffer%E4%B8%BA%E4%BE%8B%EF%BC%8C%E5%88%86%E7%B1%BB%E4%BB%8B%E7%BB%8DByteBuffer%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E3%80%82"><span class="toc-number">4.5.0.1.</span> <span class="toc-text">以ByteBuffer为例，分类介绍ByteBuffer的常用方法。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BABuffer"><span class="toc-number">4.5.0.2.</span> <span class="toc-text">创建Buffer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ByteBuffer%E6%8F%90%E4%BE%9B%E4%BA%86allocate%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E7%94%A8%E6%9D%A5%E5%88%9B%E5%BB%BA%E5%B8%A6%E6%9C%89%E5%88%9D%E5%A7%8B%E5%8C%96%E6%95%B0%E7%BB%84%E7%9A%84Buffer%E7%BC%93%E5%86%B2%E5%8C%BA%E3%80%82"><span class="toc-number">4.5.0.3.</span> <span class="toc-text">ByteBuffer提供了allocate静态方法用来创建带有初始化数组的Buffer缓冲区。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%91Buffer%E4%B8%AD%E5%86%99%E6%95%B0%E6%8D%AE"><span class="toc-number">4.5.0.4.</span> <span class="toc-text">向Buffer中写数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%86%E6%95%B0%E6%8D%AE%E5%86%99%E5%85%A5%E5%88%B0buffer%E4%B8%AD%E6%9C%89%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9A"><span class="toc-number">4.5.0.5.</span> <span class="toc-text">将数据写入到buffer中有三种方式：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#put-%E6%95%B0%E6%8D%AE-%EF%BC%9A-%E5%B0%86%E6%95%B0%E6%8D%AE%E5%AD%98%E5%85%A5%E5%88%B0buffer%EF%BC%8C%E6%AD%A4%E6%97%B6position%E9%9A%8F%E4%B9%8B%E5%8F%98%E5%8C%96%E3%80%82"><span class="toc-number">4.5.0.6.</span> <span class="toc-text">put(数据)： 将数据存入到buffer，此时position随之变化。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#wrap-%E6%95%B0%E6%8D%AE-%EF%BC%9A%E5%B0%86%E6%95%B0%E6%8D%AE%E5%AD%98%E5%85%A5%E6%95%B0%E6%8D%AE%E5%B9%B6%E8%BF%94%E5%9B%9Ebuffer%EF%BC%8C%E6%AD%A4%E6%97%B6position%E4%B8%BA-0-%EF%BC%8Climit%E4%B8%BA%E6%95%B0%E6%8D%AE"><span class="toc-number">4.5.0.7.</span> <span class="toc-text">wrap(数据)：将数据存入数据并返回buffer，此时position为 0 ，limit为数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9A%84%E2%BB%93%E5%BA%A6"><span class="toc-number">4.5.0.8.</span> <span class="toc-text">的⻓度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#channel-read-buffer-%EF%BC%9A%E5%B0%86%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%85%A5%E5%88%B0buffer%E4%B8%AD%E3%80%82"><span class="toc-number">4.5.0.9.</span> <span class="toc-text">channel.read(buffer)：将数据读入到buffer中。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8EBuffer%E4%B8%AD%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE"><span class="toc-number">4.5.0.10.</span> <span class="toc-text">从Buffer中读取数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8EBuffer%E4%B8%AD%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE%E6%9C%89%E4%BB%A5%E4%B8%8B%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9A"><span class="toc-number">4.5.0.11.</span> <span class="toc-text">从Buffer中读取数据有以下几种方式：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#get%E7%9B%B8%E5%85%B3%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9A%E8%8E%B7%E5%BE%97%E5%BD%93%E5%89%8Dposition%E6%88%96%E6%8C%87%E5%AE%9Aposition%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="toc-number">4.5.0.12.</span> <span class="toc-text">get相关的方法：获得当前position或指定position的数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#array-%EF%BC%9A%E8%BF%94%E5%9B%9E%E6%95%B4%E4%B8%AA%E6%95%B0%E7%BB%84%E5%86%85%E5%AE%B9"><span class="toc-number">4.5.0.13.</span> <span class="toc-text">array()：返回整个数组内容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#channel-write-buffer-%EF%BC%9A%E4%BD%BF%E7%94%A8channel%E8%8E%B7%E5%BE%97buffer%E4%B8%AD%E7%9A%84%E5%86%85%E5%AE%B9%E5%B9%B6%E5%86%99%E5%85%A5%E5%88%B0%E6%8C%87%E5%AE%9A%E7%9B%AE%E6%A0%87"><span class="toc-number">4.5.0.14.</span> <span class="toc-text">channel.write(buffer)：使用channel获得buffer中的内容并写入到指定目标</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E7%BC%93%E5%86%B2%E5%8C%BA%E5%88%86%E7%B1%BB"><span class="toc-number">4.6.</span> <span class="toc-text">5.缓冲区分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%90%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">4.6.0.1.</span> <span class="toc-text">子缓冲区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E4%BB%A5%E4%B8%BABuffer%E5%88%9B%E5%BB%BA%E5%AD%90%E7%BC%93%E5%86%B2%E5%8C%BA%EF%BC%8C%E5%9C%A8%E7%8E%B0%E6%9C%89%E7%BC%93%E5%86%B2%E5%8C%BA%E4%B8%8A%E5%88%86%E5%89%B2%E5%87%BA%E4%B8%80%E5%9D%97%E7%A9%BA%E9%97%B4%E4%BD%9C%E4%B8%BA%E6%96%B0%E7%9A%84%E7%BC%93%E5%86%B2%E5%8C%BA%E3%80%82%E5%8E%9F"><span class="toc-number">4.6.0.2.</span> <span class="toc-text">可以为Buffer创建子缓冲区，在现有缓冲区上分割出一块空间作为新的缓冲区。原</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E5%8C%BA%E5%92%8C%E5%AD%90%E7%BC%93%E5%86%B2%E5%8C%BA%E5%85%B1%E4%BA%AB%E5%90%8C%E4%B8%80%E7%89%87%E6%95%B0%E6%8D%AE%E7%A9%BA%E9%97%B4%E3%80%82"><span class="toc-number">4.6.0.3.</span> <span class="toc-text">缓冲区和子缓冲区共享同一片数据空间。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E8%B0%83%E7%94%A8slice%E6%96%B9%E6%B3%95%E5%88%9B%E5%BB%BA%E5%AD%90%E7%BC%93%E5%86%B2%E5%8C%BA-%E3%80%82"><span class="toc-number">4.6.0.4.</span> <span class="toc-text">通过调用slice方法创建子缓冲区 。</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#-18"><span class="toc-number">4.6.0.4.1.</span> <span class="toc-text"></span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AA%E8%AF%BB%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">4.6.0.5.</span> <span class="toc-text">只读缓冲区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E8%BF%87buffer%E7%9A%84asReadOnlyBuffer-%E6%96%B9%E6%B3%95%E8%8E%B7%E5%BE%97%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E5%8F%AA%E8%AF%BB%E7%BC%93%E5%86%B2%E5%8C%BA%EF%BC%8C%E6%89%80%E8%B0%93%E7%9A%84%E5%8F%AA%E8%AF%BB%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">4.6.0.6.</span> <span class="toc-text">通过buffer的asReadOnlyBuffer()方法获得一个新的只读缓冲区，所谓的只读缓冲区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%B1%E6%98%AF%E5%8F%AA%E8%83%BD%E8%AF%BB%E4%B8%8D%E8%83%BD%E5%86%99%E3%80%82%E5%8F%AA%E8%AF%BB%E7%BC%93%E5%86%B2%E5%8C%BA%E4%B8%8E%E5%8E%9F%E7%BC%93%E5%86%B2%E5%8C%BA%E5%85%B1%E4%BA%AB%E5%90%8C%E4%B8%80%E7%89%87%E6%95%B0%E6%8D%AE%E7%A9%BA%E9%97%B4%EF%BC%8C%E5%8E%9F%E7%BC%93%E5%86%B2%E5%8C%BA%E6%95%B0%E6%8D%AE%E5%8F%91"><span class="toc-number">4.6.0.7.</span> <span class="toc-text">就是只能读不能写。只读缓冲区与原缓冲区共享同一片数据空间，原缓冲区数据发</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%9F%E6%94%B9%E5%8F%98%EF%BC%8C%E5%8F%AA%E8%AF%BB%E7%BC%93%E5%86%B2%E5%8C%BA%E4%B9%9F%E8%83%BD%E7%9C%8B%E5%88%B0%E5%8F%98%E5%8C%96%E5%90%8E%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%8C%E5%9B%A0%E4%B8%BA%E5%AE%83%E4%BB%AC%E5%85%B1%E4%BA%AB%E5%90%8C%E4%B8%80%E7%89%87%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%E3%80%82"><span class="toc-number">4.6.0.8.</span> <span class="toc-text">生改变，只读缓冲区也能看到变化后的数据，因为它们共享同一片存储空间。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">4.6.0.9.</span> <span class="toc-text">直接缓冲区</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#-19"><span class="toc-number">4.6.0.9.1.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#-20"><span class="toc-number">4.6.0.9.2.</span> <span class="toc-text"></span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E7%BC%93%E5%86%B2%E5%8C%BA%EF%BC%8CJava%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%B0%86%E5%B0%BD%E6%9C%80%E5%A4%A7%E5%8A%AA%E5%8A%9B%E7%9B%B4%E6%8E%A5%E5%AF%B9%E5%85%B6%E6%89%A7%E8%A1%8C%E6%9C%AC%E6%9C%BAI-x2F-O%E6%93%8D%E4%BD%9C%E3%80%82%E4%B9%9F%E5%B0%B1%E6%98%AF%E8%AF%B4%EF%BC%8C%E5%AE%83%E5%B0%86"><span class="toc-number">4.6.0.10.</span> <span class="toc-text">直接缓冲区，Java虚拟机将尽最大努力直接对其执行本机I&#x2F;O操作。也就是说，它将</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%95%E5%9B%BE%E9%81%BF%E5%85%8D%E5%9C%A8%E6%AF%8F%E6%AC%A1%E8%B0%83%E7%94%A8%E5%BA%95%E5%B1%82%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%9C%AC%E6%9C%BAI-x2F-O%E6%93%8D%E4%BD%9C%E4%B9%8B%E5%89%8D%EF%BC%88%E6%88%96%E4%B9%8B%E5%90%8E%EF%BC%89%EF%BC%8C%E5%B0%86%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84%E5%86%85%E5%AE%B9"><span class="toc-number">4.6.0.11.</span> <span class="toc-text">试图避免在每次调用底层操作系统的本机I&#x2F;O操作之前（或之后），将缓冲区的内容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E5%88%B0%E4%B8%AD%E9%97%B4%E7%BC%93%E5%86%B2%E5%8C%BA%EF%BC%88%E6%88%96%E4%BB%8E%E4%B8%AD%E9%97%B4%E7%BC%93%E5%86%B2%E5%8C%BA%E5%A4%8D%E5%88%B6%EF%BC%89%E3%80%82"><span class="toc-number">4.6.0.12.</span> <span class="toc-text">复制到中间缓冲区（或从中间缓冲区复制）。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87%E8%B0%83%E7%94%A8%E6%AD%A4%E7%B1%BB%E7%9A%84allocateDirect%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%9D%A5%E5%88%9B%E5%BB%BA%E7%9B%B4%E6%8E%A5%E5%AD%97%E8%8A%82%E7%BC%93%E5%86%B2%E5%8C%BA%E3%80%82%E6%AD%A4%E6%96%B9%E6%B3%95%E8%BF%94%E5%9B%9E%E7%9A%84"><span class="toc-number">4.6.0.13.</span> <span class="toc-text">可以通过调用此类的allocateDirect工厂方法来创建直接字节缓冲区。此方法返回的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E5%8C%BA%E9%80%9A%E5%B8%B8%E6%AF%94%E9%9D%9E%E7%9B%B4%E6%8E%A5%E7%BC%93%E5%86%B2%E5%8C%BA%E5%85%B7%E6%9C%89%E6%9B%B4%E9%AB%98%E7%9A%84%E5%88%86%E9%85%8D%E5%92%8C%E9%87%8A%E6%94%BE%E6%88%90%E6%9C%AC%E3%80%82%E7%9B%B4%E6%8E%A5%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84%E5%86%85%E5%AE%B9%E5%8F%AF%E8%83%BD%E4%BD%8D"><span class="toc-number">4.6.0.14.</span> <span class="toc-text">缓冲区通常比非直接缓冲区具有更高的分配和释放成本。直接缓冲区的内容可能位</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8E%E6%AD%A3%E5%B8%B8%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%A0%86%E4%B9%8B%E5%A4%96%EF%BC%8C%E5%9B%A0%E6%AD%A4%E5%AE%83%E4%BB%AC%E5%AF%B9%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%E7%9A%84%E5%BD%B1%E5%93%8D%E5%8F%AF%E8%83%BD%E4%B8%8D%E6%98%8E%E6%98%BE%E3%80%82"><span class="toc-number">4.6.0.15.</span> <span class="toc-text">于正常垃圾收集堆之外，因此它们对应用程序内存占用的影响可能不明显。</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#-21"><span class="toc-number">4.6.0.15.1.</span> <span class="toc-text"></span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E7%9A%84Buffer"><span class="toc-number">4.6.0.16.</span> <span class="toc-text">基于内存映射的Buffer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MappedByteBuffer%E9%87%87%E7%94%A8direct-buffer%E7%9A%84%E6%96%B9%E5%BC%8F%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9-%E8%BF%99%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%B0%B1%E6%98%AF%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E3%80%82"><span class="toc-number">4.6.0.17.</span> <span class="toc-text">MappedByteBuffer采用direct buffer的方式读写文件内容,这种方式就是内存映射。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%99%E7%A7%8D%E6%96%B9%E5%BC%8F%E7%9B%B4%E6%8E%A5%E8%B0%83%E7%94%A8%E7%B3%BB%E7%BB%9F%E5%BA%95%E5%B1%82%E7%9A%84%E7%BC%93%E5%AD%98-%E6%B2%A1%E6%9C%89JVM%E5%92%8C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E9%97%B4%E7%9A%84%E5%A4%8D%E5%88%B6%E6%93%8D%E4%BD%9C%EF%BC%8C%E6%89%80%E4%BB%A5%E6%95%88%E7%8E%87%E9%9D%9E%E5%B8%B8"><span class="toc-number">4.6.0.18.</span> <span class="toc-text">这种方式直接调用系统底层的缓存,没有JVM和系统之间的复制操作，所以效率非常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%AB%98%EF%BC%8C%E4%B8%BB%E8%A6%81%E7%94%A8%E4%BA%8E%E6%93%8D%E4%BD%9C%E5%A4%A7%E6%96%87%E4%BB%B6%E3%80%82"><span class="toc-number">4.6.0.19.</span> <span class="toc-text">高，主要用于操作大文件。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E8%BF%87FileChannel%E7%9A%84map%E6%96%B9%E6%B3%95%E5%BE%97%E5%88%B0MappedByteBuffer%EF%BC%8CMappedByteBuffer%E6%8A%8A%E7%A3%81%E7%9B%98%E4%B8%AD%E6%96%87"><span class="toc-number">4.6.0.20.</span> <span class="toc-text">通过FileChannel的map方法得到MappedByteBuffer，MappedByteBuffer把磁盘中文</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%B6%E7%9A%84%E5%86%85%E5%AE%B9%E6%98%A0%E5%B0%84%E5%88%B0%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E4%B8%AD%EF%BC%8C%E6%93%8D%E4%BD%9CMappedByteBuffer%E7%9B%B4%E6%8E%A5%E6%93%8D%E4%BD%9C%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E6%95%B0"><span class="toc-number">4.6.0.21.</span> <span class="toc-text">件的内容映射到计算机的虚拟内存中，操作MappedByteBuffer直接操作内存中的数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8D%AE%EF%BC%8C%E8%80%8C%E6%97%A0%E9%9C%80%E6%AF%8F%E6%AC%A1%E9%80%9A%E8%BF%87IO%E6%9D%A5%E8%AF%BB%E5%8F%96%E7%89%A9%E7%90%86%E7%A3%81%E7%9B%98%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6%EF%BC%8C%E6%95%88%E7%8E%87%E6%9E%81%E9%AB%98%E3%80%82"><span class="toc-number">4.6.0.22.</span> <span class="toc-text">据，而无需每次通过IO来读取物理磁盘中的文件，效率极高。</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#-22"><span class="toc-number">4.6.0.22.1.</span> <span class="toc-text"></span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E3%80%81NIO-Selector%E8%AF%A6%E8%A7%A3"><span class="toc-number">5.</span> <span class="toc-text">五、NIO-Selector详解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Selector%E6%A6%82%E8%BF%B0"><span class="toc-number">5.1.</span> <span class="toc-text">1.Selector概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Selector%E9%80%89%E6%8B%A9%E5%99%A8%EF%BC%8C%E4%B9%9F%E5%8F%AF%E4%BB%A5%E7%A7%B0%E4%B8%BA%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%99%A8%E3%80%82%E5%AE%83%E6%98%AFJava-NIO%E7%9A%84%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E4%B9%8B%E4%B8%80%EF%BC%8C%E7%94%A8%E4%BA%8E%E6%A3%80%E6%9F%A5"><span class="toc-number">5.1.0.1.</span> <span class="toc-text">Selector选择器，也可以称为多路复用器。它是Java NIO的核心组件之一，用于检查</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E6%88%96%E5%A4%9A%E4%B8%AAChannel%E7%9A%84%E7%8A%B6%E6%80%81%E6%98%AF%E5%90%A6%E5%A4%84%E4%BA%8E%E5%8F%AF%E8%AF%BB%E3%80%81%E5%8F%AF%E5%86%99%E3%80%81%E5%8F%AF%E8%BF%9E%E6%8E%A5%E3%80%81%E5%8F%AF%E6%8E%A5%E6%94%B6%E7%AD%89%E3%80%82%E9%80%9A%E8%BF%87%E4%B8%80%E4%B8%AA"><span class="toc-number">5.1.0.2.</span> <span class="toc-text">一个或多个Channel的状态是否处于可读、可写、可连接、可接收等。通过一个</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Selector%E9%80%89%E6%8B%A9%E5%99%A8%E7%AE%A1%E7%90%86%E5%A4%9A%E4%B8%AAChannel%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86%E5%A4%9A%E4%B8%AAChannel%E5%AF%B9%E5%BA%94%E7%9A%84%E7%BD%91%E7%BB%9C"><span class="toc-number">5.1.0.3.</span> <span class="toc-text">Selector选择器管理多个Channel，可以实现一个线程管理多个Channel对应的网络</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E3%80%82%E4%BD%BF%E7%94%A8%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86%E5%A4%9A%E4%B8%AAChannel%E5%8F%AF%E4%BB%A5%E9%81%BF%E5%85%8D%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2%E5%B8%A6%E6%9D%A5%E7%9A%84%E9%A2%9D%E5%A4%96"><span class="toc-number">5.1.0.4.</span> <span class="toc-text">连接。使用单线程管理多个Channel可以避免多线程的线程上下文切换带来的额外</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%80%E9%94%80%E3%80%82"><span class="toc-number">5.1.0.5.</span> <span class="toc-text">开销。</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-SelectableChannel%E5%8F%AF%E9%80%89%E6%8B%A9%E9%80%9A%E9%81%93"><span class="toc-number">5.2.</span> <span class="toc-text">2.SelectableChannel可选择通道</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AA%E6%9C%89SelectableChannel%E6%89%8D%E8%83%BD%E8%A2%ABSelector%E7%AE%A1%E7%90%86%EF%BC%8C%E6%AF%94%E5%A6%82%E6%89%80%E6%9C%89%E7%9A%84Socket%E9%80%9A%E9%81%93%E3%80%82%E8%80%8CFileChannel"><span class="toc-number">5.2.0.1.</span> <span class="toc-text">只有SelectableChannel才能被Selector管理，比如所有的Socket通道。而FileChannel</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E6%B2%A1%E6%9C%89%E7%BB%A7%E6%89%BFSelectableChannel%EF%BC%8C%E5%9B%A0%E6%AD%A4%E4%B8%8D%E8%83%BD%E8%A2%ABSelector%E7%AE%A1%E7%90%86%E3%80%82"><span class="toc-number">5.2.0.2.</span> <span class="toc-text">并没有继承SelectableChannel，因此不能被Selector管理。</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Channel%E6%B3%A8%E5%86%8C%E5%88%B0Selector%E4%B8%8A"><span class="toc-number">5.3.</span> <span class="toc-text">3.Channel注册到Selector上</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#27"><span class="toc-number">5.3.0.0.1.</span> <span class="toc-text">27 }</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#28"><span class="toc-number">5.3.0.0.2.</span> <span class="toc-text">28</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Channel%E9%80%9A%E8%BF%87%E6%B3%A8%E5%86%8C%E7%9A%84%E6%96%B9%E5%BC%8F%E5%85%B3%E8%81%94Selector%E3%80%82%E4%B8%80%E4%B8%AAChannel%E5%8F%AF%E4%BB%A5%E6%B3%A8%E5%86%8C%E5%88%B0%E5%A4%9A%E4%B8%AASelector%E4%B8%8A%EF%BC%8C%E4%BD%86"><span class="toc-number">5.3.0.1.</span> <span class="toc-text">Channel通过注册的方式关联Selector。一个Channel可以注册到多个Selector上，但</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E6%9F%90%E4%B8%80%E4%B8%AASelector%E4%B8%8A%E5%8F%AA%E8%83%BD%E6%B3%A8%E5%86%8C%E4%B8%80%E6%AC%A1%E3%80%82%E6%B3%A8%E5%86%8C%E6%97%B6%E9%9C%80%E8%A6%81%E5%91%8A%E7%9F%A5Selector%EF%BC%8CSelector%E9%9C%80%E8%A6%81%E5%AF%B9%E9%80%9A%E9%81%93"><span class="toc-number">5.3.0.2.</span> <span class="toc-text">在某一个Selector上只能注册一次。注册时需要告知Selector，Selector需要对通道</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9A%84%E5%93%AA%E4%B8%AA%E6%93%8D%E4%BD%9C%E6%84%9F%E5%85%B4%E8%B6%A3%E3%80%82"><span class="toc-number">5.3.0.3.</span> <span class="toc-text">的哪个操作感兴趣。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E9%81%93%E7%9A%84%E6%93%8D%E4%BD%9C%E5%A6%82%E4%B8%8B%EF%BC%9A"><span class="toc-number">5.3.0.4.</span> <span class="toc-text">通道的操作如下：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E8%AF%BB%EF%BC%9ASelectionKey-OP-READ"><span class="toc-number">5.3.0.5.</span> <span class="toc-text">可读：SelectionKey.OP_READ</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E5%86%99%EF%BC%9ASelectionKey-OP-WRITE"><span class="toc-number">5.3.0.6.</span> <span class="toc-text">可写：SelectionKey.OP_WRITE</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E8%BF%9E%E6%8E%A5%EF%BC%9ASelectionKey-OP-CONNECT"><span class="toc-number">5.3.0.7.</span> <span class="toc-text">可连接：SelectionKey.OP_CONNECT</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E6%8E%A5%E6%94%B6%EF%BC%9ASelectionKey-OP-ACCEPT"><span class="toc-number">5.3.0.8.</span> <span class="toc-text">可接收：SelectionKey.OP_ACCEPT</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AF%94%E5%A6%82channel%E8%B0%83%E7%94%A8register%E6%96%B9%E6%B3%95%E8%BF%9B%E8%A1%8C%E6%B3%A8%E5%86%8C%E5%88%B0Selector%EF%BC%8C%E5%B9%B6%E5%91%8A%E7%9F%A5Selector%E5%AF%B9%E5%93%AA%E4%B8%AA%E6%93%8D%E4%BD%9C%E6%84%9F%E5%85%B4"><span class="toc-number">5.3.0.9.</span> <span class="toc-text">比如channel调用register方法进行注册到Selector，并告知Selector对哪个操作感兴</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B6%A3%EF%BC%9A"><span class="toc-number">5.3.0.10.</span> <span class="toc-text">趣：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B9%9F%E5%8F%AF%E4%BB%A5%E5%90%8C%E6%97%B6%E6%B3%A8%E5%86%8C%E5%A4%9A%E4%B8%AA%E6%93%8D%E4%BD%9C%EF%BC%9A"><span class="toc-number">5.3.0.11.</span> <span class="toc-text">也可以同时注册多个操作：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E5%99%A8%E4%BC%9A%E6%9F%A5%E8%AF%A2%E6%AF%8F%E4%B8%AA%E4%B8%80%E4%B8%AAchannel%E7%9A%84%E6%93%8D%E4%BD%9C%E4%BA%8B%E4%BB%B6%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%98%AF%E8%AF%A5channel%E6%B3%A8%E5%86%8C%E7%9A%84%E6%93%8D%E4%BD%9C%E5%B7%B2%E5%B0%B1%E7%BB%AA%EF%BC%8C"><span class="toc-number">5.3.0.12.</span> <span class="toc-text">选择器会查询每个一个channel的操作事件，如果是该channel注册的操作已就绪，</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%99%E8%BF%9B%E8%A1%8C%E5%93%8D%E5%BA%94%E3%80%82%E6%B3%A8%E6%84%8F%EF%BC%8C%E8%BF%99%E9%87%8Cchannel%E7%9A%84%E6%93%8D%E4%BD%9C%E6%8C%87%E7%9A%84%E6%98%AFchannel%E5%AE%8C%E6%88%90%E6%9F%90%E4%B8%AA%E6%93%8D%E4%BD%9C%E7%9A%84%E6%9D%A1%E4%BB%B6%EF%BC%8C%E8%A1%A8%E7%A4%BA"><span class="toc-number">5.3.0.13.</span> <span class="toc-text">则进行响应。注意，这里channel的操作指的是channel完成某个操作的条件，表示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%A5channel%E5%AF%B9%E4%BA%8E%E8%AF%A5%E6%93%8D%E4%BD%9C%E5%B7%B2%E5%A4%84%E4%BA%8E%E5%B0%B1%E7%BB%AA%E7%8A%B6%E6%80%81%E3%80%82%E6%AF%94%E5%A6%82ServerSocketChannel%E5%B7%B2%E5%87%86%E5%A4%87%E5%A5%BD%E6%8E%A5%E6%94%B6%E6%96%B0"><span class="toc-number">5.3.0.14.</span> <span class="toc-text">该channel对于该操作已处于就绪状态。比如ServerSocketChannel已准备好接收新</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9A%84%E8%BF%9E%E6%8E%A5%EF%BC%8C%E9%82%A3%E4%B9%88%E5%AE%83%E6%B3%A8%E5%86%8C%E7%9A%84SelectionKey-OP-ACCEPT%E6%93%8D%E4%BD%9C%E5%B0%B1%E5%A4%84%E4%BA%8E%E5%B0%B1%E7%BB%AA%E7%8A%B6%E6%80%81%E3%80%82%E5%8F%88%E6%AF%94%E5%A6%82"><span class="toc-number">5.3.0.15.</span> <span class="toc-text">的连接，那么它注册的SelectionKey.OP_ACCEPT操作就处于就绪状态。又比如</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SocketChannel%E5%B7%B2%E5%87%86%E5%A4%87%E5%A5%BD%E5%8E%BB%E8%BF%9E%E6%8E%A5Server%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%8C%E9%82%A3%E4%B9%88%E5%AE%83%E6%B3%A8%E5%86%8C%E7%9A%84"><span class="toc-number">5.3.0.16.</span> <span class="toc-text">SocketChannel已准备好去连接Server服务器，那么它注册的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SelectionKey-OP-CONNECT%E6%93%8D%E4%BD%9C%E5%B0%B1%E5%A4%84%E4%BA%8E%E5%B0%B1%E7%BB%AA%E7%8A%B6%E6%80%81%E3%80%82%E4%BA%8E%E6%98%AFSelector%E5%B0%B1%E5%8F%AF%E4%BB%A5%E8%A7%A6%E5%8F%91%E4%B9%8B%E5%90%8E"><span class="toc-number">5.3.0.17.</span> <span class="toc-text">SelectionKey.OP_CONNECT操作就处于就绪状态。于是Selector就可以触发之后</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9A%84%E5%8A%A8%E4%BD%9C%E3%80%82"><span class="toc-number">5.3.0.18.</span> <span class="toc-text">的动作。</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-SelectionKey%E9%80%89%E6%8B%A9%E9%94%AE"><span class="toc-number">5.4.</span> <span class="toc-text">4.SelectionKey选择键</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#-23"><span class="toc-number">5.4.0.0.1.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#-24"><span class="toc-number">5.4.0.0.2.</span> <span class="toc-text"></span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-SelectionKey%E9%80%89%E6%8B%A9%E9%94%AE-1"><span class="toc-number">5.5.</span> <span class="toc-text">4.SelectionKey选择键</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#SelectionKey%E5%B0%81%E8%A3%85%E4%BA%86Channel%E5%92%8C%E6%B3%A8%E5%86%8C%E7%9A%84%E6%93%8D%E4%BD%9C%E3%80%82"><span class="toc-number">5.5.0.1.</span> <span class="toc-text">SelectionKey封装了Channel和注册的操作。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BD%93Selector%E8%B0%83%E7%94%A8select-%E6%96%B9%E6%B3%95%E6%97%B6%EF%BC%8C%E4%BC%9A%E8%BD%AE%E8%AF%A2%E6%89%80%E6%9C%89%E6%B3%A8%E5%86%8C%E5%9C%A8%E5%AE%83%E8%BA%AB%E4%B8%8A%E7%9A%84Channel%EF%BC%8C%E6%9F%A5%E7%9C%8B%E6%98%AF%E5%90%A6%E6%9C%89%E5%A4%84"><span class="toc-number">5.5.0.2.</span> <span class="toc-text">当Selector调用select()方法时，会轮询所有注册在它身上的Channel，查看是否有处</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8E%E6%9F%90%E4%B8%AA%E6%93%8D%E4%BD%9C%EF%BC%88%E5%B7%B2%E6%B3%A8%E5%86%8C%E5%88%B0selector%E4%B8%8A%E7%9A%84%EF%BC%89%E5%B0%B1%E7%BB%AA%E7%8A%B6%E6%80%81%E7%9A%84Channel%EF%BC%8C%E6%8A%8A%E8%BF%99%E4%BA%9BChannel%E6%94%BE%E5%85%A5%E5%88%B0"><span class="toc-number">5.5.0.3.</span> <span class="toc-text">于某个操作（已注册到selector上的）就绪状态的Channel，把这些Channel放入到</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SelectionKey%E7%9A%84%E9%9B%86%E5%90%88%E4%B8%AD%E3%80%82"><span class="toc-number">5.5.0.4.</span> <span class="toc-text">SelectionKey的集合中。</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-Selector%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">5.6.</span> <span class="toc-text">5.Selector的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BASelector"><span class="toc-number">5.6.0.1.</span> <span class="toc-text">创建Selector</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E8%BF%87Selector%E7%9A%84open%E6%96%B9%E6%B3%95%E5%88%9B%E5%BB%BASelector%E5%AF%B9%E8%B1%A1%E3%80%82"><span class="toc-number">5.6.0.2.</span> <span class="toc-text">通过Selector的open方法创建Selector对象。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Channel%E6%B3%A8%E5%86%8C%E5%88%B0Selector%E4%B8%8A"><span class="toc-number">5.6.0.3.</span> <span class="toc-text">Channel注册到Selector上</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Channel%E5%BF%85%E9%A1%BB%E5%A4%84%E4%BA%8E%E9%9D%9E%E9%98%BB%E5%A1%9E%E6%A8%A1%E5%BC%8F%E6%89%8D%E8%83%BD%E6%B3%A8%E5%86%8C%E5%88%B0Selector%E4%B8%8A%E3%80%82"><span class="toc-number">5.6.0.4.</span> <span class="toc-text">Channel必须处于非阻塞模式才能注册到Selector上。</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#-25"><span class="toc-number">5.6.0.4.1.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#-26"><span class="toc-number">5.6.0.4.2.</span> <span class="toc-text"></span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Selector%E8%BD%AE%E8%AF%A2%E5%B0%B1%E7%BB%AA%E7%8A%B6%E6%80%81%E7%9A%84Channel"><span class="toc-number">5.6.0.5.</span> <span class="toc-text">Selector轮询就绪状态的Channel</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Selector%E9%80%9A%E8%BF%87%E8%B0%83%E7%94%A8select%E6%96%B9%E6%B3%95%E8%BD%AE%E8%AF%A2%E5%B7%B2%E5%B0%B1%E7%BB%AA%E7%9A%84%E9%80%9A%E9%81%93%E6%93%8D%E4%BD%9C%E3%80%82select%E6%96%B9%E6%B3%95%E6%98%AF%E9%98%BB%E5%A1%9E%E7%9A%84%EF%BC%8C%E7%9B%B4%E5%88%B0%E8%87%B3"><span class="toc-number">5.6.0.6.</span> <span class="toc-text">Selector通过调用select方法轮询已就绪的通道操作。select方法是阻塞的，直到至</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%91%E6%9C%89%E4%B8%80%E4%B8%AA%E9%80%9A%E9%81%93%E7%9A%84%E6%B3%A8%E5%86%8C%E6%93%8D%E4%BD%9C%E5%B7%B2%E5%B0%B1%E7%BB%AA%E3%80%82%E5%BD%93%E5%AE%8C%E6%88%90select%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E5%90%8E%EF%BC%8C%E8%A2%AB%E9%80%89%E4%B8%AD%E7%9A%84%E5%B7%B2%E5%B0%B1%E7%BB%AA%E7%9A%84%E6%89%80"><span class="toc-number">5.6.0.7.</span> <span class="toc-text">少有一个通道的注册操作已就绪。当完成select方法调用后，被选中的已就绪的所</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89channel%E9%80%9A%E8%BF%87Selector%E7%9A%84selectedKeys-%E6%96%B9%E6%B3%95%E8%8E%B7%E5%BE%97%EF%BC%8C%E8%AF%A5%E6%96%B9%E6%B3%95%E8%8E%B7%E5%BE%97%E7%9A%84%E6%98%AF%E4%B8%80%E4%B8%AA"><span class="toc-number">5.6.0.8.</span> <span class="toc-text">有channel通过Selector的selectedKeys()方法获得，该方法获得的是一个</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SelectionKey%E9%9B%86%E5%90%88%EF%BC%8C%E5%85%B6%E4%B8%AD%E6%AF%8F%E4%B8%80%E4%B8%AASelectionKey%E9%83%BD%E8%A1%A8%E7%A4%BA%E4%B8%80%E4%B8%AAChannel%E3%80%82%E4%BA%8E%E6%98%AF%E5%8F%AF%E4%BB%A5%E6%A0%B9%E6%8D%AE"><span class="toc-number">5.6.0.9.</span> <span class="toc-text">SelectionKey集合，其中每一个SelectionKey都表示一个Channel。于是可以根据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SelectionKey%E7%9A%84%E6%B3%A8%E5%86%8C%E6%93%8D%E4%BD%9C%E6%9D%A5%E5%81%9A%E5%85%B7%E4%BD%93%E7%9A%84%E4%B8%9A%E5%8A%A1%E5%A4%84%E7%90%86%E3%80%82"><span class="toc-number">5.6.0.10.</span> <span class="toc-text">SelectionKey的注册操作来做具体的业务处理。</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#-27"><span class="toc-number">5.6.0.10.1.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#-28"><span class="toc-number">5.6.0.10.2.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#-29"><span class="toc-number">5.6.0.10.3.</span> <span class="toc-text"></span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-Selector%E7%A4%BA%E4%BE%8B"><span class="toc-number">5.7.</span> <span class="toc-text">6.Selector示例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0NIO%E9%80%9A%E4%BF%A1%E7%9A%84%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">5.7.0.1.</span> <span class="toc-text">实现NIO通信的客户端</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#-30"><span class="toc-number">5.7.0.1.1.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#-31"><span class="toc-number">5.7.0.1.2.</span> <span class="toc-text"></span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0NIO%E9%80%9A%E4%BF%A1%E7%9A%84%E6%9C%8D%E5%8A%A1%E7%AB%AF"><span class="toc-number">5.7.0.2.</span> <span class="toc-text">实现NIO通信的服务端</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#-32"><span class="toc-number">5.7.0.2.1.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#-33"><span class="toc-number">5.7.0.2.2.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#x2F-x2F-%E8%AE%BE%E7%BD%AE%E6%88%90%E9%9D%9E%E9%98%BB%E5%A1%9E%E7%9A%84%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.7.0.2.3.</span> <span class="toc-text">&#x2F;&#x2F;设置成非阻塞的模式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#-34"><span class="toc-number">5.7.0.2.4.</span> <span class="toc-text"></span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD%E3%80%81NIO%E5%8C%85%E4%B8%AD%E7%9A%84%E5%85%B6%E4%BB%96%E7%B1%BB"><span class="toc-number">6.</span> <span class="toc-text">六、NIO包中的其他类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Pipe"><span class="toc-number">6.1.</span> <span class="toc-text">1.Pipe</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Java-NIO%E5%8C%85%E4%B8%AD%E6%8F%90%E4%BE%9B%E4%BA%86Pipe%E7%B1%BB%EF%BC%8C%E7%94%A8%E6%9D%A5%E5%AE%9E%E7%8E%B0%E4%B8%A4%E4%B8%AA%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8D%95%E5%90%91%E6%95%B0%E6%8D%AE%E8%BF%9E%E6%8E%A5%E3%80%82Pipe%E7%B1%BB%E4%B8%AD%E6%9C%89"><span class="toc-number">6.1.0.1.</span> <span class="toc-text">Java NIO包中提供了Pipe类，用来实现两个线程之间的单向数据连接。Pipe类中有</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AAChannel%EF%BC%8C%E5%88%86%E5%88%AB%E6%98%AFSink-Channel%E5%92%8CSource-Channel%E3%80%82"><span class="toc-number">6.1.0.2.</span> <span class="toc-text">两个Channel，分别是Sink Channel和Source Channel。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Sink-Channel%EF%BC%9A%E7%BA%BF%E7%A8%8B%E5%B0%86%E6%95%B0%E6%8D%AE%E5%86%99%E5%85%A5%E5%88%B0Sink-Channel"><span class="toc-number">6.1.0.3.</span> <span class="toc-text">Sink Channel：线程将数据写入到Sink Channel</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#-35"><span class="toc-number">6.1.0.3.1.</span> <span class="toc-text"></span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Source-Channel%EF%BC%9A%E7%BA%BF%E7%A8%8B%E4%BB%8ESource-Channel%E4%B8%AD%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE"><span class="toc-number">6.1.0.4.</span> <span class="toc-text">Source Channel：线程从Source Channel中获取数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E7%9A%84%E4%B8%A4%E4%B8%AA%E7%BA%BF%E7%A8%8B%E9%80%9A%E8%BF%87Pipe%E7%AE%A1%E9%81%93%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E7%9A%84%E4%BE%8B%E5%AD%90%E5%A6%82%E4%B8%8B%EF%BC%9A"><span class="toc-number">6.1.0.5.</span> <span class="toc-text">具体的两个线程通过Pipe管道实现数据传输的例子如下：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#-36"><span class="toc-number">6.1.0.5.1.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#-37"><span class="toc-number">6.1.0.5.2.</span> <span class="toc-text"></span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-FileLock"><span class="toc-number">6.2.</span> <span class="toc-text">2.FileLock</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#FileLock%E8%A1%A8%E7%A4%BA%E6%96%87%E4%BB%B6%E9%94%81%EF%BC%8C%E9%80%9A%E8%BF%87JVM%E8%BF%9B%E7%A8%8B%E5%AF%B9%E8%A6%81%E6%93%8D%E4%BD%9C%E7%9A%84%E6%96%87%E4%BB%B6%E4%B8%8A%E9%94%81%EF%BC%8C%E5%9C%A8%E5%90%8C%E4%B8%80%E6%97%B6%E9%97%B4%E5%8F%AA%E5%85%81%E8%AE%B8%E4%B8%80%E4%B8%AA%E8%BF%9B"><span class="toc-number">6.2.0.1.</span> <span class="toc-text">FileLock表示文件锁，通过JVM进程对要操作的文件上锁，在同一时间只允许一个进</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A8%8B%E8%AE%BF%E9%97%AE%E4%B8%8A%E9%94%81%E7%9A%84%E6%96%87%E4%BB%B6%E3%80%82FileLock%E6%96%87%E4%BB%B6%E9%94%81%E6%98%AF%E8%BF%9B%E7%A8%8B%E7%BA%A7%E5%88%AB%EF%BC%8C%E5%9C%A8%E5%90%8C%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%A4%9A%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%8F%AF%E4%BB%A5"><span class="toc-number">6.2.0.2.</span> <span class="toc-text">程访问上锁的文件。FileLock文件锁是进程级别，在同一个进程中的多个线程可以</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E6%97%B6%E5%AF%B9%E6%96%87%E4%BB%B6%E8%BF%9B%E8%A1%8C%E6%93%8D%E4%BD%9C%E3%80%82"><span class="toc-number">6.2.0.3.</span> <span class="toc-text">同时对文件进行操作。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FileLock%E6%96%87%E4%BB%B6%E9%94%81%E5%8F%88%E5%88%86%E6%88%90%E4%BA%86%E6%8E%92%E5%AE%83%E9%94%81%E5%92%8C%E5%85%B1%E4%BA%AB%E9%94%81%E3%80%82"><span class="toc-number">6.2.0.4.</span> <span class="toc-text">FileLock文件锁又分成了排它锁和共享锁。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%92%E5%AE%83%E9%94%81%EF%BC%9A%E5%8F%AA%E6%9C%89%E8%8E%B7%E5%BE%97%E9%94%81%E7%9A%84%E8%BF%9B%E7%A8%8B%E8%83%BD%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6%E3%80%82"><span class="toc-number">6.2.0.5.</span> <span class="toc-text">排它锁：只有获得锁的进程能读写文件。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E9%94%81%EF%BC%9A%E8%8E%B7%E5%BE%97%E9%94%81%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%8F%AF%E4%BB%A5%E8%AF%BB%E6%96%87%E4%BB%B6%EF%BC%8C%E4%BD%86%E4%B8%8D%E8%83%BD%E5%86%99%E6%96%87%E4%BB%B6%E3%80%82"><span class="toc-number">6.2.0.6.</span> <span class="toc-text">共享锁：获得锁的线程可以读文件，但不能写文件。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%A1%88%E4%BE%8B%EF%BC%9A"><span class="toc-number">6.2.0.7.</span> <span class="toc-text">具体的实现案例：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#-38"><span class="toc-number">6.2.0.7.1.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#x2F-x2F-%E8%8E%B7%E5%BE%97%E6%8E%92%E5%AE%83%E9%94%81%E6%96%B9%E5%BC%8F%E4%B8%80%EF%BC%9A%E9%98%BB%E5%A1%9E%E6%96%B9%E5%BC%8F%E8%8E%B7%E5%BE%97%E9%94%81%EF%BC%8C%E5%A6%82%E6%9E%9C%E9%94%81%E8%A2%AB%E5%85%B6%E4%BB%96%E8%BF%9B%E7%A8%8B%E6%8C%81%E6%9C%89%E5%88%99%E9%98%BB%E5%A1%9E"><span class="toc-number">6.2.0.7.2.</span> <span class="toc-text">&#x2F;&#x2F;获得排它锁方式一：阻塞方式获得锁，如果锁被其他进程持有则阻塞</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-3-4-5-6-7-8"><span class="toc-number">6.2.0.7.3.</span> <span class="toc-text">1 2 3 4 5 6 7 8</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#x2F-x2F-%E8%8E%B7%E5%BE%97%E5%85%B1%E4%BA%AB%E9%94%81%E6%96%B9%EF%BC%8C%E5%8F%82%E6%95%B01-%E9%94%81%E6%96%87%E4%BB%B6%E7%9A%84%E5%85%B7%E4%BD%93%E5%93%AA%E4%B8%80%E9%83%A8%E5%88%86%E5%86%85%E5%AE%B9%E7%9A%84%E8%B5%B7%E5%A7%8B%E4%BD%8D%E7%BD%AE%EF%BC%8C%E5%8F%82%E6%95%B02-%E2%BB%93%E5%BA%A6%EF%BC%8C%E5%8F%82%E6%95%B0"><span class="toc-number">6.2.0.7.4.</span> <span class="toc-text">&#x2F;&#x2F;获得共享锁方，参数1:锁文件的具体哪一部分内容的起始位置，参数2:⻓度，参数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E6%98%AF%E5%90%A6%E5%85%B1%E4%BA%AB"><span class="toc-number">6.2.0.7.5.</span> <span class="toc-text">3:是否共享</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#-39"><span class="toc-number">6.2.0.7.6.</span> <span class="toc-text"></span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%B8%80%EF%BC%9A%E8%8E%B7%E5%BE%97%E9%94%81%E5%90%8E%E9%98%BB%E5%A1%9E"><span class="toc-number">6.2.0.8.</span> <span class="toc-text">进程一：获得锁后阻塞</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%BA%8C%EF%BC%9A%E5%B0%9D%E8%AF%95%E8%8E%B7%E5%BE%97%E9%94%81%E5%B9%B6%E5%86%99%E6%95%B0%E6%8D%AE"><span class="toc-number">6.2.0.9.</span> <span class="toc-text">进程二：尝试获得锁并写数据</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#-40"><span class="toc-number">6.2.0.9.1.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#-41"><span class="toc-number">6.2.0.9.2.</span> <span class="toc-text"></span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Path"><span class="toc-number">6.3.</span> <span class="toc-text">3.Path</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Path%E7%B1%BB%E5%9C%A8JDK7%E4%B8%AD%E5%B7%B2%E7%BB%8F%E5%8A%A0%E5%85%A5%E5%88%B0NIO%E5%8C%85%E5%86%85%EF%BC%8CPath%E8%A1%A8%E7%A4%BA%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84%EF%BC%8C%E5%92%8Cjava%E7%9A%84io%E5%8C%85%E4%B8%8B"><span class="toc-number">6.3.0.1.</span> <span class="toc-text">Path类在JDK7中已经加入到NIO包内，Path表示文件系统中的路径，和java的io包下</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9A%84File%E7%B1%BB%E5%8D%81%E5%88%86%E7%9B%B8%E4%BC%BC%E3%80%82"><span class="toc-number">6.3.0.2.</span> <span class="toc-text">的File类十分相似。</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#-42"><span class="toc-number">6.3.0.2.1.</span> <span class="toc-text"></span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Path%E5%8F%AF%E4%BB%A5%E8%A1%A8%E7%A4%BA%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84%EF%BC%8C%E5%8D%B3%E7%9B%98%E7%AC%A6%E5%9C%A8%E5%86%85%E7%9A%84%E5%AE%8C%E6%95%B4%E8%B7%AF%E5%BE%84%E3%80%82Path%E4%B9%9F%E5%8F%AF%E4%BB%A5%E8%A1%A8%E7%A4%BA%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84%EF%BC%8C%E5%8D%B3%E7%9B%B8"><span class="toc-number">6.3.0.3.</span> <span class="toc-text">Path可以表示绝对路径，即盘符在内的完整路径。Path也可以表示相对路径，即相</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E4%BA%8E%E5%85%B6%E4%BB%96%E8%B7%AF%E5%BE%84%E7%9A%84%E6%96%87%E4%BB%B6%E6%88%96%E7%9B%AE%E5%BD%95%E7%9A%84%E8%B7%AF%E5%BE%84%E3%80%82"><span class="toc-number">6.3.0.4.</span> <span class="toc-text">对于其他路径的文件或目录的路径。</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Files"><span class="toc-number">6.4.</span> <span class="toc-text">4.Files</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#-43"><span class="toc-number">6.4.0.0.1.</span> <span class="toc-text"></span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#NIO%E5%8C%85%E4%B8%AD%E7%9A%84Files%E7%B1%BB%E6%8F%90%E4%BE%9B%E4%BA%86%E6%93%8D%E4%BD%9C%E6%96%87%E4%BB%B6%E5%8F%8A%E7%9B%AE%E5%BD%95%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E3%80%82Files%E9%9C%80%E8%A6%81%E5%92%8CPath%E4%B8%80%E8%B5%B7%E4%BD%BF"><span class="toc-number">6.4.0.1.</span> <span class="toc-text">NIO包中的Files类提供了操作文件及目录的一些常用方法。Files需要和Path一起使</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E3%80%82"><span class="toc-number">6.4.0.2.</span> <span class="toc-text">用。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%9B%AE%E5%BD%95%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9AcreateDirectory"><span class="toc-number">6.4.0.3.</span> <span class="toc-text">创建目录的方法：createDirectory()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AEPath%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9B%AE%E5%BD%95"><span class="toc-number">6.4.0.4.</span> <span class="toc-text">根据Path对象创建一个新目录</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%B7%E2%BB%89%E6%96%87%E4%BB%B6%EF%BC%9Acopy"><span class="toc-number">6.4.0.5.</span> <span class="toc-text">拷⻉文件：copy()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%8B%B7%E2%BB%89%E6%96%87%E4%BB%B6%E7%9A%84%E5%8A%9F%E8%83%BD%EF%BC%8C%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87%E5%8F%AF%E9%80%89%E7%9A%84%E5%8F%82%E6%95%B0%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E7%9A%84%E8%A6%86%E7%9B%96%E3%80%82"><span class="toc-number">6.4.0.6.</span> <span class="toc-text">实现拷⻉文件的功能，可以通过可选的参数实现文件的覆盖。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E6%96%87%E4%BB%B6%EF%BC%9Amove"><span class="toc-number">6.4.0.7.</span> <span class="toc-text">移动文件：move()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%86%E6%96%87%E4%BB%B6%E7%A7%BB%E5%8A%A8%E5%88%B0%E5%8F%A6%E4%B8%80%E4%B8%AA%E7%9B%AE%E5%BD%95%E5%86%85%EF%BC%8C%E5%A6%82%E6%9E%9C%E7%A7%BB%E5%8A%A8%E5%88%B0%E4%BA%86%E5%90%8C%E7%BA%A7%E7%9B%AE%E5%BD%95%EF%BC%8C%E5%88%99%E4%B8%BA%E9%87%8D%E5%91%BD%E5%90%8D%E7%9A%84%E6%95%88%E6%9E%9C%E3%80%82"><span class="toc-number">6.4.0.8.</span> <span class="toc-text">将文件移动到另一个目录内，如果移动到了同级目录，则为重命名的效果。</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#-44"><span class="toc-number">6.4.0.8.1.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#-45"><span class="toc-number">6.4.0.8.2.</span> <span class="toc-text"></span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6%EF%BC%9Adelete"><span class="toc-number">6.4.0.9.</span> <span class="toc-text">删除文件：delete()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%8C%87%E5%AE%9A%E6%96%87%E4%BB%B6%E3%80%82"><span class="toc-number">6.4.0.10.</span> <span class="toc-text">删除指定文件。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E7%9B%AE%E5%BD%95%EF%BC%9AwalkFileTree"><span class="toc-number">6.4.0.11.</span> <span class="toc-text">遍历目录：walkFileTree()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E8%BF%87walkFileTree-Path-path-FileVisitor-fv-%E6%96%B9%E6%B3%95%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0%E7%9B%AE%E5%BD%95%E7%9A%84%E9%81%8D%E5%8E%86%EF%BC%8C"><span class="toc-number">6.4.0.12.</span> <span class="toc-text">通过walkFileTree(Path path,FileVisitor fv)方法可以实现目录的遍历，</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E6%8F%90%E4%BE%9BFileVisitor%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%B1%BB%E5%AF%B9%E8%B1%A1%E6%9D%A5%E5%91%8A%E7%9F%A5%E9%81%8D%E5%8E%86%E6%96%87%E4%BB%B6%E7%9A%84%E5%85%B7%E4%BD%93%E6%8E%AA%E6%96%BD%E3%80%82%E5%85%B6%E4%B8%AD%E9%80%9A%E8%BF%87%E8%BF%94%E5%9B%9E%E7%9A%84"><span class="toc-number">6.4.0.13.</span> <span class="toc-text">通过提供FileVisitor接口的实现类对象来告知遍历文件的具体措施。其中通过返回的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FileVisitResult%E5%91%8A%E7%9F%A5%E9%81%8D%E5%8E%86%E6%AF%8F%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6%E6%97%B6%E7%9A%84%E5%85%B7%E4%BD%93%E4%B8%8B%E4%B8%80%E6%AD%A5%E5%8A%A8%E4%BD%9C%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E6%AF%94%E5%A6%82%EF%BC%9A%E7%BB%A7%E7%BB%AD"><span class="toc-number">6.4.0.14.</span> <span class="toc-text">FileVisitResult告知遍历每一个文件时的具体下一步动作是什么，比如：继续</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88CONTINUE%EF%BC%89%E3%80%81%E7%BB%88%E6%AD%A2%EF%BC%88TERMINATE%EF%BC%89%E3%80%81%E8%B7%B3%E8%BF%87%E5%90%8C%E7%BA%A7%EF%BC%88SKIP-SIBLING%EF%BC%89%E3%80%81%E8%B7%B3%E8%BF%87%E5%AD%90%E7%BA%A7"><span class="toc-number">6.4.0.15.</span> <span class="toc-text">（CONTINUE）、终止（TERMINATE）、跳过同级（SKIP_SIBLING）、跳过子级</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88SKIP-SUBTREE%EF%BC%89%E3%80%82"><span class="toc-number">6.4.0.16.</span> <span class="toc-text">（SKIP_SUBTREE）。</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#-46"><span class="toc-number">6.4.0.16.1.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#-47"><span class="toc-number">6.4.0.16.2.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#-48"><span class="toc-number">6.4.0.16.3.</span> <span class="toc-text"></span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-AsynchronousFileChannel"><span class="toc-number">6.5.</span> <span class="toc-text">5.AsynchronousFileChannel</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8Java7%E4%B8%AD%E5%8A%A0%E5%85%A5%E4%BA%86%E6%94%AF%E6%8C%81%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C%E7%9A%84%E6%96%87%E4%BB%B6%E9%80%9A%E9%81%93AsynchronousFileChannel%EF%BC%8C%E9%A6%96%E5%85%88%E8%A6%81%E7%90%86%E8%A7%A3"><span class="toc-number">6.5.0.1.</span> <span class="toc-text">在Java7中加入了支持异步操作的文件通道AsynchronousFileChannel，首先要理解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C%E3%80%82%E6%89%80%E8%B0%93%E7%9A%84%E5%BC%82%E6%AD%A5%EF%BC%8C%E5%B0%B1%E6%98%AF%E5%9C%A8%E5%AF%B9%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99%E7%9A%84%E8%BF%87%E7%A8%8B%E4%B8%AD%EF%BC%8C%E7%A8%8B%E5%BA%8F%E4%B8%8D%E9%9C%80%E8%A6%81%E7%AD%89%E5%BE%85%E6%96%87%E4%BB%B6"><span class="toc-number">6.5.0.2.</span> <span class="toc-text">什么是异步操作。所谓的异步，就是在对文件读写的过程中，程序不需要等待文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E5%AE%8C%E6%AF%95%EF%BC%8C%E5%B0%B1%E5%8F%AF%E4%BB%A5%E7%9B%B4%E6%8E%A5%E6%89%A7%E8%A1%8C%E4%B9%8B%E5%90%8E%E7%9A%84%E4%BB%A3%E7%A0%81%E3%80%82%E5%8F%AF%E4%BB%A5%E8%AE%BE%E7%BD%AE%E7%9B%91%E5%90%AC%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E8%AF%BB%E5%86%99%E5%AE%8C%E6%AF%95%E4%B9%8B%E5%90%8E%E7%9A%84%E6%93%8D"><span class="toc-number">6.5.0.3.</span> <span class="toc-text">读写完毕，就可以直接执行之后的代码。可以设置监听程序执行读写完毕之后的操</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%9C%E3%80%82"><span class="toc-number">6.5.0.4.</span> <span class="toc-text">作。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%BC%82%E6%AD%A5%E6%96%87%E4%BB%B6%E9%80%9A%E9%81%93"><span class="toc-number">6.5.0.5.</span> <span class="toc-text">创建异步文件通道</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%82%E6%95%B0%E6%98%AF%E8%A6%81%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C%E7%9A%84%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84%EF%BC%8C%E7%AC%AC%E4%BA%8C%E4%B8%AA%E5%8F%82%E6%95%B0%E6%98%AF%E6%8C%87%E6%98%8E%E4%BD%BF%E7%94%A8%E8%AF%BB%E6%93%8D%E4%BD%9C%E3%80%82"><span class="toc-number">6.5.0.6.</span> <span class="toc-text">第一个参数是要异步操作的文件路径，第二个参数是指明使用读操作。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE%E7%9A%84%E6%96%B9%E5%BC%8F%E4%B8%80%EF%BC%9A%E8%8E%B7%E5%BE%97Future%E7%9A%84%E8%AF%BB"><span class="toc-number">6.5.0.7.</span> <span class="toc-text">读取数据的方式一：获得Future的读</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E5%BC%82%E6%AD%A5%E7%9A%84%E8%AF%BB%E6%95%B0%E6%8D%AE%EF%BC%8C%E8%BF%94%E5%9B%9EFuture%E5%AF%B9%E8%B1%A1%EF%BC%8C%E8%AF%BB%E6%95%B0%E6%8D%AE%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%AB%8B%E5%8D%B3%E8%BF%94%E5%9B%9EFuture%E5%AF%B9%E8%B1%A1%EF%BC%8C%E5%8D%B3%E6%97%B6%E8%AF%BB"><span class="toc-number">6.5.0.8.</span> <span class="toc-text">通过异步的读数据，返回Future对象，读数据过程中立即返回Future对象，即时读</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E8%BF%98%E6%9C%AA%E5%AE%8C%E6%88%90%E3%80%82%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87Future%E5%AF%B9%E8%B1%A1%E4%B8%AD%E7%9A%84isDone-%E6%96%B9%E6%B3%95%E5%BE%97%E7%9F%A5%E8%AF%BB%E6%93%8D%E4%BD%9C%E6%98%AF%E5%90%A6%E5%B7%B2%E5%AE%8C%E6%88%90%E3%80%82"><span class="toc-number">6.5.0.9.</span> <span class="toc-text">操作还未完成。可以通过Future对象中的isDone()方法得知读操作是否已完成。</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#-49"><span class="toc-number">6.5.0.9.1.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#-50"><span class="toc-number">6.5.0.9.2.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#-51"><span class="toc-number">6.5.0.9.3.</span> <span class="toc-text"></span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE%E7%9A%84%E6%96%B9%E5%BC%8F%E4%BA%8C%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%BC%82%E6%AD%A5%E7%9B%91%E5%90%AC%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">6.5.0.10.</span> <span class="toc-text">读取数据的方式二：使用异步监听的方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BD%93%E8%AF%BB%E5%8F%96%E5%AE%8C%E6%88%90%E5%90%8E%EF%BC%8C%E4%BC%9A%E8%B0%83%E7%94%A8CompletionHandler%E5%AF%B9%E8%B1%A1%E7%9A%84completed%E6%96%B9%E6%B3%95%EF%BC%8C%E5%9C%A8%E6%96%B9%E6%B3%95%E4%B8%AD%E5%81%9A%E8%AF%BB%E5%8F%96"><span class="toc-number">6.5.0.11.</span> <span class="toc-text">当读取完成后，会调用CompletionHandler对象的completed方法，在方法中做读取</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%AE%8C%E6%AF%95%E5%90%8E%E7%9A%84%E6%93%8D%E4%BD%9C%E3%80%82"><span class="toc-number">6.5.0.12.</span> <span class="toc-text">数据完毕后的操作。</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#-52"><span class="toc-number">6.5.0.12.1.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#-53"><span class="toc-number">6.5.0.12.2.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#-54"><span class="toc-number">6.5.0.12.3.</span> <span class="toc-text"></span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%99%E5%85%A5%E6%95%B0%E6%8D%AE%E7%9A%84%E6%96%B9%E5%BC%8F%E4%B8%80%EF%BC%9A%E8%8E%B7%E5%BE%97Future%E7%9A%84%E5%86%99"><span class="toc-number">6.5.0.13.</span> <span class="toc-text">写入数据的方式一：获得Future的写</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E5%BC%82%E6%AD%A5%E7%9A%84%E5%86%99%E6%95%B0%E6%8D%AE%EF%BC%8C%E8%BF%94%E5%9B%9EFuture%E5%AF%B9%E8%B1%A1%EF%BC%8C%E5%86%99%E6%95%B0%E6%8D%AE%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%AB%8B%E5%8D%B3%E8%BF%94%E5%9B%9EFuture%E5%AF%B9%E8%B1%A1%EF%BC%8C%E5%8D%B3%E6%97%B6%E5%86%99"><span class="toc-number">6.5.0.14.</span> <span class="toc-text">通过异步的写数据，返回Future对象，写数据过程中立即返回Future对象，即时写</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E8%BF%98%E6%9C%AA%E5%AE%8C%E6%88%90%E3%80%82%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87Future%E5%AF%B9%E8%B1%A1%E4%B8%AD%E7%9A%84isDone-%E6%96%B9%E6%B3%95%E5%BE%97%E7%9F%A5%E5%86%99%E6%93%8D%E4%BD%9C%E6%98%AF%E5%90%A6%E5%B7%B2%E5%AE%8C%E6%88%90%E3%80%82"><span class="toc-number">6.5.0.15.</span> <span class="toc-text">操作还未完成。可以通过Future对象中的isDone()方法得知写操作是否已完成。</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#x2F-x2F-%E4%B8%BA%E4%BA%86%E6%9F%A5%E7%9C%8B%E6%95%88%E6%9E%9C%EF%BC%8C%E8%AE%A9%E7%A8%8B%E5%BA%8F%E7%AD%89%E5%BE%85%E5%BC%82%E6%AD%A5%E7%9A%84%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C"><span class="toc-number">6.5.0.15.1.</span> <span class="toc-text">&#x2F;&#x2F;为了查看效果，让程序等待异步的执行结果</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#-55"><span class="toc-number">6.5.0.15.2.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#-56"><span class="toc-number">6.5.0.15.3.</span> <span class="toc-text"></span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%99%E5%85%A5%E6%95%B0%E6%8D%AE%E7%9A%84%E6%96%B9%E5%BC%8F%E4%BA%8C%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%BC%82%E6%AD%A5%E7%9B%91%E5%90%AC%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">6.5.0.16.</span> <span class="toc-text">写入数据的方式二：使用异步监听的方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BD%93%E5%86%99%E6%95%B0%E6%8D%AE%E5%AE%8C%E6%88%90%E5%90%8E%EF%BC%8C%E4%BC%9A%E8%B0%83%E7%94%A8CompletionHandler%E5%AF%B9%E8%B1%A1%E7%9A%84completed%E6%96%B9%E6%B3%95%EF%BC%8C%E5%9C%A8%E6%96%B9%E6%B3%95%E4%B8%AD%E5%81%9A%E5%86%99"><span class="toc-number">6.5.0.17.</span> <span class="toc-text">当写数据完成后，会调用CompletionHandler对象的completed方法，在方法中做写</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%AE%8C%E6%AF%95%E5%90%8E%E7%9A%84%E6%93%8D%E4%BD%9C%E3%80%82-1"><span class="toc-number">6.5.0.18.</span> <span class="toc-text">数据完毕后的操作。</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#-57"><span class="toc-number">6.5.0.18.1.</span> <span class="toc-text"></span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%83%E3%80%81NIO%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B-%E8%81%8A%E5%A4%A9%E5%AE%A4"><span class="toc-number">7.</span> <span class="toc-text">七、NIO综合案例-聊天室</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E8%81%8A%E5%A4%A9%E5%AE%A4%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%BC%96%E5%86%99"><span class="toc-number">7.1.</span> <span class="toc-text">1.聊天室服务端编写</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E8%81%8A%E5%A4%A9%E5%AE%A4%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%BC%96%E5%86%99-1"><span class="toc-number">7.2.</span> <span class="toc-text">1.聊天室服务端编写</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#-58"><span class="toc-number">7.2.0.0.1.</span> <span class="toc-text">}</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#x2F-1"><span class="toc-number">7.2.0.0.2.</span> <span class="toc-text">&#x2F;**</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%86%99%E6%95%B0%E6%8D%AE%E7%9A%84%E8%AF%B7%E6%B1%82%E2%80%94%E2%80%94%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%A4%84%E4%BA%8E%E8%AF%BB%E6%93%8D%E4%BD%9C%E7%9A%84%E5%B0%B1%E7%BB%AA%E7%8A%B6%E6%80%81"><span class="toc-number">7.2.0.0.3.</span> <span class="toc-text">* 处理客户端写数据的请求——服务端处于读操作的就绪状态</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#-59"><span class="toc-number">7.2.0.0.4.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#-60"><span class="toc-number">7.2.0.0.5.</span> <span class="toc-text"></span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E8%81%8A%E5%A4%A9%E5%AE%A4%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%BC%96%E5%86%99"><span class="toc-number">7.3.</span> <span class="toc-text">2.聊天室客户端编写</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#-61"><span class="toc-number">7.3.0.0.1.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#-62"><span class="toc-number">7.3.0.0.2.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#-63"><span class="toc-number">7.3.0.0.3.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#-64"><span class="toc-number">7.3.0.0.4.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#-65"><span class="toc-number">7.3.0.0.5.</span> <span class="toc-text">}</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#-66"><span class="toc-number">7.3.0.0.6.</span> <span class="toc-text"></span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AB%E3%80%81Java-AIO"><span class="toc-number">8.</span> <span class="toc-text">八、Java-AIO</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-AIO%E6%A6%82%E8%BF%B0"><span class="toc-number">8.1.</span> <span class="toc-text">1.AIO概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Asynchronous-IO%E4%B9%9F%E7%A7%B0%E4%B8%BAAIO%EF%BC%8C%E5%8D%B3%E5%BC%82%E6%AD%A5%E9%9D%9E%E9%98%BB%E5%A1%9EIO%E3%80%82Java7%E6%8F%90%E4%BE%9B%E4%BA%86%E6%94%B9%E8%BF%9B%E7%89%88%E7%9A%84NIO%EF%BC%8C%E5%BC%95%E5%85%A5%E4%BA%86-1"><span class="toc-number">8.1.0.1.</span> <span class="toc-text">Asynchronous IO也称为AIO，即异步非阻塞IO。Java7提供了改进版的NIO，引入了</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E9%9D%9E%E9%98%BB%E5%A1%9E%E7%9A%84IO%EF%BC%8C%E7%94%B1%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%8C%E6%88%90%E5%90%8E%E5%9B%9E%E8%B0%83%E9%80%9A%E7%9F%A5%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8%E7%BA%BF%E7%A8%8B%E5%8E%BB%E5%A4%84%E7%90%86%E3%80%82%E4%B8%80%E8%88%AC%E9%80%82"><span class="toc-number">8.1.0.2.</span> <span class="toc-text">异步非阻塞的IO，由操作系统完成后回调通知服务端程序启动线程去处理。一般适</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E4%BA%8E%E8%BF%9E%E6%8E%A5%E6%95%B0%E8%BE%83%E5%A4%9A%E4%B8%94%E8%BF%9E%E6%8E%A5%E6%97%B6%E9%97%B4%E8%BE%83%E2%BB%93%E7%9A%84%E5%BA%94%E7%94%A8%E3%80%82"><span class="toc-number">8.1.0.3.</span> <span class="toc-text">用于连接数较多且连接时间较⻓的应用。</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-AIO%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="toc-number">8.2.</span> <span class="toc-text">2.AIO具体实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%AE%9E%E7%8E%B0"><span class="toc-number">8.2.0.1.</span> <span class="toc-text">服务端实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AE%9E%E7%8E%B0"><span class="toc-number">8.2.0.2.</span> <span class="toc-text">客户端实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#-67"><span class="toc-number">8.2.0.2.1.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#x2F-2"><span class="toc-number">8.2.0.2.2.</span> <span class="toc-text">&#x2F;**</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#AIO%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">8.2.0.2.3.</span> <span class="toc-text">* AIO客户端</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-BIO%E3%80%81NIO%E3%80%81AIO%E5%AF%B9%E6%AF%94"><span class="toc-number">8.3.</span> <span class="toc-text">3.BIO、NIO、AIO对比</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#BIONIOAIO"><span class="toc-number">8.3.0.0.1.</span> <span class="toc-text">BIO				NIO					AIO</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/DoublePeach/myblog/2024/01/04/%E4%B8%9A%E5%8A%A1%E5%B9%82%E7%AD%89%E6%80%A7%E7%9A%84%E5%AE%9E%E7%8E%B0/" title="业务幂等性的实现"><img src="/DoublePeach/myblog/img/HuLi.jpg" onerror="this.onerror=null;this.src='/DoublePeach/myblog/img/404.jpg'" alt="业务幂等性的实现"/></a><div class="content"><a class="title" href="/DoublePeach/myblog/2024/01/04/%E4%B8%9A%E5%8A%A1%E5%B9%82%E7%AD%89%E6%80%A7%E7%9A%84%E5%AE%9E%E7%8E%B0/" title="业务幂等性的实现">业务幂等性的实现</a><time datetime="2024-01-04T15:33:17.000Z" title="发表于 2024-01-04 23:33:17">2024-01-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/DoublePeach/myblog/2023/12/20/MQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02%EF%BC%88%E8%BF%9B%E9%98%B6%EF%BC%89/" title="MQ学习笔记2（进阶）"><img src="/DoublePeach/myblog/img/HuLi.jpg" onerror="this.onerror=null;this.src='/DoublePeach/myblog/img/404.jpg'" alt="MQ学习笔记2（进阶）"/></a><div class="content"><a class="title" href="/DoublePeach/myblog/2023/12/20/MQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02%EF%BC%88%E8%BF%9B%E9%98%B6%EF%BC%89/" title="MQ学习笔记2（进阶）">MQ学习笔记2（进阶）</a><time datetime="2023-12-20T11:25:34.000Z" title="发表于 2023-12-20 19:25:34">2023-12-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/DoublePeach/myblog/2023/12/08/MQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/" title="MQ学习笔记1（基础）"><img src="/DoublePeach/myblog/img/HuLi.jpg" onerror="this.onerror=null;this.src='/DoublePeach/myblog/img/404.jpg'" alt="MQ学习笔记1（基础）"/></a><div class="content"><a class="title" href="/DoublePeach/myblog/2023/12/08/MQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/" title="MQ学习笔记1（基础）">MQ学习笔记1（基础）</a><time datetime="2023-12-08T10:25:34.000Z" title="发表于 2023-12-08 18:25:34">2023-12-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/DoublePeach/myblog/2023/11/15/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E7%A5%9E%E7%A7%98%E6%8A%A5%E9%94%99/" title="记录一次数据库的神秘报错"><img src="/DoublePeach/myblog/img/HuLi.jpg" onerror="this.onerror=null;this.src='/DoublePeach/myblog/img/404.jpg'" alt="记录一次数据库的神秘报错"/></a><div class="content"><a class="title" href="/DoublePeach/myblog/2023/11/15/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E7%A5%9E%E7%A7%98%E6%8A%A5%E9%94%99/" title="记录一次数据库的神秘报错">记录一次数据库的神秘报错</a><time datetime="2023-11-15T11:57:38.000Z" title="发表于 2023-11-15 19:57:38">2023-11-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/DoublePeach/myblog/2023/07/09/NIO%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%88%86%E4%BA%AB/" title="NIO学习笔记分享"><img src="/DoublePeach/myblog/img/HuLi.jpg" onerror="this.onerror=null;this.src='/DoublePeach/myblog/img/404.jpg'" alt="NIO学习笔记分享"/></a><div class="content"><a class="title" href="/DoublePeach/myblog/2023/07/09/NIO%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%88%86%E4%BA%AB/" title="NIO学习笔记分享">NIO学习笔记分享</a><time datetime="2023-07-09T14:22:51.000Z" title="发表于 2023-07-09 22:22:51">2023-07-09</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/DoublePeach/myblog/img/HuLi.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By DoublePeach</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">已经到底了，别往下划啦，更多详情划到上面添加我滴QQ微信，我们畅谈人生！</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="聊天"><i class="fas fa-sms"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/DoublePeach/myblog/js/utils.js"></script><script src="/DoublePeach/myblog/js/main.js"></script><script src="/DoublePeach/myblog/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/DoublePeach/myblog/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>