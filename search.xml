<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>业务幂等性的实现</title>
      <link href="/DoublePeach/myblog/2024/01/04/%E4%B8%9A%E5%8A%A1%E5%B9%82%E7%AD%89%E6%80%A7%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
      <url>/DoublePeach/myblog/2024/01/04/%E4%B8%9A%E5%8A%A1%E5%B9%82%E7%AD%89%E6%80%A7%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p><strong>业务幂等性</strong>是指对同一个业务操作的多次执行所产生的结果与仅执行一次的结果相同。换句话说，无论对一个业务操作执行多少次，最终的结果都应该是一致的。<br>在微服务项目中，保证业务幂等性非常重要，因为微服务架构通常涉及到多个服务之间的协作和交互。如果某个业务操作不具备幂等性，那么在出现网络延迟、故障重试或者其他异常情况时，可能会导致数据的不一致或者产生错误的结果。</p><p><strong>以下是实现业务幂等性的4种方案</strong></p><h1 id="方案一：数据库唯一主键"><a href="#方案一：数据库唯一主键" class="headerlink" title="方案一：数据库唯一主键"></a>方案一：数据库唯一主键</h1><h2 id="方案描述"><a href="#方案描述" class="headerlink" title="方案描述"></a>方案描述</h2><p>数据库唯一主键的实现主要是利用数据库中主键唯一约束的特性，一般来说唯一主键比较适用于“插入”时的幂等性，其能保证一张表中只能存在一条带该唯一主键的记录。<br>使用数据库唯一主键完成幂等性时需要注意的是，该主键一般来说并不是使用数据库中自增主键，而是使用分布式 ID 充当主键（可以参考 Java 中分布式 ID 的设计方案 这篇文章），这样才能能保证在分布式环境下 ID 的全局唯一性。</p><h2 id="适用操作："><a href="#适用操作：" class="headerlink" title="适用操作："></a>适用操作：</h2><p>插入操作<br>删除操作</p><h2 id="使用限制："><a href="#使用限制：" class="headerlink" title="使用限制："></a>使用限制：</h2><p>需要生成全局唯一主键 ID</p><h2 id="主要流程："><a href="#主要流程：" class="headerlink" title="主要流程："></a>主要流程：</h2><img src="/2024/01/04/%E4%B8%9A%E5%8A%A1%E5%B9%82%E7%AD%89%E6%80%A7%E7%9A%84%E5%AE%9E%E7%8E%B0/bf469f56993005d29fbdeaf8a2e80743.png" class><h2 id="主要流程：-1"><a href="#主要流程：-1" class="headerlink" title="主要流程："></a>主要流程：</h2><p>① 客户端执行创建请求，调用服务端接口。<br>② 服务端执行业务逻辑，生成一个分布式 ID，将该 ID 充当待插入数据的主键，然后执数据插入操作，运行对应的 SQL 语句。<br>③ 服务端将该条数据插入数据库中，如果插入成功则表示没有重复调用接口。如果抛出主键重复异常，则表示数据库中已经存在该条记录，返回错误信息到客户端。</p><h1 id="方案二：数据库乐观锁"><a href="#方案二：数据库乐观锁" class="headerlink" title="方案二：数据库乐观锁"></a>方案二：数据库乐观锁</h1><h2 id="方案描述："><a href="#方案描述：" class="headerlink" title="方案描述："></a>方案描述：</h2><p>数据库乐观锁方案一般只能适用于执行“更新操作”的过程，我们可以提前在对应的数据表中多添加一个字段，充当当前数据的版本标识。这样每次对该数据库该表的这条数据执行更新时，都会将该版本标识作为一个条件，值为上次待更新数据中的版本标识的值。</p><h2 id="适用操作：-1"><a href="#适用操作：-1" class="headerlink" title="适用操作："></a>适用操作：</h2><p>更新操作</p><h2 id="使用限制：-1"><a href="#使用限制：-1" class="headerlink" title="使用限制："></a>使用限制：</h2><p>需要数据库对应业务表中添加额外字段；</p><h2 id="描述示例："><a href="#描述示例：" class="headerlink" title="描述示例："></a>描述示例：</h2><img src="/2024/01/04/%E4%B8%9A%E5%8A%A1%E5%B9%82%E7%AD%89%E6%80%A7%E7%9A%84%E5%AE%9E%E7%8E%B0/b60d4adf4e8995a9ad66f9c504276e3f.png" class><h1 id="方案三：防重-Token-令牌"><a href="#方案三：防重-Token-令牌" class="headerlink" title="方案三：防重 Token 令牌"></a>方案三：防重 Token 令牌</h1><h2 id="方案描述：-1"><a href="#方案描述：-1" class="headerlink" title="方案描述："></a>方案描述：</h2><p>针对客户端连续点击或者调用方的超时重试等情况，例如提交订单，此种操作就可以用 Token 的机制实现防止重复提交。简单的说就是调用方在调用接口的时候先向后端请求一个全局 ID（Token），请求的时候携带这个全局 ID 一起请求（Token 最好将其放到 Headers 中），后端需要对这个 Token 作为 Key，用户信息作为 Value 到 Redis 中进行键值内容校验，如果 Key 存在且 Value 匹配就执行删除命令，然后正常执行后面的业务逻辑。如果不存在对应的 Key 或 Value 不匹配就返回重复执行的错误信息，这样来保证幂等操作。</p><h2 id="适用操作：-2"><a href="#适用操作：-2" class="headerlink" title="适用操作："></a>适用操作：</h2><p>插入操作<br>更新操作<br>删除操作</p><h2 id="使用限制：-2"><a href="#使用限制：-2" class="headerlink" title="使用限制："></a>使用限制：</h2><p>需要生成全局唯一 Token 串；<br>需要使用第三方组件 Redis 进行数据效验；</p><h2 id="主要流程：-2"><a href="#主要流程：-2" class="headerlink" title="主要流程："></a>主要流程：</h2><img src="/2024/01/04/%E4%B8%9A%E5%8A%A1%E5%B9%82%E7%AD%89%E6%80%A7%E7%9A%84%E5%AE%9E%E7%8E%B0/a685d6acdc67c720b6af6e633a68eea0.png" class><p>① 服务端提供获取 Token 的接口，该 Token 可以是一个序列号，也可以是一个分布式 ID 或者 UUID 串。<br>② 客户端调用接口获取 Token，这时候服务端会生成一个 Token 串。<br>③ 然后将该串存入 Redis 数据库中，以该 Token 作为 Redis 的键（注意设置过期时间）。<br>④ 将 Token 返回到客户端，客户端拿到后应存到表单隐藏域中。<br>⑤ 客户端在执行提交表单时，把 Token 存入到 Headers 中，执行业务请求带上该 Headers。<br>⑥ 服务端接收到请求后从 Headers 中拿到 Token，然后根据 Token 到 Redis 中查找该 key 是否存在。<br>⑦ 服务端根据 Redis 中是否存该 key 进行判断，如果存在就将该 key 删除，然后正常执行业务逻辑。如果不存在就抛异常，返回重复提交的错误信息。<br>    注意，在并发情况下，执行 Redis 查找数据与删除需要保证原子性，否则很可能在并发下无法保证幂等性。其实现方法可以使用分布式锁或者使用 Lua 表达式来注销查询与删除操作。</p><h1 id="方案四、下游传递唯一序列号"><a href="#方案四、下游传递唯一序列号" class="headerlink" title="方案四、下游传递唯一序列号"></a>方案四、下游传递唯一序列号</h1><h2 id="方案描述：-2"><a href="#方案描述：-2" class="headerlink" title="方案描述："></a>方案描述：</h2><p>所谓请求序列号，其实就是每次向服务端请求时候附带一个短时间内唯一不重复的序列号，该序列号可以是一个有序 ID，也可以是一个订单号，一般由下游生成，在调用上游服务端接口时附加该序列号和用于认证的 ID。</p><p>当上游服务器收到请求信息后拿取该 序列号 和下游 认证ID 进行组合，形成用于操作 Redis 的 Key，然后到 Redis 中查询是否存在对应的 Key 的键值对，根据其结果：</p><p>如果存在，就说明已经对该下游的该序列号的请求进行了业务处理，这时可以直接响应重复请求的错误信息。如果不存在，就以该 Key 作为 Redis 的键，以下游关键信息作为存储的值（例如下游商传递的一些业务逻辑信息），将该键值对存储到 Redis 中 ，然后再正常执行对应的业务逻辑即可。</p><h2 id="适用操作：-3"><a href="#适用操作：-3" class="headerlink" title="适用操作："></a>适用操作：</h2><p>插入操作<br>更新操作<br>删除操作</p><h2 id="使用限制：-3"><a href="#使用限制：-3" class="headerlink" title="使用限制："></a>使用限制：</h2><p>要求第三方传递唯一序列号；<br>需要使用第三方组件 Redis 进行数据效验；</p><h2 id="主要流程：-3"><a href="#主要流程：-3" class="headerlink" title="主要流程："></a>主要流程：</h2><img src="/2024/01/04/%E4%B8%9A%E5%8A%A1%E5%B9%82%E7%AD%89%E6%80%A7%E7%9A%84%E5%AE%9E%E7%8E%B0/d1ff756ec1d24b443e003f819fc68ad0.png" class><h2 id="主要步骤："><a href="#主要步骤：" class="headerlink" title="主要步骤："></a>主要步骤：</h2><p>① 下游服务生成分布式 ID 作为序列号，然后执行请求调用上游接口，并附带“唯一序列号”与请求的“认证凭据ID”。<br>② 上游服务进行安全效验，检测下游传递的参数中是否存在“序列号”和“凭据ID”。<br>③ 上游服务到 Redis 中检测是否存在对应的“序列号”与“认证ID”组成的 Key，如果存在就抛出重复执行的异常信息，然后响应下游对应的错误信息。如果不存在就以该“序列号”和“认证ID”组合作为 Key，以下游关键信息作为 Value，进而存储到 Redis 中，然后正常执行接来来的业务逻辑。<br>    上面步骤中插入数据到 Redis 一定要设置过期时间。这样能保证在这个时间范围内，如果重复调用接口，则能够进行判断识别。如果不设置过期时间，很可能导致数据无限量的存入 Redis，致使 Redis 不能正常工作。</p><br><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>实现业务幂等性有以下几种方案：</p><table><thead><tr><th>方案名称</th><th>适用方法</th><th>实现复杂度</th><th>方案缺点</th></tr></thead><tbody><tr><td>数据库唯一主键</td><td>插入操作 删除操作</td><td>简单</td><td>只能用于插入操作； 只能用于存在唯一主键场景；</td></tr><tr><td>数据库乐观锁</td><td>更新操作</td><td>简单</td><td>只能用于更新操作；表中需要额外添加字段；</td></tr><tr><td>请求序列号</td><td>插入操作 更新操作 删除操作</td><td>简单</td><td>需要保证下游生成唯一序列号；需要 Redis 第三方存储已经请求的序列号；</td></tr><tr><td>防重 Token 令牌</td><td>插入操作 更新操作 删除操作</td><td>适中</td><td>需要 Redis 第三方存储生成的 Token 串；</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 微服务解决方案 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 业务幂等性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MQ学习笔记2（进阶）</title>
      <link href="/DoublePeach/myblog/2023/12/20/MQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02%EF%BC%88%E8%BF%9B%E9%98%B6%EF%BC%89/"/>
      <url>/DoublePeach/myblog/2023/12/20/MQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02%EF%BC%88%E8%BF%9B%E9%98%B6%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h1><p>在了解基本的MQ发布订阅机制后，我脑中就有一个<strong>疑惑</strong>，发布者完成自己的业务然后通过发送消息到MQ，但如果消息到达MQ后此时MQ却宕机了导致消息丢失了，或者MQ向订阅者发送消息时，发送失败了，那么这些情况都会导致下游的消费者和上游的发布者的业务处理数据不一致的情况，在很多业务上都会出现bug，甚至造成不可挽回的损失，<strong>这怎么处理呢？</strong></p><p>那么我们应该要有相应的措施，来解决MQ在消息发送过程中可能会出现的消息丢失的情况，<strong>保证消息的可靠性，进而保障业务的安全运行！</strong></p><p><strong>在MQ工作流程中，以下原因会导致消息丢失：</strong></p><ul><li><strong>发送消息时丢失：</strong><ul><li>生产者发送消息时连接MQ失败</li><li>生产者发送消息到达MQ后未找到<code>Exchange</code></li><li>生产者发送消息到达MQ的<code>Exchange</code>后，未找到合适的<code>Queue</code></li><li>消息到达MQ后，处理消息的进程发生异常</li></ul></li><li><strong>MQ导致消息丢失：</strong><ul><li>消息到达MQ，保存到队列后，尚未消费就突然宕机</li></ul></li><li><strong>消费者处理消息时：</strong><ul><li>消息接收后尚未处理突然宕机</li><li>消息接收后处理过程中抛出异常</li></ul></li></ul><p><strong>那应该如何确保MQ消息的可靠性？</strong>可以从三方面保障：<strong>保障发送者的可靠性、保障MQ的可靠性、保障消费者的可靠性</strong></p><h1 id="1-发送者的可靠性"><a href="#1-发送者的可靠性" class="headerlink" title="1.发送者的可靠性"></a>1.发送者的可靠性</h1><h2 id="1-1-生产者重试机制"><a href="#1-1-生产者重试机制" class="headerlink" title="1.1 生产者重试机制"></a>1.1 生产者重试机制</h2><p>当生产者发送消息时，出现网络故障导致MQ没有收到消息，可以使用SpringAMQP提供的消息发送时的重试机制</p><p><strong>即：当<code>RabbitTemplate</code>与MQ连接超时后，多次重试。</strong></p><p>只需要添加以下配置即可：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">connection-timeout:</span> <span class="string">1s</span> <span class="comment"># 设置MQ的连接超时时间</span></span><br><span class="line">    <span class="attr">template:</span></span><br><span class="line">      <span class="attr">retry:</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启超时重试机制</span></span><br><span class="line">        <span class="attr">initial-interval:</span> <span class="string">1000ms</span> <span class="comment"># 失败后的初始等待时间</span></span><br><span class="line">        <span class="attr">multiplier:</span> <span class="number">1</span> <span class="comment"># 失败后下次的等待时长倍数，下次等待时长 = initial-interval * multiplier</span></span><br><span class="line">        <span class="attr">max-attempts:</span> <span class="number">3</span> <span class="comment"># 最大重试次数</span></span><br></pre></td></tr></table></figure><p><strong>注意：这种重试机制是阻塞式的重试，也就是说重试过程时，当前线程是阻塞的，若对业务性能有要求，建议禁用重试功能</strong></p><h2 id="1-2-生产者确认机制"><a href="#1-2-生产者确认机制" class="headerlink" title="1.2 生产者确认机制"></a>1.2 生产者确认机制</h2><p>当发送者发送消息到MQ后仍丢失，可以针对这种情况开启生产者消息确认机制</p><p>当生产者发送消息给MQ后，MQ会根据消息处理的情况返回不同的<strong>回执</strong> <strong>（ACK、NACK、return）</strong></p><img src="/2023/12/20/MQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02%EF%BC%88%E8%BF%9B%E9%98%B6%EF%BC%89/17a90f7f73ac47cebffa13568ee9bca3.png" class><ul><li>当消息投递到MQ，但是路由失败时，通过<strong>Publisher Return</strong>返回异常信息，同时返回ack的确认信息，代表投递成功</li><li>临时消息投递到了MQ，并且入队成功，返回ACK，告知投递成功</li><li>持久消息投递到了MQ，并且入队完成持久化，返回ACK ，告知投递成功</li><li>其它情况都会返回NACK，告知投递失败</li></ul><p>其中<code>ack</code>和<code>nack</code>属于<strong>Publisher Confirm</strong>机制，<code>ack</code>是投递成功；<code>nack</code>是投递失败。而<code>return</code>则属于<strong>Publisher Return</strong>机制。<br>默认两种机制都是关闭状态，需要通过配置文件来开启。</p><pre><code>    **实现过程略**（其实也就添加配置即可）</code></pre><p><strong>注意：</strong></p><p>开启生产者确认机制比较<strong>消耗MQ性能</strong>，一般不建议开启。并且触发确认只有以下几种情况：</p><ul><li><p>路由失败：一般是因为RoutingKey错误导致，往往是编程导致</p></li><li><p>交换机名称错误：同样是编程错误导致</p></li><li><p>MQ内部故障：这种需要处理，但概率往往较低。因此只有对消息可靠性要求非常高的业务才需要开启，而且仅仅需要开启ConfirmCallback处理nack就可以了。</p><p>  **综上，一般场景下并不需要开启这种机制！**</p></li></ul><h1 id="2-MQ的可靠性"><a href="#2-MQ的可靠性" class="headerlink" title="2. MQ的可靠性"></a>2. MQ的可靠性</h1><h2 id="2-1-数据持久化"><a href="#2-1-数据持久化" class="headerlink" title="2.1 数据持久化"></a>2.1 数据持久化</h2><p>为了提升性能，<strong>默认情况下</strong>MQ的数据都是在<strong>内存</strong>存储的临时数据，重启后就会消失。为了保证数据的可靠性，必须配置数据持久化，包括：</p><ul><li>交换机持久化<ul><li>在控制台的<code>Exchanges</code>页面，添加交换机时可以配置交换机的<code>Durability</code>参数为<strong>Durable</strong>即可</li><li>设置为<code>Durable</code>就是持久化模式，<code>Transient</code>就是临时模式</li></ul></li><li>队列持久化<ul><li>在控制台的Queues页面，添加队列时，同样可以配置队列的<code>Durability</code>参数</li><li>同样，设置为<code>Durable</code>就是持久化模式，<code>Transient</code>就是临时模式。</li><li>队列这里还有其他的参数，可以实现更多的功能</li></ul></li><li>消息持久化<ul><li>在控制台发送消息的时候，可以添加很多参数，而消息的持久化是要配置一个<code>properties</code>：</li><li>在<code>properties</code>中添加如下参数：<strong>delivery_mode&#x3D;2</strong> 即可实现消息持久化</li></ul></li></ul><p><strong>说明</strong>：在开启持久化机制以后，如果同时还开启了生产者确认，那么MQ会在消息持久化以后才发送ACK回执，进一步确保消息的可靠性。<br>不过出于性能考虑，为了减少IO次数，发送到MQ的消息并不是逐条持久化到数据库的，而是每隔一段时间批量持久化。一般间隔在100毫秒左右，这就会导致ACK有一定的延迟，因此建议生产者确认全部采用异步方式。</p><h2 id="2-2-LazyQueue惰性队列"><a href="#2-2-LazyQueue惰性队列" class="headerlink" title="2.2 LazyQueue惰性队列"></a>2.2 LazyQueue惰性队列</h2><p>在某些情况下，MQ会产生<strong>消息积压</strong>，导致内存占用达到预警上限，为了解决这个问题，从RabbitMQ的3.6.0版本开始，就增加了<strong>Lazy Queues</strong>的模式，也就是<strong>惰性队列</strong>。</p><p>惰性队列的特征如下：</p><ul><li>接收到消息后直接<strong>存入磁盘</strong>而非内存</li><li>消费者要消费消息时才会<strong>从磁盘中读取并加载到内存</strong>（也就是懒加载）</li><li>支持数<strong>百万条</strong>的消息存储</li></ul><p>而在3.12版本之后，<strong>LazyQueue已经成为所有队列的默认格式</strong>。因此官方推荐升级MQ为3.12版本或者所有队列都设置为LazyQueue模式。</p><h3 id="配置LazyQueue的三种方式"><a href="#配置LazyQueue的三种方式" class="headerlink" title="配置LazyQueue的三种方式"></a>配置LazyQueue的三种方式</h3><p><strong>（1）控制台添加参数方式</strong></p><p>只需在添加队列的时候，添加 <strong>x-queue-mod&#x3D;lazy</strong> 参数即可设置队列为Lazy模式：</p><p><strong>（2）代码配置Lazy模式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">lazyQueue</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> QueueBuilder</span><br><span class="line">            .durable(<span class="string">&quot;lazy.queue&quot;</span>)</span><br><span class="line">            .lazy() <span class="comment">// 开启Lazy模式 ，底层源码仍为第一种添加参数的形式</span></span><br><span class="line">            .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>（3）基于注解来声明队列并配置Lazy模式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queuesToDeclare = @Queue(</span></span><br><span class="line"><span class="meta">        name = &quot;lazy.queue&quot;,</span></span><br><span class="line"><span class="meta">        durable = &quot;true&quot;,</span></span><br><span class="line"><span class="meta">        arguments = @Argument(name = &quot;x-queue-mode&quot;, value = &quot;lazy&quot;)  // 其实也是使用参数形式</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenLazyQueue</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;接收到 lazy.queue的消息：&#123;&#125;&quot;</span>, msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-消费者的可靠性"><a href="#3-消费者的可靠性" class="headerlink" title="3. 消费者的可靠性"></a>3. 消费者的可靠性</h1><p>当RabbitMQ向消费者投递消息以后，需要知道消费者的处理状态如何。因为消息投递给消费者并不代表就一定被正确消费了，可能出现的故障有很多，比如：</p><ul><li>消息投递的过程中出现了网络故障</li><li>消费者接收到消息后突然宕机</li><li>消费者接收到消息后，因处理不当导致异常</li><li>…</li></ul><p>一旦发生上述情况，消息也会丢失。<strong>因此，RabbitMQ必须知道消费者的处理状态，一旦消息处理失败才能重新投递消息</strong>。</p><h2 id="3-1-消费者确认机制"><a href="#3-1-消费者确认机制" class="headerlink" title="3.1 消费者确认机制"></a>3.1 消费者确认机制</h2><p>为了确认消费者是否成功处理消息，RabbitMQ提供了<strong>消费者确认机制</strong>（<strong>Consumer Acknowledgement</strong>）。即：当消费者处理消息结束后，应该向RabbitMQ发送一个<strong>回执</strong>，告知RabbitMQ自己消息处理状态。回执有三种可选值：</p><ul><li><strong>ack</strong>：成功处理消息，RabbitMQ从队列中<strong>删除该消息</strong></li><li><strong>nack</strong>：消息处理失败，RabbitMQ<strong>需要再次投递消息</strong></li><li><strong>reject</strong>：消息处理失败并拒绝该消息，RabbitMQ从队列中<strong>删除该消息</strong></li></ul><p><strong>那么消息确认回执如何实现呢？</strong></p><p>由于消息回执的处理代码比较统一，因此S<strong>pringAMQP帮我们实现了消息确认回执</strong>。并允许我们通过配置文件设置ACK处理方式，有三种模式：</p><ul><li><code>**none**</code>：不处理。即消息投递给消费者后立刻ack，消息会立刻从MQ删除。非常不安全，不建议使用</li><li><code>**manual**</code>：手动模式。需要自己在业务代码中调用api，发送<code>ack</code>或<code>reject</code>，存在业务入侵，但更灵活</li><li><strong>auto：自动模式（推荐）</strong>。SpringAMQP利用AOP对我们的消息处理逻辑做了环绕增强，当业务正常执行时则自动返回<code>ack</code>.  当业务出现异常时，根据异常判断返回不同结果：<ul><li>如果是<strong>业务异常</strong>，会自动返回<code>nack</code>；</li><li>如果是<strong>消息处理或校验异常</strong>，自动返回<code>reject</code>;</li></ul></li></ul><p><strong>配置消费者确认机制</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">acknowledge-mode:</span> <span class="string">auto</span> <span class="comment"># 自动ack</span></span><br><span class="line"><span class="comment"># 当我们把配置改为 auto 时，消息处理失败后，会回到RabbitMQ，并重新投递到消费者。</span></span><br></pre></td></tr></table></figure><h2 id="3-2-失败重试机制"><a href="#3-2-失败重试机制" class="headerlink" title="3.2 失败重试机制"></a>3.2 失败重试机制</h2><p>如果消息发送到消费者后，总是执行出错，消息重新投递，但一直出错，MQ就会陷入循环导致系统压力增大。所以又提出了：</p><p><strong>消费者失败重试机制</strong>：在消费者出现异常时利用<strong>本地重试</strong>，而不是无限制的requeue到mq队列。</p><p>配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">retry:</span></span><br><span class="line">          <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 开启消费者失败重试</span></span><br><span class="line">          <span class="attr">initial-interval:</span> <span class="string">1000ms</span> <span class="comment"># 初识的失败等待时长为1秒</span></span><br><span class="line">          <span class="attr">multiplier:</span> <span class="number">1</span> <span class="comment"># 失败的等待时长倍数，下次等待时长 = multiplier * last-interval</span></span><br><span class="line">          <span class="attr">max-attempts:</span> <span class="number">3</span> <span class="comment"># 最大重试次数</span></span><br><span class="line">          <span class="attr">stateless:</span> <span class="literal">true</span> <span class="comment"># true无状态；false有状态。如果业务中包含事务，这里改为false</span></span><br></pre></td></tr></table></figure><p><strong>结论：</strong></p><ul><li><strong>开启本地重试时，消息处理过程中抛出异常，不会requeue到队列，而是在消费者本地重试</strong></li><li><strong>重试达到最大次数后，Spring会返回reject，消息会被丢弃</strong></li></ul><h2 id="3-3-失败处理策略"><a href="#3-3-失败处理策略" class="headerlink" title="3.3 失败处理策略"></a>3.3 失败处理策略</h2><p>如果业务对消息可靠性要求很高的话，那么上面的失败重试机制中消息被丢弃也是不能容忍的，那么就要有一个失败处理的策略</p><p>这个策略是由<strong>MessageRecovery</strong>接口来定义的，它有3个不同实现：</p><ul><li><code>RejectAndDontRequeueRecoverer</code>：重试耗尽后，直接<code>reject</code>，丢弃消息。默认就是这种方式 </li><li><code>ImmediateRequeueMessageRecoverer</code>：重试耗尽后，返回<code>nack</code>，消息重新入队 </li><li><strong>RepublishMessageRecoverer</strong>：重试耗尽后，将失败消息投递到指定的交换机<strong>（推荐）</strong></li></ul><p><strong>推荐最后一种方式，失败后将消息投递到一个指定的，专门存放异常消息的队列，后续由人工集中处理。</strong></p><p><strong>具体实现</strong>即在消费者模块正常创建一个交换机和队列并绑定，且加上消息转换器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty(name = &quot;spring.rabbitmq.listener.simple.retry.enabled&quot;, havingValue = &quot;true&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ErrorMessageConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">errorMessageExchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectExchange</span>(<span class="string">&quot;error.direct&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">errorQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;error.queue&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">errorBinding</span><span class="params">(Queue errorQueue, DirectExchange errorMessageExchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(errorQueue).to(errorMessageExchange).with(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MessageRecoverer <span class="title function_">republishMessageRecoverer</span><span class="params">(RabbitTemplate rabbitTemplate)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RepublishMessageRecoverer</span>(rabbitTemplate, <span class="string">&quot;error.direct&quot;</span>, <span class="string">&quot;error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，就可以定义一些方法来监听这个error队列，当出现重试也无法解决的错误时，就会调用这些方法来完成错误处理的业务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;error.queue&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenErrorQueue</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">    <span class="comment">// 这里完成error错误处理</span></span><br><span class="line">    <span class="comment">// 例如：给用户一个友好的界面、向开发人员发送邮件短信等通知错误、</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-4-业务幂等性的保障"><a href="#3-4-业务幂等性的保障" class="headerlink" title="3.4 业务幂等性的保障"></a>3.4 业务幂等性的保障</h2><p><strong>业务幂等性即指同一个业务，执行一次或多次对业务状态的影响是一致的</strong></p><p>数据的删除、查找往往是自带幂等的，而数据的更新往往都是非幂等的，如果重复执行可能造成不一样的后果</p><p>保证消息处理的幂等性。这里给出两种实现方案：</p><ul><li><strong>唯一消息ID</strong></li><li><strong>业务状态判断</strong></li></ul><h3 id="3-4-1-唯一消息ID"><a href="#3-4-1-唯一消息ID" class="headerlink" title="3.4.1 唯一消息ID"></a>3.4.1 唯一消息ID</h3><p>思路如下：</p><p>（1）每一条消息都生成一个唯一的id，与消息一起投递给消费者。</p><p>（2）消费者接收到消息后处理自己的业务，业务处理成功后将消息ID保存到数据库</p><p>（3）如果下次又收到相同消息，去数据库查询判断是否存在，存在则为重复消息放弃处理。</p><h3 id="3-4-2-消息幂等性的其他解决方案"><a href="#3-4-2-消息幂等性的其他解决方案" class="headerlink" title="3.4.2 消息幂等性的其他解决方案"></a>3.4.2 消息幂等性的其他解决方案</h3><p>其他解决方案，请参考我另一篇文章，专门给出了更多的保障业务幂等性的解决方案。</p><h2 id="3-5-兜底方案"><a href="#3-5-兜底方案" class="headerlink" title="3.5 兜底方案"></a>3.5 兜底方案</h2><p>虽然我们利用各种机制尽可能增加了消息的可靠性，但也不好说能保证消息100%的可靠。万一万一真的MQ通知失败该怎么办呢？</p><p><strong>兜底解决方案：</strong></p><pre><code>消费者利用**定时任务**定期**主动查询**，并利用查询得到的结果**完成后面的业务**</code></pre><p>至此，消息可靠性的问题就得到了完美解决！</p><h1 id="4-延迟消息"><a href="#4-延迟消息" class="headerlink" title="4. 延迟消息"></a>4. 延迟消息</h1><p>在RabbitMQ中实现延迟消息也有两种方案：</p><ul><li>死信交换机+TTL</li><li>延迟消息插件</li></ul><h2 id="4-1-死信交换机和延迟消息"><a href="#4-1-死信交换机和延迟消息" class="headerlink" title="4.1 死信交换机和延迟消息"></a>4.1 死信交换机和延迟消息</h2><h3 id="4-1-1-死信交换机"><a href="#4-1-1-死信交换机" class="headerlink" title="4.1.1 死信交换机"></a>4.1.1 死信交换机</h3><p>当一个队列中的消息满足下列情况之一时，可以成为死信（dead letter）：</p><ul><li>消费者使用<code>basic.reject</code>或 <code>basic.nack</code>声明消费失败，并且消息的<code>requeue</code>参数设置为false</li><li>消息是一个过期消息，超时无人消费</li><li>要投递的队列消息满了，无法投递</li></ul><p>如果一个队列中的消息已经成为死信，并且这个队列通过<strong>dead-letter-exchange</strong>属性<strong>指定了一个交换机</strong>，那么队列中的死信就会投递到这个交换机中，而这个交换机就称为<strong>死信交换机</strong>（Dead Letter Exchange）。而此时加入有队列与死信交换机绑定，则最终死信就会被投递到这个队列中。</p><p><strong>死信交换机有什么作用呢？</strong></p><ol><li>收集那些因处理失败而被拒绝的消息</li><li>收集那些因队列满了而被拒绝的消息</li><li>收集因TTL（有效期）到期的消息</li></ol><h3 id="4-1-2-延迟消息"><a href="#4-1-2-延迟消息" class="headerlink" title="4.1.2 延迟消息"></a>4.1.2 延迟消息</h3><p>发送的消息携带<strong>过期时间</strong>，当投递到ttl.queue时，由于没有消费者所以暂存，<strong>当到达过期时间就成为了死信</strong>。</p><p>死信被再次投递到<strong>死信交换机</strong><code>hmall.direct</code>，并沿用之前的RoutingKey，也就是<code>blue</code>，此时消息就被投递到了direct<strong>目标队列</strong>。</p><p>这时有消费者监听此队列的话，消息就得到了消费，即实现了<strong>延迟消息</strong>。</p><img src="/2023/12/20/MQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02%EF%BC%88%E8%BF%9B%E9%98%B6%EF%BC%89/image.png" class><p>** 注意：**<br>RabbitMQ的消息过期是基于追溯方式来实现的，也就是说当一个消息的TTL到期以后不一定会被移除或投递到死信交换机，而是在消息恰好处于队首时才会被处理。<br>当队列中消息堆积很多的时候，过期消息可能不会被按时处理，因此你设置的TTL时间不一定准确</p><h2 id="4-2-DelayExchange插件"><a href="#4-2-DelayExchange插件" class="headerlink" title="4.2 DelayExchange插件"></a>4.2 DelayExchange插件</h2><p>基于死信队列虽然可以实现延迟消息，但是太麻烦了。因此RabbitMQ社区提供了一个延迟消息插件来实现相同的效果。<br>官方文档说明：<br><a href="https://blog.rabbitmq.com/posts/2015/04/scheduling-messages-with-rabbitmq">Scheduling Messages with RabbitMQ | RabbitMQ - Blog</a></p><h3 id="4-2-1-下载"><a href="#4-2-1-下载" class="headerlink" title="4.2.1 下载"></a>4.2.1 下载</h3><p>插件下载地址：<br><a href="https://github.com/rabbitmq/rabbitmq-delayed-message-exchange">GitHub - rabbitmq&#x2F;rabbitmq-delayed-message-exchange: Delayed Messaging for RabbitMQ</a><br>由于我们安装的MQ是<code>3.8</code>版本，因此这里下载<code>3.8.17</code>版本：</p><h3 id="4-2-2-安装"><a href="#4-2-2-安装" class="headerlink" title="4.2.2 安装"></a>4.2.2 安装</h3><p>一开始在使用Docker启动RabbitMQ时，我们使用的命令是：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">run</span><span class="language-bash"> \</span></span><br><span class="line"><span class="language-bash"> -e RABBITMQ_DEFAULT_USER=itheima \</span></span><br><span class="line"><span class="language-bash"> -e RABBITMQ_DEFAULT_PASS=123321 \</span></span><br><span class="line"><span class="language-bash"> -v mq-plugins:/plugins \   <span class="comment"># 这里挂载了插件目录</span></span></span><br><span class="line"> --name mq \</span><br><span class="line"> --hostname mq \</span><br><span class="line"> -p <span class="number">15672</span>:<span class="number">15672</span> \     <span class="comment"># 15672是web控制台端口</span></span><br><span class="line"> -p <span class="number">5672</span>:<span class="number">5672</span> \       <span class="comment"># 5672是MQ的收发消息端口</span></span><br><span class="line"> --network hmall \    <span class="comment"># 这里配置网络名，可以使用命令先创建好网络 docker network creat &lt;网络&gt;</span></span><br><span class="line"> -d \</span><br><span class="line"> rabbitmq:<span class="number">3.8</span>-management</span><br></pre></td></tr></table></figure><p>我们在启动MQ时对插件目录进行了挂载，可以使用以下命令查看RabbitMQ的插件目录对应的数据卷。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">volume</span><span class="language-bash"> inspect mq-plugins</span></span><br></pre></td></tr></table></figure><p>在结果中找到”<strong>Mountpoint</strong>“: “&#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes&#x2F;mq-plugins&#x2F;_data”</p><p>通过<strong>Mountpoint</strong>属性拿到后面的<strong>插件挂载目录</strong>，可能与我的这里不一样，使用自己的插件路径，我们<strong>上传</strong>准备好的插件到该目录下。</p><p>然后属于以下命令<strong>安装插件</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it mq rabbitmq-plugins enable rabbitmq_delayed_message_exchange</span><br></pre></td></tr></table></figure><h3 id="4-2-3-代码声明延迟交换机"><a href="#4-2-3-代码声明延迟交换机" class="headerlink" title="4.2.3 代码声明延迟交换机"></a>4.2.3 代码声明延迟交换机</h3><p><strong>基于注解方式：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">        value = @Queue(name = &quot;delay.queue&quot;, durable = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">        exchange = @Exchange(name = &quot;delay.direct&quot;, delayed = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">        key = &quot;delay&quot;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenDelayMessage</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;接收到delay.queue的延迟消息：&#123;&#125;&quot;</span>, msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>基于<code>@Bean</code>的方式：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DelayExchangeConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DirectExchange <span class="title function_">delayExchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ExchangeBuilder</span><br><span class="line">                .directExchange(<span class="string">&quot;delay.direct&quot;</span>) <span class="comment">// 指定交换机类型和名称</span></span><br><span class="line">                .delayed() <span class="comment">// 设置delay的属性为true</span></span><br><span class="line">                .durable(<span class="literal">true</span>) <span class="comment">// 持久化</span></span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">delayedQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;delay.queue&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">delayQueueBinding</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(delayedQueue()).to(delayExchange()).with(<span class="string">&quot;delay&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-4-代码发送延迟消息"><a href="#4-2-4-代码发送延迟消息" class="headerlink" title="4.2.4 代码发送延迟消息"></a>4.2.4 代码发送延迟消息</h3><p>发送消息时，必须通过x-delay属性设定延迟时间：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RabbitTemplate rabbitTemplate；</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testPublisherDelayMessage</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.创建消息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;hello, delayed message&quot;</span>;</span><br><span class="line">    <span class="comment">// 2.发送消息，利用消息后置处理器添加消息头</span></span><br><span class="line">    rabbitTemplate.convertAndSend(<span class="string">&quot;delay.direct&quot;</span>, <span class="string">&quot;delay&quot;</span>, message, <span class="keyword">new</span> <span class="title class_">MessagePostProcessor</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Message <span class="title function_">postProcessMessage</span><span class="params">(Message message)</span> <span class="keyword">throws</span> AmqpException &#123;</span><br><span class="line">            <span class="comment">// 添加延迟消息属性</span></span><br><span class="line">            message.getMessageProperties().setDelay(<span class="number">5000</span>);</span><br><span class="line">            <span class="keyword">return</span> message;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong><br>延迟消息插件内部会维护一个本地数据库表，同时使用Elang Timers功能实现计时。如果消息的<strong>延迟时间设置较长，可能会导致堆积</strong>的延迟消息非常多，会带来<strong>较大的CPU开销</strong>，同时延迟消息的时间会存在误差。<br>因此，<strong>不建议设置延迟时间过长的延迟消息</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 消息队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MQ学习笔记1（基础）</title>
      <link href="/DoublePeach/myblog/2023/12/08/MQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/"/>
      <url>/DoublePeach/myblog/2023/12/08/MQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p><strong>本文对RabbiteMQ的学习做一个总结，希望能加深巩固我对MQ的运行机制和MQ的一些高级特性，以及消息队列的应用场景和对应的解决方案，为微服务应用开发打下坚实的基础！</strong></p><p>分为两篇文章，本篇为基础篇，介绍了MQ的机制和基本应用。进阶篇介绍了MQ的一些高级特性以及如何保证消息的可靠性和延迟消息的实现</p><h1 id="1-常见MQ对比"><a href="#1-常见MQ对比" class="headerlink" title="1.常见MQ对比"></a>1.常见MQ对比</h1><img src="/2023/12/08/MQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/a04a4838e3f59c0971e460b0ff9df593.png" class><h1 id="2-安装RabbitMQ"><a href="#2-安装RabbitMQ" class="headerlink" title="2.安装RabbitMQ"></a>2.安装RabbitMQ</h1><p>Docker一条命令安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">docker run \</span><br><span class="line"> -e RABBITMQ_DEFAULT_USER=itheima \</span><br><span class="line"> -e RABBITMQ_DEFAULT_PASS=123321 \</span><br><span class="line"> -v mq-plugins:/plugins \</span><br><span class="line"> --name mq \</span><br><span class="line"> --hostname mq \</span><br><span class="line"> -p 15672:15672 \     # 15672是web控制台端口</span><br><span class="line"> -p 5672:5672 \       # 5672是MQ的收发消息端口</span><br><span class="line"> --network hmall \    # 这里配置网络名，可以使用命令先创建好网络 docker network creat &lt;网络&gt;</span><br><span class="line"> -d \</span><br><span class="line"> rabbitmq:3.8-management</span><br></pre></td></tr></table></figure><h1 id="3-RabbitMQ架构图"><a href="#3-RabbitMQ架构图" class="headerlink" title="3.RabbitMQ架构图"></a>3.RabbitMQ架构图</h1><img src="/2023/12/08/MQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/ae25d857676b47e07d33d73614d806f0.png" class><h1 id="4-交换机类型"><a href="#4-交换机类型" class="headerlink" title="4.交换机类型"></a>4.交换机类型</h1><p><strong>Exchange（交换机）只负责转发消息，不具备存储消息的能力</strong>，因此如果没有任何队列与Exchange绑定，或者没有符合路由规则的队列，那么消息会丢失！以下是四种交换机类型：</p><ul><li><strong>Fanout</strong>：广播，将消息交给所有绑定到交换机的队列。</li><li><strong>Direct</strong>：订阅，基于RoutingKey（路由key）发送给订阅了消息的队列</li><li><strong>Topic</strong>：通配符订阅，与Direct类似，只不过RoutingKey可以使用通配符</li><li><strong>Headers</strong>：头匹配，基于MQ的消息头匹配，用的较少。</li></ul><h2 id="4-1-Direct交换机"><a href="#4-1-Direct交换机" class="headerlink" title="4.1 Direct交换机"></a>4.1 Direct交换机</h2><img src="/2023/12/08/MQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/f36223fd100ae244cce91d24a626e4c5.png" class><h3 id="Direct与Fanout交换机的差异"><a href="#Direct与Fanout交换机的差异" class="headerlink" title="Direct与Fanout交换机的差异"></a>Direct与Fanout交换机的差异</h3><p>描述下Direct交换机与Fanout交换机的差异？</p><ul><li>Fanout交换机将消息路由给每一个与之绑定的队列</li><li>Direct交换机根据RoutingKey判断路由给哪个队列</li><li>如果多个队列具有相同的RoutingKey，则与Fanout功能类似</li></ul><h2 id="4-2-Topic交换机"><a href="#4-2-Topic交换机" class="headerlink" title="4.2 Topic交换机"></a>4.2 Topic交换机</h2><img src="/2023/12/08/MQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/eeea5e33572eb1052dea4964f92871d8.png" class><h3 id="Direct交换机与Topic交换机的差异？"><a href="#Direct交换机与Topic交换机的差异？" class="headerlink" title="Direct交换机与Topic交换机的差异？"></a>Direct交换机与Topic交换机的差异？</h3><ul><li>Topic交换机接收的消息RoutingKey必须是多个单词，以 <code>**.**</code> 分割</li><li>Topic交换机与队列绑定时的bindingKey可以指定通配符</li><li><code>#</code>：代表0个或多个词</li><li>‘*’：代表1个词</li></ul><br><h1 id="5-RabbitMQ的使用"><a href="#5-RabbitMQ的使用" class="headerlink" title="5.RabbitMQ的使用"></a>5.RabbitMQ的使用</h1><p><strong>（1）引入SpringAMQP</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--消息发送--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>（2）配置MQ地址</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span> <span class="comment"># 你的主机IP</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span> <span class="comment"># 端口</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/hmall</span> <span class="comment"># 虚拟主机</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">hmall</span> <span class="comment"># 用户名</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123</span> <span class="comment"># 密码</span></span><br></pre></td></tr></table></figure><ul><li><p>创建队列 ： new Queue类</p></li><li><p>创建交换机 ： new Exchange类(接口)  –&gt; 子类有TopicExchange、FanoutExchange、DirectExchange等</p></li><li><p>绑定交换机和队列 ： 使用BindingBuilder来创建Binding对象来绑定交换机和队列</p></li></ul><h2 id="5-1-发布者-x2F-生产者模块"><a href="#5-1-发布者-x2F-生产者模块" class="headerlink" title="5.1 发布者&#x2F;生产者模块"></a>5.1 发布者&#x2F;生产者模块</h2><h3 id="（1）发布者和订阅者都要引入依赖"><a href="#（1）发布者和订阅者都要引入依赖" class="headerlink" title="（1）发布者和订阅者都要引入依赖"></a>（1）发布者和订阅者都要引入依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--消息发送--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="（2）调用API发送消息"><a href="#（2）调用API发送消息" class="headerlink" title="（2）调用API发送消息"></a>（2）调用API发送消息</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先注入RabbitTemplate对象</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后在方法中就可以调用API进行消息发送了</span></span><br><span class="line">rabbitTemplate.convertAndSend(exchangeName, <span class="string">&quot;RoutingKey&quot;</span>, message);</span><br></pre></td></tr></table></figure><h2 id="5-2-订阅者-x2F-消费者模块"><a href="#5-2-订阅者-x2F-消费者模块" class="headerlink" title="5.2 订阅者&#x2F;消费者模块"></a>5.2 订阅者&#x2F;消费者模块</h2><h3 id="5-2-1基于-Bean方式声明交换机和队列"><a href="#5-2-1基于-Bean方式声明交换机和队列" class="headerlink" title="5.2.1基于@Bean方式声明交换机和队列"></a>5.2.1基于@Bean方式声明交换机和队列</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FanoutConfig</span> &#123;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 声明交换机</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Fanout类型交换机，也可以是其他类型的交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> FanoutExchange <span class="title function_">fanoutExchange</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FanoutExchange</span>(<span class="string">&quot;hmall.fanout&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第1个队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">fanoutQueue1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;fanout.queue1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定队列和交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingQueue1</span><span class="params">(Queue fanoutQueue1, FanoutExchange fanoutExchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(fanoutQueue1).to(fanoutExchange);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第2个队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">fanoutQueue2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;fanout.queue2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定队列和交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">bindingQueue2</span><span class="params">(Queue fanoutQueue2, FanoutExchange fanoutExchange)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(fanoutQueue2).to(fanoutExchange);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-2基于注解方式声明交换机和队列"><a href="#5-2-2基于注解方式声明交换机和队列" class="headerlink" title="5.2.2基于注解方式声明交换机和队列"></a>5.2.2基于注解方式声明交换机和队列</h3><p><strong>使用Direct类型交换机和队列</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(name = &quot;direct.queue1&quot;),  // 队列声明</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(name = &quot;hmall.direct&quot;, type = ExchangeTypes.DIRECT), // 交换机声明</span></span><br><span class="line"><span class="meta">    key = &#123;&quot;red&quot;, &quot;blue&quot;&#125; // RoutingKey声明</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenDirectQueue1</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者1接收到direct.queue1的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用Topic类型交换机和队列</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(name = &quot;topic.queue1&quot;),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(name = &quot;hmall.topic&quot;, type = ExchangeTypes.TOPIC),</span></span><br><span class="line"><span class="meta">    key = &quot;china.#&quot;   // Topic交换机使用通配符指定Key</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenTopicQueue1</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者1接收到topic.queue1的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">    value = @Queue(name = &quot;topic.queue2&quot;),</span></span><br><span class="line"><span class="meta">    exchange = @Exchange(name = &quot;hmall.topic&quot;, type = ExchangeTypes.TOPIC),</span></span><br><span class="line"><span class="meta">    key = &quot;#.news&quot;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenTopicQueue2</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费者2接收到topic.queue2的消息：【&quot;</span> + msg + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="6-消息转换器-配置json消息转换器"><a href="#6-消息转换器-配置json消息转换器" class="headerlink" title="6. 消息转换器(配置json消息转换器)"></a>6. 消息转换器(配置json消息转换器)</h1><p>在MQ数据传输时，发送的消息序列化为字节发送给MQ，接收消息的时候，还会把字节反序列化为Java对象。</p><p>Spring默认采用的是<strong>JDK序列化</strong>方式，这种方式存在以下问题：</p><ul><li>数据体积过大</li><li>有安全漏洞</li><li>可读性差</li></ul><h2 id="（1）引入依赖"><a href="#（1）引入依赖" class="headerlink" title="（1）引入依赖"></a>（1）引入依赖</h2><p>使用JSON方式来做序列化和反序列化，<strong>在发布者和订阅者两个模块都引入依赖</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.dataformat<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-dataformat-xml<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>注意：如果项目中引入了<code>spring-boot-starter-web</code>依赖，则无需再次引入<code>Jackson</code>依赖。</strong></p><h2 id="（2）配置消息转换器"><a href="#（2）配置消息转换器" class="headerlink" title="（2）配置消息转换器"></a>（2）配置消息转换器</h2><p><strong>在发布者和订阅者两个模块的启动类都添加以下@Bean</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MessageConverter <span class="title function_">messageConverter</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 1.定义消息转换器</span></span><br><span class="line">    <span class="type">Jackson2JsonMessageConverter</span> <span class="variable">jackson2JsonMessageConverter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonMessageConverter</span>();</span><br><span class="line">    <span class="comment">// 2.配置自动创建消息id，用于识别不同消息，也可以在业务中基于ID判断是否是重复消息</span></span><br><span class="line">    jackson2JsonMessageConverter.setCreateMessageIds(<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">return</span> jackson2JsonMessageConverter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的消息转换器中添加的<strong>messageId</strong>可以便于我们将来做<strong>幂等性判断</strong>。</p><p><strong>注：发布者发送的什么数据类型的消息，订阅者就使用什么样的数据类型接收</strong></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 消息队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记录一次数据库的神秘报错</title>
      <link href="/DoublePeach/myblog/2023/11/15/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E7%A5%9E%E7%A7%98%E6%8A%A5%E9%94%99/"/>
      <url>/DoublePeach/myblog/2023/11/15/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E7%A5%9E%E7%A7%98%E6%8A%A5%E9%94%99/</url>
      
        <content type="html"><![CDATA[<p><strong>记录一次数据库的神秘报错</strong></p><p>运行yimu-smart时报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ERROR o.s.b.SpringApplication - [reportFailure,843] - Application run failed</span><br><span class="line">org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name &#x27;sysJobController&#x27;: Unsatisfied dependency expressed through field &#x27;jobService&#x27;; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name &#x27;sysJobServiceImpl&#x27;: Invocation of init method failed; nested exception is org.quartz.impl.jdbcjobstore.LockException: Failure obtaining db row lock: Table &#x27;yimu-smart.QRTZ_LOCKS&#x27; doesn&#x27;t exist [See nested exception: java.sql.SQLSyntaxErrorException: Table &#x27;yimu-smart.QRTZ_LOCKS&#x27; doesn&#x27;t exist]</span><br></pre></td></tr></table></figure><br><p>这个问题是说数据库中缺少QRTZ_LOCKS这个表，程序访问数据库时找不到这个表。</p><p>但是我在yml配置文件中配置本地数据库时却能正常运行起来</p><img src="/2023/11/15/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E7%A5%9E%E7%A7%98%E6%8A%A5%E9%94%99/f7227eb4c4c007516798c1726b12ee21.png" class><p>但是一换成上面的8.140.247.245服务器的数据库时就报那个错误，但是我查看了我本地和服务器上的数据库，结构和数据都是完全一样的，运行程序时却一个可以运行，一个报错。</p><p>追根求因：</p><p>经过一番DEBUG，最终发现，我的数据库中有qrtz_locks表，即QRTZ_LOCKS的小写，这才发觉有没有可能是数据库大小写识别的问题，我们正常安装mysql时它默认是大小写不敏感的，也就是说程序在查询数据库时大小写都可以，但是在云服务器上使用docker pull mysql:5.7 拉取下来的mysql，它默认是大小写敏感的，所以才导致了查询QRTZ_LOCKS表找不到的情况。</p><br><br><p>解决：</p><br><p>要关闭 MySQL 数据库的大小写敏感性，您可以按照以下步骤进行操作：</p><ol><li><p>编辑 MySQL 服务器的配置文件。在 Linux 系统上，默认的配置文件路径通常是 &#x2F;etc&#x2F;my.cnf 或 &#x2F;etc&#x2F;mysql&#x2F;my.cnf。在 Windows 系统上，默认的配置文件路径通常是 C:\Program Files\MySQL\MySQL Server X.X\my.ini。</p></li><li><p>打开配置文件，并在 [mysqld] 部分添加或修改以下行：</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lower_case_table_names=1</span><br></pre></td></tr></table></figure><p>将 lower_case_table_names 的值设置为 1。这个选项告诉 MySQL 将所有表名转换为小写。</p><ol start="3"><li>保存配置文件并重新启动 MySQL 服务器，以使更改生效。</li></ol><br><p><strong>注意：如果mysql是使用docker拉取的，则使用以下方式编辑mysql的配置文件：</strong></p><ol><li>确定正在运行的 MySQL 容器的名称或 ID。可以使用以下命令列出运行中的容器：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><ol start="2"><li><p>找到正在运行的 MySQL 容器，并复制其名称或 ID。</p><p>使用以下命令进入 MySQL 容器的 shell：</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it &lt;容器名称或ID&gt; bash</span><br></pre></td></tr></table></figure><ol start="3"><li>进入容器shell后默认是没有编辑器的，所以无法使用vi命令来编辑配置文件，这里下载nano作为编辑器</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install nano</span><br></pre></td></tr></table></figure><ol start="4"><li>然后进入编辑配置文件：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nano /etc/mysql/my.cnf</span><br></pre></td></tr></table></figure><ol start="5"><li>在编辑器中找到 [mysqld] 部分，并在其中添加或修改以下行：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lower_case_table_names=1</span><br></pre></td></tr></table></figure><ol start="6"><li><p>保存文件并退出编辑器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nano编辑器保存命令是：ctrl+O</span><br><span class="line">退出命令是：ctrl+X</span><br></pre></td></tr></table></figure></li><li><p>exit退出shell</p></li><li><p>重启 MySQL 容器，以使更改生效。可以使用以下命令重启容器：</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart &lt;容器名称或ID&gt;</span><br></pre></td></tr></table></figure><p>这样再访问云服务器上docker的数据库时就不会出现找不到表的报错了。</p><p>这个错误还是挺难发现的，特此记录一下，以帮助到后来被此bug折磨的人……</p>]]></content>
      
      
      <categories>
          
          <category> 分类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 标签 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NIO学习笔记分享</title>
      <link href="/DoublePeach/myblog/2023/07/09/NIO%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%88%86%E4%BA%AB/"/>
      <url>/DoublePeach/myblog/2023/07/09/NIO%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%88%86%E4%BA%AB/</url>
      
        <content type="html"><![CDATA[<p>花了三天的时间把网络编程中的NIO模型学习了，现在将我学习过程中的笔记和心得整理分享出来，希望能帮助到别人或者未来的自己！</p><h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><h2 id="1-网络编程IO模型介绍"><a href="#1-网络编程IO模型介绍" class="headerlink" title="1.网络编程IO模型介绍"></a>1.网络编程IO模型介绍</h2><h2 id="1-）Blocking-IO"><a href="#1-）Blocking-IO" class="headerlink" title="1 ）Blocking IO"></a>1 ）Blocking IO</h2><h4 id="Blocking-IO也称为BIO，即同步阻塞IO。Java的io包基于流模型实现，提供了File、"><a href="#Blocking-IO也称为BIO，即同步阻塞IO。Java的io包基于流模型实现，提供了File、" class="headerlink" title="Blocking IO也称为BIO，即同步阻塞IO。Java的io包基于流模型实现，提供了File、"></a>Blocking IO也称为BIO，即同步阻塞IO。Java的io包基于流模型实现，提供了File、</h4><h4 id="FileInputStream、FileOutputStream等输入输出流的功能。Java的io包下提供的流操"><a href="#FileInputStream、FileOutputStream等输入输出流的功能。Java的io包下提供的流操" class="headerlink" title="FileInputStream、FileOutputStream等输入输出流的功能。Java的io包下提供的流操"></a>FileInputStream、FileOutputStream等输入输出流的功能。Java的io包下提供的流操</h4><h4 id="作，交互方式是同步且阻塞的方式，在输入输出流的操作进行读、写动作完成之"><a href="#作，交互方式是同步且阻塞的方式，在输入输出流的操作进行读、写动作完成之" class="headerlink" title="作，交互方式是同步且阻塞的方式，在输入输出流的操作进行读、写动作完成之"></a>作，交互方式是同步且阻塞的方式，在输入输出流的操作进行读、写动作完成之</h4><h4 id="前，线程会一直阻塞。因此io包中对流的操作容易造成性能的瓶颈。"><a href="#前，线程会一直阻塞。因此io包中对流的操作容易造成性能的瓶颈。" class="headerlink" title="前，线程会一直阻塞。因此io包中对流的操作容易造成性能的瓶颈。"></a>前，线程会一直阻塞。因此io包中对流的操作容易造成性能的瓶颈。</h4><h4 id="同样的，在java-net包下提供的部分网络API，如Socket、ServerSocket、"><a href="#同样的，在java-net包下提供的部分网络API，如Socket、ServerSocket、" class="headerlink" title="同样的，在java.net包下提供的部分网络API，如Socket、ServerSocket、"></a>同样的，在java.net包下提供的部分网络API，如Socket、ServerSocket、</h4><h4 id="HttpURLConnection等，进行网络通信时，也用到了java-io包下的流操作，因此也属"><a href="#HttpURLConnection等，进行网络通信时，也用到了java-io包下的流操作，因此也属" class="headerlink" title="HttpURLConnection等，进行网络通信时，也用到了java.io包下的流操作，因此也属"></a>HttpURLConnection等，进行网络通信时，也用到了java.io包下的流操作，因此也属</h4><h4 id="于同步且阻塞的IO行为。"><a href="#于同步且阻塞的IO行为。" class="headerlink" title="于同步且阻塞的IO行为。"></a>于同步且阻塞的IO行为。</h4><h2 id="2-）Non-Blocking-IO"><a href="#2-）Non-Blocking-IO" class="headerlink" title="2 ）Non Blocking IO"></a>2 ）Non Blocking IO</h2><h4 id="Non-Blocking-IO也称为NIO，即同步非阻塞IO。Java1-4中引入了NIO框架，在"><a href="#Non-Blocking-IO也称为NIO，即同步非阻塞IO。Java1-4中引入了NIO框架，在" class="headerlink" title="Non Blocking IO也称为NIO，即同步非阻塞IO。Java1.4中引入了NIO框架，在"></a>Non Blocking IO也称为NIO，即同步非阻塞IO。Java1.4中引入了NIO框架，在</h4><h4 id="java-nio包中提供了Channel、Selector、Buffer等抽象类，可以快速构建多路复用的"><a href="#java-nio包中提供了Channel、Selector、Buffer等抽象类，可以快速构建多路复用的" class="headerlink" title="java.nio包中提供了Channel、Selector、Buffer等抽象类，可以快速构建多路复用的"></a>java.nio包中提供了Channel、Selector、Buffer等抽象类，可以快速构建多路复用的</h4><h4 id="IO程序，用于提供更接近操作系统底层的高性能数据操作方式。"><a href="#IO程序，用于提供更接近操作系统底层的高性能数据操作方式。" class="headerlink" title="IO程序，用于提供更接近操作系统底层的高性能数据操作方式。"></a>IO程序，用于提供更接近操作系统底层的高性能数据操作方式。</h4><h2 id="3-）Asynchronous-IO"><a href="#3-）Asynchronous-IO" class="headerlink" title="3 ）Asynchronous IO"></a>3 ）Asynchronous IO</h2><h4 id="Asynchronous-IO也称为AIO，即异步非阻塞IO。Java7提供了改进版的NIO，引入了"><a href="#Asynchronous-IO也称为AIO，即异步非阻塞IO。Java7提供了改进版的NIO，引入了" class="headerlink" title="Asynchronous IO也称为AIO，即异步非阻塞IO。Java7提供了改进版的NIO，引入了"></a>Asynchronous IO也称为AIO，即异步非阻塞IO。Java7提供了改进版的NIO，引入了</h4><h4 id="异步非阻塞的IO，由操作系统完成后回调通知服务端程序启动线程去处理。"><a href="#异步非阻塞的IO，由操作系统完成后回调通知服务端程序启动线程去处理。" class="headerlink" title="异步非阻塞的IO，由操作系统完成后回调通知服务端程序启动线程去处理。"></a>异步非阻塞的IO，由操作系统完成后回调通知服务端程序启动线程去处理。</h4><h2 id="2-BIO的实现逻辑"><a href="#2-BIO的实现逻辑" class="headerlink" title="2.BIO的实现逻辑"></a>2.BIO的实现逻辑</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">܉᲋රᙙJavaරᎸᴺ ̓ݩռلဳىJavaຝ຅຾̈́ӥ᫹ಅํ᧞ᑕդᎱ᧞կ݊ૡٍ ᦏದ๞ࢧ୭๜ᧆํጱᕍᶉѺ</span><br></pre></td></tr></table></figure><h2 id="2-BIO的实现逻辑-1"><a href="#2-BIO的实现逻辑-1" class="headerlink" title="2.BIO的实现逻辑"></a>2.BIO的实现逻辑</h2><h4 id="在BIO同步阻塞模型下，一个服务端的可以开启多个处理线程来处理客户端的连"><a href="#在BIO同步阻塞模型下，一个服务端的可以开启多个处理线程来处理客户端的连" class="headerlink" title="在BIO同步阻塞模型下，一个服务端的可以开启多个处理线程来处理客户端的连"></a>在BIO同步阻塞模型下，一个服务端的可以开启多个处理线程来处理客户端的连</h4><h4 id="接，但是一个处理线程只能对应一个客户端的连接。"><a href="#接，但是一个处理线程只能对应一个客户端的连接。" class="headerlink" title="接，但是一个处理线程只能对应一个客户端的连接。"></a>接，但是一个处理线程只能对应一个客户端的连接。</h4><h4 id="客户端的实现"><a href="#客户端的实现" class="headerlink" title="客户端的实现"></a>客户端的实现</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">package com.qf.io.bio;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line">import java.io.OutputStream;</span><br><span class="line">import java.net.Socket;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 客户端</span><br><span class="line">* @author htt</span><br><span class="line">* doublepeach</span><br><span class="line">*/</span><br><span class="line">public class SocketClient &#123;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws IOException &#123;</span><br></pre></td></tr></table></figure><h5 id><a href="#" class="headerlink" title></a></h5><h4 id="单线程服务端的实现"><a href="#单线程服务端的实现" class="headerlink" title="单线程服务端的实现"></a>单线程服务端的实现</h4><h5 id="x2F-x2F-连接服务端"><a href="#x2F-x2F-连接服务端" class="headerlink" title="&#x2F;&#x2F;连接服务端"></a>&#x2F;&#x2F;连接服务端</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Socket socket = new Socket(&quot;localhost&quot;, 9090 );</span><br><span class="line">//发送数据</span><br><span class="line">OutputStream outputStream = socket.getOutputStream();</span><br><span class="line">outputStream.write(&quot;hello bio&quot;.getBytes());</span><br><span class="line">outputStream.flush();</span><br><span class="line">//接收服务端返回的数据</span><br><span class="line">InputStream inputStream = socket.getInputStream();</span><br><span class="line">byte[] bytes = new byte[ 1024 ];</span><br><span class="line">//阻塞等待服务端返回数据</span><br><span class="line">int len = inputStream.read(bytes);</span><br><span class="line">System.out.println(&quot;接收到服务端返回的数据：&quot;+new</span><br><span class="line">String(bytes, 0 ,len));</span><br><span class="line">//关闭连接</span><br><span class="line">socket.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="-1"><a href="#-1" class="headerlink" title></a></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">package com.qf.io.bio;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line">import java.net.ServerSocket;</span><br><span class="line">import java.net.Socket;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 单线程的服务端</span><br><span class="line">* @author htt</span><br><span class="line">* doublepeach</span><br><span class="line">*/</span><br><span class="line">public class SocketServerSingleThread &#123;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws IOException &#123;</span><br><span class="line">ServerSocket serverSocket = new ServerSocket( 9090 );</span><br></pre></td></tr></table></figure><h5 id="-2"><a href="#-2" class="headerlink" title></a></h5><h4 id="多线程服务端的实现"><a href="#多线程服务端的实现" class="headerlink" title="多线程服务端的实现"></a>多线程服务端的实现</h4><h4 id="为了解决单线程服务端的同步阻塞问题，BIO模型下可以让服务端使用多线程来同"><a href="#为了解决单线程服务端的同步阻塞问题，BIO模型下可以让服务端使用多线程来同" class="headerlink" title="为了解决单线程服务端的同步阻塞问题，BIO模型下可以让服务端使用多线程来同"></a>为了解决单线程服务端的同步阻塞问题，BIO模型下可以让服务端使用多线程来同</h4><h4 id="时处理多个客户端的请求。"><a href="#时处理多个客户端的请求。" class="headerlink" title="时处理多个客户端的请求。"></a>时处理多个客户端的请求。</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">while(true)&#123;</span><br><span class="line">System.out.println(&quot;等待客户端的连接&quot;);</span><br><span class="line">//阻塞等待</span><br><span class="line">Socket socket = serverSocket.accept();</span><br><span class="line">System.out.println(&quot;已有客户端连接&quot;);</span><br><span class="line">//开始处理</span><br><span class="line">InputStream is = socket.getInputStream();</span><br><span class="line">byte[] bytes = new byte[ 1024 ];</span><br><span class="line">//阻塞等待客户端发送数据</span><br><span class="line">int len = is.read(bytes);</span><br><span class="line">System.out.println(&quot;收到客户端的数据：&quot;+new</span><br><span class="line">String(bytes, 0 ,len));</span><br><span class="line">socket.getOutputStream().write(&quot;success&quot;.getBytes());</span><br><span class="line">socket.getOutputStream().flush();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">package com.qf.io.bio;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line">import java.net.ServerSocket;</span><br><span class="line">import java.net.Socket;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 单线程的服务端</span><br><span class="line">* @author htt</span><br><span class="line">* doublepeach</span><br><span class="line">*/</span><br><span class="line">public class SocketServerMultipleThread &#123;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws IOException &#123;</span><br></pre></td></tr></table></figure><h2 id="3-BIO的局限"><a href="#3-BIO的局限" class="headerlink" title="3.BIO的局限"></a>3.BIO的局限</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ServerSocket serverSocket = new ServerSocket( 9090 );</span><br><span class="line">while(true)&#123;</span><br><span class="line">System.out.println(&quot;等待客户端的连接&quot;);</span><br><span class="line">//阻塞等待</span><br><span class="line">Socket socket = serverSocket.accept();</span><br><span class="line">System.out.println(&quot;已有客户端连接&quot;);</span><br><span class="line">//开始处理</span><br><span class="line">new Thread(new Runnable() &#123;</span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">try &#123;</span><br><span class="line">handle(socket);</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;).start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private static void handle(Socket socket) throws IOException &#123;</span><br><span class="line">InputStream is = socket.getInputStream();</span><br><span class="line">byte[] bytes = new byte[ 1024 ];</span><br><span class="line">//阻塞等待客户端发送数据</span><br><span class="line">int len = is.read(bytes);</span><br><span class="line">System.out.println(&quot;收到客户端的数据：&quot;+new</span><br><span class="line">String(bytes, 0 ,len));</span><br><span class="line">socket.getOutputStream().write(&quot;success&quot;.getBytes());</span><br><span class="line">socket.getOutputStream().flush();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="在上面的例子中可以看出，IO代码里Read操作是阻塞操作，如果连接不做数据读写"><a href="#在上面的例子中可以看出，IO代码里Read操作是阻塞操作，如果连接不做数据读写" class="headerlink" title="在上面的例子中可以看出，IO代码里Read操作是阻塞操作，如果连接不做数据读写"></a>在上面的例子中可以看出，IO代码里Read操作是阻塞操作，如果连接不做数据读写</h4><h4 id="操作，会导致线程阻塞，浪费线程资源。"><a href="#操作，会导致线程阻塞，浪费线程资源。" class="headerlink" title="操作，会导致线程阻塞，浪费线程资源。"></a>操作，会导致线程阻塞，浪费线程资源。</h4><h4 id="除此之外，如果客户端请求过多，将会导致服务端不断创建出新的线程，对服务器"><a href="#除此之外，如果客户端请求过多，将会导致服务端不断创建出新的线程，对服务器" class="headerlink" title="除此之外，如果客户端请求过多，将会导致服务端不断创建出新的线程，对服务器"></a>除此之外，如果客户端请求过多，将会导致服务端不断创建出新的线程，对服务器</h4><h4 id="造成过大压力。"><a href="#造成过大压力。" class="headerlink" title="造成过大压力。"></a>造成过大压力。</h4><h2 id="4-BIO的应用场景"><a href="#4-BIO的应用场景" class="headerlink" title="4.BIO的应用场景"></a>4.BIO的应用场景</h2><h4 id="BIO方式的使用和维护相对比较简单，适用于较小且固定的应用框架。"><a href="#BIO方式的使用和维护相对比较简单，适用于较小且固定的应用框架。" class="headerlink" title="BIO方式的使用和维护相对比较简单，适用于较小且固定的应用框架。"></a>BIO方式的使用和维护相对比较简单，适用于较小且固定的应用框架。</h4><h1 id="二、NIO快速开始"><a href="#二、NIO快速开始" class="headerlink" title="二、NIO快速开始"></a>二、NIO快速开始</h1><h2 id="1-NIO概述"><a href="#1-NIO概述" class="headerlink" title="1.NIO概述"></a>1.NIO概述</h2><h4 id="NIO（Non-Blocking-IO）是同步非阻塞的IO，服务器可以使用一个线程来处理多个"><a href="#NIO（Non-Blocking-IO）是同步非阻塞的IO，服务器可以使用一个线程来处理多个" class="headerlink" title="NIO（Non Blocking IO）是同步非阻塞的IO，服务器可以使用一个线程来处理多个"></a>NIO（Non Blocking IO）是同步非阻塞的IO，服务器可以使用一个线程来处理多个</h4><h4 id="客户端请求，客户端发送的请求会注册到多路复用器Selector上，由多路复用器"><a href="#客户端请求，客户端发送的请求会注册到多路复用器Selector上，由多路复用器" class="headerlink" title="客户端请求，客户端发送的请求会注册到多路复用器Selector上，由多路复用器"></a>客户端请求，客户端发送的请求会注册到多路复用器Selector上，由多路复用器</h4><h4 id="Selector轮询各客户端的请求并进行处理。"><a href="#Selector轮询各客户端的请求并进行处理。" class="headerlink" title="Selector轮询各客户端的请求并进行处理。"></a>Selector轮询各客户端的请求并进行处理。</h4><h2 id="2-NIO线程模型"><a href="#2-NIO线程模型" class="headerlink" title="2.NIO线程模型"></a>2.NIO线程模型</h2><h4 id="NIO包含三大组件："><a href="#NIO包含三大组件：" class="headerlink" title="NIO包含三大组件："></a>NIO包含三大组件：</h4><h4 id="Channel通道：每个通道对应一个buffer缓冲区"><a href="#Channel通道：每个通道对应一个buffer缓冲区" class="headerlink" title="Channel通道：每个通道对应一个buffer缓冲区"></a>Channel通道：每个通道对应一个buffer缓冲区</h4><h4 id="Buffer缓冲区：buffer底层是数组，类似于蓄水池，channel就是水管"><a href="#Buffer缓冲区：buffer底层是数组，类似于蓄水池，channel就是水管" class="headerlink" title="Buffer缓冲区：buffer底层是数组，类似于蓄水池，channel就是水管"></a>Buffer缓冲区：buffer底层是数组，类似于蓄水池，channel就是水管</h4><h4 id="Selector选择器：selector对应一个或多个线程。channel会注册到selector上，由"><a href="#Selector选择器：selector对应一个或多个线程。channel会注册到selector上，由" class="headerlink" title="Selector选择器：selector对应一个或多个线程。channel会注册到selector上，由"></a>Selector选择器：selector对应一个或多个线程。channel会注册到selector上，由</h4><h4 id="selector根据channel读写事件的发生交给某个空闲线程来执行。"><a href="#selector根据channel读写事件的发生交给某个空闲线程来执行。" class="headerlink" title="selector根据channel读写事件的发生交给某个空闲线程来执行。"></a>selector根据channel读写事件的发生交给某个空闲线程来执行。</h4><h4 id="Buffer和Channel都是既可读也可写。"><a href="#Buffer和Channel都是既可读也可写。" class="headerlink" title="Buffer和Channel都是既可读也可写。"></a>Buffer和Channel都是既可读也可写。</h4><h2 id="3-NIO初体验"><a href="#3-NIO初体验" class="headerlink" title="3.NIO初体验"></a>3.NIO初体验</h2><h4 id="服务端程序"><a href="#服务端程序" class="headerlink" title="服务端程序"></a>服务端程序</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">package com.qf.io.nio;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line">import java.net.InetSocketAddress;</span><br><span class="line">import java.nio.ByteBuffer;</span><br><span class="line">import java.nio.channels.*;</span><br><span class="line">import java.nio.charset.StandardCharsets;</span><br><span class="line">import java.util.Iterator;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* NIO服务端</span><br><span class="line">* @author htt</span><br><span class="line">* doublepeach</span><br><span class="line">*/</span><br><span class="line">public class NIOServer &#123;</span><br><span class="line">public static void main(String[] args) throws IOException &#123;</span><br><span class="line">//创建服务端Socket通道，ServerSocketChannel</span><br><span class="line">ServerSocketChannel ssc = ServerSocketChannel.open();</span><br><span class="line">//设置为非阻塞方式</span><br><span class="line">ssc.configureBlocking(false);</span><br><span class="line">//设置端口号为 9090</span><br><span class="line">ssc.socket().bind(new InetSocketAddress( 9090 ));</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//创建Selector多路复用器</span><br><span class="line">Selector selector = Selector.open();</span><br><span class="line">//把ServerSocketChannel注册到Selector上，并且监听客户端的连接事</span><br><span class="line">件操作</span><br><span class="line">ssc.register(selector, SelectionKey.OP_ACCEPT);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">while(true)&#123;</span><br><span class="line">System.out.println(&quot;等待事件发生&quot;);</span><br><span class="line">//轮询监听所有注册到selector上的channel的SelectionKey，此方</span><br><span class="line">法是阻塞的</span><br><span class="line">int select = selector.select();</span><br><span class="line">System.out.println(&quot;某个事件发生了&quot;);</span><br><span class="line">//获得所有发生事件的channel的key，遍历key的集合并处理每一个</span><br><span class="line">key的channel</span><br><span class="line">Iterator&lt;SelectionKey&gt; iterator =</span><br><span class="line">selector.selectedKeys().iterator();</span><br><span class="line">while(iterator.hasNext())&#123;</span><br><span class="line">SelectionKey key = iterator.next();</span><br><span class="line">handle(key);</span><br><span class="line">//删除本次处理的key，防止重复处理</span><br><span class="line">iterator.remove();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private static void handle(SelectionKey key) throws</span><br><span class="line">IOException &#123;</span><br><span class="line">//判断channel发生的是什么事件</span><br><span class="line">if(key.isAcceptable())&#123;</span><br><span class="line">System.out.println(&quot;有客户端连接了&quot;);</span><br><span class="line">//应为服务端在监听客户端的连接，所有获得ServerSocketChannel</span><br><span class="line">ServerSocketChannel ssc = (ServerSocketChannel)</span><br><span class="line">key.channel();</span><br><span class="line">//处理连接请求，建立SocketChannel。该方法是阻塞的，但该阻塞是</span><br><span class="line">在连接事件发生后⻢上执行的，相当于是非阻塞</span><br><span class="line">//且接收完后不需要阻塞等待客户端的读写操作</span><br></pre></td></tr></table></figure><h4 id="客户端程序"><a href="#客户端程序" class="headerlink" title="客户端程序"></a>客户端程序</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">SocketChannel sc = ssc.accept();</span><br><span class="line">//设置成非阻塞</span><br><span class="line">sc.configureBlocking(false);</span><br><span class="line">//注册读事件到Selector上，当读事件发生时（针对于服务端），触发</span><br><span class="line">事件</span><br><span class="line">sc.register(key.selector(),SelectionKey.OP_READ);</span><br><span class="line">&#125;else if(key.isReadable())&#123;</span><br><span class="line">System.out.println(&quot;有客户端向服务端写数据&quot;);</span><br><span class="line">//获得客户端和服务端之间的channel通道</span><br><span class="line">SocketChannel sc = (SocketChannel) key.channel();</span><br><span class="line">//创建Buffer</span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate( 1024 );</span><br><span class="line">//把数据读到buffer中。NIO非阻塞体现在此，read方法本身不会阻</span><br><span class="line">塞，且当read方法发生时一定是客户端做了发送数据的事情</span><br><span class="line">int len = sc.read(buffer);</span><br><span class="line">if(len!=- 1 )&#123;</span><br><span class="line">System.out.println(&quot;读到客户端发送的数据：&quot;+new</span><br><span class="line">String(buffer.array(), 0 ,len));</span><br><span class="line">&#125;</span><br><span class="line">//服务端返回数据给客户端</span><br><span class="line">ByteBuffer bufferToWrite = ByteBuffer.wrap(&quot;hello</span><br><span class="line">nio&quot;.getBytes());</span><br><span class="line">sc.write(bufferToWrite);</span><br><span class="line">//监听下一次事件，读或写</span><br><span class="line">key.interestOps(SelectionKey.OP_READ |</span><br><span class="line">SelectionKey.OP_WRITE);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">package com.qf.io.nio;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line">import java.net.InetSocketAddress;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import java.nio.ByteBuffer;</span><br><span class="line">import java.nio.channels.SelectionKey;</span><br><span class="line">import java.nio.channels.Selector;</span><br><span class="line">import java.nio.channels.SocketChannel;</span><br><span class="line">import java.util.Iterator;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* NIO客户端</span><br><span class="line">* @author htt</span><br><span class="line">* doublepeach</span><br><span class="line">*/</span><br><span class="line">public class NIOClient &#123;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws IOException &#123;</span><br><span class="line">//获得Channel通道</span><br><span class="line">SocketChannel channel = SocketChannel.open();</span><br><span class="line">//设置成非阻塞</span><br><span class="line">channel.configureBlocking(false);</span><br><span class="line">//获得多路复用器Selector</span><br><span class="line">Selector selector = Selector.open();</span><br><span class="line">//客户端连接服务器，需要在监听方法中调用channel的finishConnect()</span><br><span class="line">才能完成连接</span><br><span class="line">channel.connect(new InetSocketAddress(&quot;127.0.0.1&quot;, 9090 ));</span><br><span class="line">//将channel注册到Selector上，并且监听连接事件</span><br><span class="line">channel.register(selector, SelectionKey.OP_CONNECT);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//轮询访问Selector</span><br><span class="line">while(true)&#123;</span><br><span class="line">//阻塞等待，实际上selector只对应着客户端这一个channel</span><br><span class="line">selector.select();</span><br><span class="line">Iterator&lt;SelectionKey&gt; iterator =</span><br><span class="line">selector.selectedKeys().iterator();</span><br><span class="line">//遍历所有的事件</span><br><span class="line">while(iterator.hasNext())&#123;</span><br><span class="line">SelectionKey key = iterator.next();</span><br><span class="line">if(key.isConnectable())&#123;</span><br><span class="line">//如果是连接</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SocketChannel socketChannel = (SocketChannel)</span><br><span class="line">key.channel();</span><br><span class="line">//如果是正在连接，则完成连接</span><br><span class="line">if(socketChannel.isConnectionPending())&#123;</span><br><span class="line">socketChannel.finishConnect();</span><br><span class="line">//设置成非阻塞</span><br><span class="line">socketChannel.configureBlocking(false);</span><br><span class="line">//给服务端发送消息</span><br><span class="line">ByteBuffer buffer = ByteBuffer.wrap(&quot;hello</span><br><span class="line">server&quot;.getBytes());</span><br><span class="line">//缓存区中的数据写到通道里</span><br><span class="line">socketChannel.write(buffer);</span><br><span class="line">//监听读事件，可以获取服务器返回的数据</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">socketChannel.register(selector,SelectionKey.OP_READ);</span><br><span class="line">&#125;</span><br><span class="line">&#125;else if(key.isReadable())&#123;</span><br><span class="line">//读服务端返回的数据</span><br><span class="line">SocketChannel socketChannel = (SocketChannel)</span><br><span class="line">key.channel();</span><br><span class="line">//创建缓冲区</span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate( 1024 );</span><br><span class="line">//读缓冲区中的数据</span><br><span class="line">int len = channel.read(buffer);</span><br><span class="line">if(len!=- 1 )&#123;</span><br><span class="line">System.out.println(&quot;服务端返回的数据：&quot;+new</span><br><span class="line">String(buffer.array(), 0 ,len));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br><span class="line">//删除本次处理的key，防止重复处理</span><br><span class="line">iterator.remove();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="通信逻辑"><a href="#通信逻辑" class="headerlink" title="通信逻辑"></a>通信逻辑</h4><h1 id="三、NIO-Channel详解"><a href="#三、NIO-Channel详解" class="headerlink" title="三、NIO-Channel详解"></a>三、NIO-Channel详解</h1><h2 id="1-Channel概述"><a href="#1-Channel概述" class="headerlink" title="1.Channel概述"></a>1.Channel概述</h2><h4 id="Channel即通道，表示打开IO设备的连接，比如打开到文件、Socket套接字的连接。"><a href="#Channel即通道，表示打开IO设备的连接，比如打开到文件、Socket套接字的连接。" class="headerlink" title="Channel即通道，表示打开IO设备的连接，比如打开到文件、Socket套接字的连接。"></a>Channel即通道，表示打开IO设备的连接，比如打开到文件、Socket套接字的连接。</h4><h4 id="在使用NIO时，必须要获取用于连接IO设备的通道以及用于容纳数据的缓冲区。通"><a href="#在使用NIO时，必须要获取用于连接IO设备的通道以及用于容纳数据的缓冲区。通" class="headerlink" title="在使用NIO时，必须要获取用于连接IO设备的通道以及用于容纳数据的缓冲区。通"></a>在使用NIO时，必须要获取用于连接IO设备的通道以及用于容纳数据的缓冲区。通</h4><h4 id="过操作缓冲区，实现对数据的处理。也就是说数据是保存在buffer缓冲区中的，需"><a href="#过操作缓冲区，实现对数据的处理。也就是说数据是保存在buffer缓冲区中的，需" class="headerlink" title="过操作缓冲区，实现对数据的处理。也就是说数据是保存在buffer缓冲区中的，需"></a>过操作缓冲区，实现对数据的处理。也就是说数据是保存在buffer缓冲区中的，需</h4><h4 id="要通过Channel来操作缓冲区中的数据。"><a href="#要通过Channel来操作缓冲区中的数据。" class="headerlink" title="要通过Channel来操作缓冲区中的数据。"></a>要通过Channel来操作缓冲区中的数据。</h4><h4 id="Channel相比IO流中的Stream更加高效，可以异步双向传输。"><a href="#Channel相比IO流中的Stream更加高效，可以异步双向传输。" class="headerlink" title="Channel相比IO流中的Stream更加高效，可以异步双向传输。"></a>Channel相比IO流中的Stream更加高效，可以异步双向传输。</h4><h4 id="Channel的主要实现类有以下几个："><a href="#Channel的主要实现类有以下几个：" class="headerlink" title="Channel的主要实现类有以下几个："></a>Channel的主要实现类有以下几个：</h4><h4 id="FileChannel：读写文件的通道"><a href="#FileChannel：读写文件的通道" class="headerlink" title="FileChannel：读写文件的通道"></a>FileChannel：读写文件的通道</h4><h4 id="SocketChannel：读写TCP网络数据的通道"><a href="#SocketChannel：读写TCP网络数据的通道" class="headerlink" title="SocketChannel：读写TCP网络数据的通道"></a>SocketChannel：读写TCP网络数据的通道</h4><h4 id="ServerSocketChannel：像web服务器一样，监听新进来的TCP连接，为连接创建"><a href="#ServerSocketChannel：像web服务器一样，监听新进来的TCP连接，为连接创建" class="headerlink" title="ServerSocketChannel：像web服务器一样，监听新进来的TCP连接，为连接创建"></a>ServerSocketChannel：像web服务器一样，监听新进来的TCP连接，为连接创建</h4><h4 id="SocketChannel"><a href="#SocketChannel" class="headerlink" title="SocketChannel"></a>SocketChannel</h4><h4 id="DatagramChannel：读写UDP网络数据的通道"><a href="#DatagramChannel：读写UDP网络数据的通道" class="headerlink" title="DatagramChannel：读写UDP网络数据的通道"></a>DatagramChannel：读写UDP网络数据的通道</h4><h2 id="2-FileChannel详解"><a href="#2-FileChannel详解" class="headerlink" title="2.FileChannel详解"></a>2.FileChannel详解</h2><h3 id="FileChannel介绍"><a href="#FileChannel介绍" class="headerlink" title="FileChannel介绍"></a>FileChannel介绍</h3><h4 id="用于读取、写入、映射和操作文件的通道。"><a href="#用于读取、写入、映射和操作文件的通道。" class="headerlink" title="用于读取、写入、映射和操作文件的通道。"></a>用于读取、写入、映射和操作文件的通道。</h4><h4 id="文件通道是连接到文件的可搜索字节通道。它在其文件中有一个当前位置，可以查"><a href="#文件通道是连接到文件的可搜索字节通道。它在其文件中有一个当前位置，可以查" class="headerlink" title="文件通道是连接到文件的可搜索字节通道。它在其文件中有一个当前位置，可以查"></a>文件通道是连接到文件的可搜索字节通道。它在其文件中有一个当前位置，可以查</h4><h4 id="询和修改。文件本身包含可变⻓度的字节序列，可以读取和写入，并且可以查询其"><a href="#询和修改。文件本身包含可变⻓度的字节序列，可以读取和写入，并且可以查询其" class="headerlink" title="询和修改。文件本身包含可变⻓度的字节序列，可以读取和写入，并且可以查询其"></a>询和修改。文件本身包含可变⻓度的字节序列，可以读取和写入，并且可以查询其</h4><h4 id="当前大小。当写入的字节超过其当前大小时，文件的大小增加；文件被截断时，其"><a href="#当前大小。当写入的字节超过其当前大小时，文件的大小增加；文件被截断时，其" class="headerlink" title="当前大小。当写入的字节超过其当前大小时，文件的大小增加；文件被截断时，其"></a>当前大小。当写入的字节超过其当前大小时，文件的大小增加；文件被截断时，其</h4><h4 id="大小会减小。文件还可能具有一些相关联的元数据，如访问权限、内容类型和上次"><a href="#大小会减小。文件还可能具有一些相关联的元数据，如访问权限、内容类型和上次" class="headerlink" title="大小会减小。文件还可能具有一些相关联的元数据，如访问权限、内容类型和上次"></a>大小会减小。文件还可能具有一些相关联的元数据，如访问权限、内容类型和上次</h4><h4 id="修改时间；此类不定义元数据访问的方法。"><a href="#修改时间；此类不定义元数据访问的方法。" class="headerlink" title="修改时间；此类不定义元数据访问的方法。"></a>修改时间；此类不定义元数据访问的方法。</h4><h4 id="除了熟悉的字节通道读、写和关闭操作外，此类还定义了以下文件特定操作："><a href="#除了熟悉的字节通道读、写和关闭操作外，此类还定义了以下文件特定操作：" class="headerlink" title="除了熟悉的字节通道读、写和关闭操作外，此类还定义了以下文件特定操作："></a>除了熟悉的字节通道读、写和关闭操作外，此类还定义了以下文件特定操作：</h4><h4 id="字节可以以不影响通道当前位置的方式在文件中的绝对位置读取或写入。"><a href="#字节可以以不影响通道当前位置的方式在文件中的绝对位置读取或写入。" class="headerlink" title="字节可以以不影响通道当前位置的方式在文件中的绝对位置读取或写入。"></a>字节可以以不影响通道当前位置的方式在文件中的绝对位置读取或写入。</h4><h4 id="文件的区域可以直接映射到存储器中；对于大型文件，这通常比调用通常的读"><a href="#文件的区域可以直接映射到存储器中；对于大型文件，这通常比调用通常的读" class="headerlink" title="文件的区域可以直接映射到存储器中；对于大型文件，这通常比调用通常的读"></a>文件的区域可以直接映射到存储器中；对于大型文件，这通常比调用通常的读</h4><h4 id="或写方法更有效。"><a href="#或写方法更有效。" class="headerlink" title="或写方法更有效。"></a>或写方法更有效。</h4><h4 id="对文件进行的更新可能会被强制输出到底层存储设备，以确保在系统崩溃时数"><a href="#对文件进行的更新可能会被强制输出到底层存储设备，以确保在系统崩溃时数" class="headerlink" title="对文件进行的更新可能会被强制输出到底层存储设备，以确保在系统崩溃时数"></a>对文件进行的更新可能会被强制输出到底层存储设备，以确保在系统崩溃时数</h4><h4 id="据不会丢失。"><a href="#据不会丢失。" class="headerlink" title="据不会丢失。"></a>据不会丢失。</h4><h4 id="字节可以从一个文件传输到另一个通道，反之亦然，许多操作系统都可以将其"><a href="#字节可以从一个文件传输到另一个通道，反之亦然，许多操作系统都可以将其" class="headerlink" title="字节可以从一个文件传输到另一个通道，反之亦然，许多操作系统都可以将其"></a>字节可以从一个文件传输到另一个通道，反之亦然，许多操作系统都可以将其</h4><h4 id="优化为直接从文件系统缓存进行非常快速的传输。"><a href="#优化为直接从文件系统缓存进行非常快速的传输。" class="headerlink" title="优化为直接从文件系统缓存进行非常快速的传输。"></a>优化为直接从文件系统缓存进行非常快速的传输。</h4><h4 id="文件的一个区域可以被锁定以防止其他程序访问。"><a href="#文件的一个区域可以被锁定以防止其他程序访问。" class="headerlink" title="文件的一个区域可以被锁定以防止其他程序访问。"></a>文件的一个区域可以被锁定以防止其他程序访问。</h4><h4 id="多个并发线程使用文件通道是安全的。根据通道接口的指定，可以随时调用close方"><a href="#多个并发线程使用文件通道是安全的。根据通道接口的指定，可以随时调用close方" class="headerlink" title="多个并发线程使用文件通道是安全的。根据通道接口的指定，可以随时调用close方"></a>多个并发线程使用文件通道是安全的。根据通道接口的指定，可以随时调用close方</h4><h4 id="法。在任何给定时间，只有一个涉及通道位置或可以改变其文件大小的操作正在进"><a href="#法。在任何给定时间，只有一个涉及通道位置或可以改变其文件大小的操作正在进" class="headerlink" title="法。在任何给定时间，只有一个涉及通道位置或可以改变其文件大小的操作正在进"></a>法。在任何给定时间，只有一个涉及通道位置或可以改变其文件大小的操作正在进</h4><h4 id="行；在第一个操作仍在进行时尝试发起第二个这样的操作将被阻止，直到第一个操"><a href="#行；在第一个操作仍在进行时尝试发起第二个这样的操作将被阻止，直到第一个操" class="headerlink" title="行；在第一个操作仍在进行时尝试发起第二个这样的操作将被阻止，直到第一个操"></a>行；在第一个操作仍在进行时尝试发起第二个这样的操作将被阻止，直到第一个操</h4><h4 id="作完成。其他行动，特别是采取明确立场的行动，可以同时进行；它们是否真的这"><a href="#作完成。其他行动，特别是采取明确立场的行动，可以同时进行；它们是否真的这" class="headerlink" title="作完成。其他行动，特别是采取明确立场的行动，可以同时进行；它们是否真的这"></a>作完成。其他行动，特别是采取明确立场的行动，可以同时进行；它们是否真的这</h4><h4 id="样做取决于底层实现，因此没有具体说明。"><a href="#样做取决于底层实现，因此没有具体说明。" class="headerlink" title="样做取决于底层实现，因此没有具体说明。"></a>样做取决于底层实现，因此没有具体说明。</h4><h2 id="FileChannel示例"><a href="#FileChannel示例" class="headerlink" title="FileChannel示例"></a>FileChannel示例</h2><h4 id="FileChannel读文件"><a href="#FileChannel读文件" class="headerlink" title="FileChannel读文件"></a>FileChannel读文件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">package com.qf.channel.file;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import java.io.FileNotFoundException;</span><br><span class="line">import java.io.RandomAccessFile;</span><br><span class="line">import java.nio.ByteBuffer;</span><br><span class="line">import java.nio.channels.FileChannel;</span><br><span class="line">import java.util.RandomAccess;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* FileChannel读文件</span><br><span class="line">* @author htt</span><br><span class="line">* doublepeach</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><h4 id="FileChannel写数据"><a href="#FileChannel写数据" class="headerlink" title="FileChannel写数据"></a>FileChannel写数据</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class Demo1 &#123;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">//创建随机访问流</span><br><span class="line">RandomAccessFile file = new</span><br><span class="line">RandomAccessFile(&quot;1.txt&quot;,&quot;rw&quot;);</span><br><span class="line">//获得FileChannel</span><br><span class="line">FileChannel fileChannel = file.getChannel();</span><br><span class="line">//创建Buffer</span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate( 1024 );</span><br><span class="line">//读取数据到buffer中</span><br><span class="line">int len = 0 ;</span><br><span class="line">while((len = fileChannel.read(buffer))!=- 1 )&#123;</span><br><span class="line">//将写模式切换成读模式</span><br><span class="line">buffer.flip();</span><br><span class="line">while(buffer.hasRemaining())&#123;</span><br><span class="line">System.out.print((char)buffer.get());</span><br><span class="line">&#125;</span><br><span class="line">buffer.clear();</span><br><span class="line">&#125;</span><br><span class="line">file.close();</span><br><span class="line">System.out.println(&#x27;\n&#x27;+&quot;读取完毕&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">package com.qf.channel.file;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import java.io.FileNotFoundException;</span><br><span class="line">import java.io.RandomAccessFile;</span><br><span class="line">import java.nio.ByteBuffer;</span><br><span class="line">import java.nio.channels.FileChannel;</span><br></pre></td></tr></table></figure><h5 id="1-2-3-4-5-6-7"><a href="#1-2-3-4-5-6-7" class="headerlink" title="1 2 3 4 5 6 7"></a>1 2 3 4 5 6 7</h5><h4 id="通道之间传输数据一"><a href="#通道之间传输数据一" class="headerlink" title="通道之间传输数据一"></a>通道之间传输数据一</h4><h5 id="x2F"><a href="#x2F" class="headerlink" title="&#x2F;**"></a>&#x2F;**</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">* FileChannel写数据</span><br><span class="line">* @author htt</span><br><span class="line">* doublepeach</span><br><span class="line">*/</span><br><span class="line">public class Demo2 &#123;</span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">//创建随机访问流</span><br><span class="line">RandomAccessFile file = new</span><br><span class="line">RandomAccessFile(&quot;2.txt&quot;,&quot;rw&quot;);</span><br><span class="line">//获得FileChannel</span><br><span class="line">FileChannel fileChannel = file.getChannel();</span><br><span class="line">//创建buffer对象</span><br><span class="line">ByteBuffer byteBuffer = ByteBuffer.allocate( 1024 );</span><br><span class="line">String data = &quot;hello file channel&quot;;</span><br><span class="line">//存入buffer</span><br><span class="line">byteBuffer.put(data.getBytes());</span><br><span class="line">//读写模式转换</span><br><span class="line">byteBuffer.flip();</span><br><span class="line">//把buffer中的数据写入文件</span><br><span class="line">fileChannel.write(byteBuffer);</span><br><span class="line">//关闭</span><br><span class="line">fileChannel.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">package com.qf.channel.file;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import java.io.FileNotFoundException;</span><br><span class="line">import java.io.RandomAccessFile;</span><br><span class="line">import java.nio.channels.FileChannel;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 通道之间传输数据</span><br></pre></td></tr></table></figure><h4 id="通道之间传输数据二"><a href="#通道之间传输数据二" class="headerlink" title="通道之间传输数据二"></a>通道之间传输数据二</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">* @author htt</span><br><span class="line">* doublepeach</span><br><span class="line">*/</span><br><span class="line">public class Demo3 &#123;</span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">//获得两个文件的FileChannel</span><br><span class="line">RandomAccessFile srcFile = new</span><br><span class="line">RandomAccessFile(&quot;1.txt&quot;,&quot;rw&quot;);</span><br><span class="line">FileChannel srcFileChannel = srcFile.getChannel();</span><br><span class="line">RandomAccessFile destFile = new</span><br><span class="line">RandomAccessFile(&quot;3.txt&quot;,&quot;rw&quot;);</span><br><span class="line">FileChannel destFileChannel = destFile.getChannel();</span><br><span class="line">//src-&gt;dest</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">destFileChannel.transferFrom(srcFileChannel, 0 ,srcFileChannel.size</span><br><span class="line">());</span><br><span class="line">//关闭</span><br><span class="line">srcFileChannel.close();</span><br><span class="line">destFileChannel.close();</span><br><span class="line">System.out.println(&quot;传输完成&quot;);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">package com.qf.channel.file;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import java.io.RandomAccessFile;</span><br><span class="line">import java.nio.channels.FileChannel;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 通道之间传输数据</span><br><span class="line">* @author htt</span><br><span class="line">* doublepeach</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><h2 id="3-Socket通道介绍"><a href="#3-Socket通道介绍" class="headerlink" title="3.Socket通道介绍"></a>3.Socket通道介绍</h2><h4 id="面向流的连接通道。Socket通道用于管理socket和socket之间的通道。Socket通道具"><a href="#面向流的连接通道。Socket通道用于管理socket和socket之间的通道。Socket通道具" class="headerlink" title="面向流的连接通道。Socket通道用于管理socket和socket之间的通道。Socket通道具"></a>面向流的连接通道。Socket通道用于管理socket和socket之间的通道。Socket通道具</h4><h4 id="有以下特点："><a href="#有以下特点：" class="headerlink" title="有以下特点："></a>有以下特点：</h4><h4 id="可以实现非阻塞，一个线程可以同时管理多个Socket连接，提升系统的吞吐"><a href="#可以实现非阻塞，一个线程可以同时管理多个Socket连接，提升系统的吞吐" class="headerlink" title="可以实现非阻塞，一个线程可以同时管理多个Socket连接，提升系统的吞吐"></a>可以实现非阻塞，一个线程可以同时管理多个Socket连接，提升系统的吞吐</h4><h4 id="量。"><a href="#量。" class="headerlink" title="量。"></a>量。</h4><h4 id="Socket通道的实现类（DatagramChannel、SocketChannel和"><a href="#Socket通道的实现类（DatagramChannel、SocketChannel和" class="headerlink" title="Socket通道的实现类（DatagramChannel、SocketChannel和"></a>Socket通道的实现类（DatagramChannel、SocketChannel和</h4><h4 id="ServerSocketChannel）在被实例化时会创建一个对等的Socket对象，也可以从"><a href="#ServerSocketChannel）在被实例化时会创建一个对等的Socket对象，也可以从" class="headerlink" title="ServerSocketChannel）在被实例化时会创建一个对等的Socket对象，也可以从"></a>ServerSocketChannel）在被实例化时会创建一个对等的Socket对象，也可以从</h4><h4 id="Socket对象中通过getChannel-方法获得对应的Channel。"><a href="#Socket对象中通过getChannel-方法获得对应的Channel。" class="headerlink" title="Socket对象中通过getChannel()方法获得对应的Channel。"></a>Socket对象中通过getChannel()方法获得对应的Channel。</h4><h2 id="4-ServerSocketChannel详解"><a href="#4-ServerSocketChannel详解" class="headerlink" title="4.ServerSocketChannel详解"></a>4.ServerSocketChannel详解</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Demo4 &#123;</span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">//获得两个文件的FileChannel</span><br><span class="line">RandomAccessFile srcFile = new</span><br><span class="line">RandomAccessFile(&quot;1.txt&quot;,&quot;rw&quot;);</span><br><span class="line">FileChannel srcFileChannel = srcFile.getChannel();</span><br><span class="line">RandomAccessFile destFile = new</span><br><span class="line">RandomAccessFile(&quot;4.txt&quot;,&quot;rw&quot;);</span><br><span class="line">FileChannel destFileChannel = destFile.getChannel();</span><br><span class="line">//src-&gt;dest</span><br><span class="line">srcFileChannel.transferTo( 0 , srcFileChannel.size(),</span><br><span class="line">destFileChannel);</span><br><span class="line">//关闭</span><br><span class="line">srcFileChannel.close();</span><br><span class="line">destFileChannel.close();</span><br><span class="line">System.out.println(&quot;传输完成&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="-3"><a href="#-3" class="headerlink" title></a></h5><h4 id="ServerSocketChannel是一个基于通道的Socket监听器，能够实现非阻塞模式。"><a href="#ServerSocketChannel是一个基于通道的Socket监听器，能够实现非阻塞模式。" class="headerlink" title="ServerSocketChannel是一个基于通道的Socket监听器，能够实现非阻塞模式。"></a>ServerSocketChannel是一个基于通道的Socket监听器，能够实现非阻塞模式。</h4><h4 id="ServerSocketChannel的主要作用是用来监听端口的连接，来创建SocketChannel。"><a href="#ServerSocketChannel的主要作用是用来监听端口的连接，来创建SocketChannel。" class="headerlink" title="ServerSocketChannel的主要作用是用来监听端口的连接，来创建SocketChannel。"></a>ServerSocketChannel的主要作用是用来监听端口的连接，来创建SocketChannel。</h4><h4 id="也就是说，可以调用ServerSocketChannel的accept方法，来创建SocketChannel对"><a href="#也就是说，可以调用ServerSocketChannel的accept方法，来创建SocketChannel对" class="headerlink" title="也就是说，可以调用ServerSocketChannel的accept方法，来创建SocketChannel对"></a>也就是说，可以调用ServerSocketChannel的accept方法，来创建SocketChannel对</h4><h4 id="象。"><a href="#象。" class="headerlink" title="象。"></a>象。</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">package com.qf.channel.socket;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line">import java.net.InetSocketAddress;</span><br><span class="line">import java.nio.ByteBuffer;</span><br><span class="line">import java.nio.channels.ServerSocketChannel;</span><br><span class="line">import java.nio.channels.SocketChannel;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* ServerSocketChannel</span><br><span class="line">* @author htt</span><br><span class="line">* doublepeach</span><br><span class="line">*/</span><br><span class="line">public class ServerSocketChannelDemo &#123;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws IOException &#123;</span><br><span class="line">//创建buffer</span><br><span class="line">ByteBuffer buffer = ByteBuffer.wrap(&quot;hello server</span><br><span class="line">socket&quot;.getBytes());</span><br><span class="line">//创建ServerSocketChannel</span><br><span class="line">ServerSocketChannel ssc = ServerSocketChannel.open();</span><br><span class="line">//绑定端口</span><br><span class="line">ssc.socket().bind(new InetSocketAddress( 9090 ));</span><br><span class="line">//设置成非阻塞模式</span><br><span class="line">ssc.configureBlocking(false);</span><br><span class="line">//监听新连接</span><br><span class="line">while(true)&#123;</span><br><span class="line">System.out.println(&quot;等待连接&quot;);</span><br><span class="line">SocketChannel socketChannel = ssc.accept();</span><br><span class="line">if(socketChannel!=null)&#123;</span><br></pre></td></tr></table></figure><h5 id="-4"><a href="#-4" class="headerlink" title></a></h5><h2 id="5-SocketChannel详解"><a href="#5-SocketChannel详解" class="headerlink" title="5.SocketChannel详解"></a>5.SocketChannel详解</h2><h3 id="SocketChannel介绍"><a href="#SocketChannel介绍" class="headerlink" title="SocketChannel介绍"></a>SocketChannel介绍</h3><h4 id="SocketChannel是连接到TCP网络套接字的通道，更多代表的是客户端的操作。"><a href="#SocketChannel是连接到TCP网络套接字的通道，更多代表的是客户端的操作。" class="headerlink" title="SocketChannel是连接到TCP网络套接字的通道，更多代表的是客户端的操作。"></a>SocketChannel是连接到TCP网络套接字的通道，更多代表的是客户端的操作。</h4><h4 id="SocketChannel具有以下特点："><a href="#SocketChannel具有以下特点：" class="headerlink" title="SocketChannel具有以下特点："></a>SocketChannel具有以下特点：</h4><h4 id="SocketChannel连接的是Socket套接字，也就是说通道的两边是Socket套接字"><a href="#SocketChannel连接的是Socket套接字，也就是说通道的两边是Socket套接字" class="headerlink" title="SocketChannel连接的是Socket套接字，也就是说通道的两边是Socket套接字"></a>SocketChannel连接的是Socket套接字，也就是说通道的两边是Socket套接字</h4><h4 id="SocketChannel是用来处理网络IO的通道"><a href="#SocketChannel是用来处理网络IO的通道" class="headerlink" title="SocketChannel是用来处理网络IO的通道"></a>SocketChannel是用来处理网络IO的通道</h4><h4 id="SocketChannel是可选择的，可以被多路复用"><a href="#SocketChannel是可选择的，可以被多路复用" class="headerlink" title="SocketChannel是可选择的，可以被多路复用"></a>SocketChannel是可选择的，可以被多路复用</h4><h4 id="SocketChannel基于TCP连接传输"><a href="#SocketChannel基于TCP连接传输" class="headerlink" title="SocketChannel基于TCP连接传输"></a>SocketChannel基于TCP连接传输</h4><h3 id="SocketChannel使用细节"><a href="#SocketChannel使用细节" class="headerlink" title="SocketChannel使用细节"></a>SocketChannel使用细节</h3><h4 id="SocketChannel在使用上需要注意以下细节："><a href="#SocketChannel在使用上需要注意以下细节：" class="headerlink" title="SocketChannel在使用上需要注意以下细节："></a>SocketChannel在使用上需要注意以下细节：</h4><h4 id="不能在已经存在的Socket上再创建SocketChannel"><a href="#不能在已经存在的Socket上再创建SocketChannel" class="headerlink" title="不能在已经存在的Socket上再创建SocketChannel"></a>不能在已经存在的Socket上再创建SocketChannel</h4><h4 id="SocketChannel需要指明关联的服务器地址及端口后才能使用"><a href="#SocketChannel需要指明关联的服务器地址及端口后才能使用" class="headerlink" title="SocketChannel需要指明关联的服务器地址及端口后才能使用"></a>SocketChannel需要指明关联的服务器地址及端口后才能使用</h4><h4 id="未进行连接的SocketChannel进行IO操作时将抛出NotYetConnectedException异常"><a href="#未进行连接的SocketChannel进行IO操作时将抛出NotYetConnectedException异常" class="headerlink" title="未进行连接的SocketChannel进行IO操作时将抛出NotYetConnectedException异常"></a>未进行连接的SocketChannel进行IO操作时将抛出NotYetConnectedException异常</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(&quot;有新的连</span><br><span class="line">接:&quot;+socketChannel.socket().getRemoteSocketAddress());</span><br><span class="line">&#125;else&#123;</span><br><span class="line">try &#123;</span><br><span class="line">Thread.sleep( 1000 );</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="-5"><a href="#-5" class="headerlink" title></a></h5><h4 id="参数名称-Description"><a href="#参数名称-Description" class="headerlink" title="参数名称 Description"></a>参数名称 Description</h4><h4 id="SO-SNDBUF-Socket发送缓冲区的大小"><a href="#SO-SNDBUF-Socket发送缓冲区的大小" class="headerlink" title="SO_SNDBUF Socket发送缓冲区的大小"></a>SO_SNDBUF Socket发送缓冲区的大小</h4><h4 id="SO-RCVBUF-Socket接受缓冲区的大小"><a href="#SO-RCVBUF-Socket接受缓冲区的大小" class="headerlink" title="SO_RCVBUF Socket接受缓冲区的大小"></a>SO_RCVBUF Socket接受缓冲区的大小</h4><h4 id="SO-KEEPALIVE-保活连接"><a href="#SO-KEEPALIVE-保活连接" class="headerlink" title="SO_KEEPALIVE 保活连接"></a>SO_KEEPALIVE 保活连接</h4><h4 id="SO-REUSEADDR-复用地址"><a href="#SO-REUSEADDR-复用地址" class="headerlink" title="SO_REUSEADDR 复用地址"></a>SO_REUSEADDR 复用地址</h4><h4 id="SO-LINGER-有数据传输时延缓关闭Channel-只在非阻塞模式下使用"><a href="#SO-LINGER-有数据传输时延缓关闭Channel-只在非阻塞模式下使用" class="headerlink" title="SO_LINGER 有数据传输时延缓关闭Channel (只在非阻塞模式下使用)"></a>SO_LINGER 有数据传输时延缓关闭Channel (只在非阻塞模式下使用)</h4><h4 id="TCP-NODELAY-禁用Nagle算法"><a href="#TCP-NODELAY-禁用Nagle算法" class="headerlink" title="TCP_NODELAY 禁用Nagle算法"></a>TCP_NODELAY 禁用Nagle算法</h4><h4 id="SocketChannel支持阻塞和非阻塞两种模式"><a href="#SocketChannel支持阻塞和非阻塞两种模式" class="headerlink" title="SocketChannel支持阻塞和非阻塞两种模式"></a>SocketChannel支持阻塞和非阻塞两种模式</h4><h4 id="SocketChannel支持异步关闭。"><a href="#SocketChannel支持异步关闭。" class="headerlink" title="SocketChannel支持异步关闭。"></a>SocketChannel支持异步关闭。</h4><h4 id="SocketChannel支持设定参数"><a href="#SocketChannel支持设定参数" class="headerlink" title="SocketChannel支持设定参数"></a>SocketChannel支持设定参数</h4><h3 id="SocketChannel示例"><a href="#SocketChannel示例" class="headerlink" title="SocketChannel示例"></a>SocketChannel示例</h3><h4 id="创建SocketChannel"><a href="#创建SocketChannel" class="headerlink" title="创建SocketChannel"></a>创建SocketChannel</h4><h4 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h4><h4 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h4><h4 id="连接状态校验"><a href="#连接状态校验" class="headerlink" title="连接状态校验"></a>连接状态校验</h4><h4 id="socketChannel-isOpen-判断SocketChannel是否为open状态"><a href="#socketChannel-isOpen-判断SocketChannel是否为open状态" class="headerlink" title="socketChannel.isOpen(): 判断SocketChannel是否为open状态"></a>socketChannel.isOpen(): 判断SocketChannel是否为open状态</h4><h4 id="socketChannel-isConnected-判断SocketChannel是否已连接"><a href="#socketChannel-isConnected-判断SocketChannel是否已连接" class="headerlink" title="socketChannel.isConnected(): 判断SocketChannel是否已连接"></a>socketChannel.isConnected(): 判断SocketChannel是否已连接</h4><h4 id="socketChannel-isConnectionPending-判断SocketChannel是否正在进行连接"><a href="#socketChannel-isConnectionPending-判断SocketChannel是否正在进行连接" class="headerlink" title="socketChannel.isConnectionPending(): 判断SocketChannel是否正在进行连接"></a>socketChannel.isConnectionPending(): 判断SocketChannel是否正在进行连接</h4><h4 id="socketChannel-finishConnect-完成连接，如果此通道已连接，则此方法将"><a href="#socketChannel-finishConnect-完成连接，如果此通道已连接，则此方法将" class="headerlink" title="socketChannel.finishConnect(): 完成连接，如果此通道已连接，则此方法将"></a>socketChannel.finishConnect(): 完成连接，如果此通道已连接，则此方法将</h4><h4 id="不会阻塞，并将立即返回true。如果此通道处于非阻塞模式，则如果连接过"><a href="#不会阻塞，并将立即返回true。如果此通道处于非阻塞模式，则如果连接过" class="headerlink" title="不会阻塞，并将立即返回true。如果此通道处于非阻塞模式，则如果连接过"></a>不会阻塞，并将立即返回true。如果此通道处于非阻塞模式，则如果连接过</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SocketChannel socketChannel = SocketChannel.open(new</span><br><span class="line">InetSocketAddress(&quot;localhost&quot;, 9090 ));</span><br></pre></td></tr></table></figure><h5 id="1"><a href="#1" class="headerlink" title="1"></a>1</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SocketChannel socketChannel = SocketChannel.open();</span><br><span class="line">socketChannel.connect(new InetSocketAddress(&quot;localhost&quot;, 9090 ));</span><br></pre></td></tr></table></figure><h5 id="1-1"><a href="#1-1" class="headerlink" title="1"></a>1</h5><h5 id="2"><a href="#2" class="headerlink" title="2"></a>2</h5><h4 id="程尚未完成，则此方法将返回false。如果此通道处于阻塞模式，则此方法"><a href="#程尚未完成，则此方法将返回false。如果此通道处于阻塞模式，则此方法" class="headerlink" title="程尚未完成，则此方法将返回false。如果此通道处于阻塞模式，则此方法"></a>程尚未完成，则此方法将返回false。如果此通道处于阻塞模式，则此方法</h4><h4 id="将阻塞，直到连接完成或失败，并且将始终返回true或抛出一个描述失败的"><a href="#将阻塞，直到连接完成或失败，并且将始终返回true或抛出一个描述失败的" class="headerlink" title="将阻塞，直到连接完成或失败，并且将始终返回true或抛出一个描述失败的"></a>将阻塞，直到连接完成或失败，并且将始终返回true或抛出一个描述失败的</h4><h4 id="检查异常。"><a href="#检查异常。" class="headerlink" title="检查异常。"></a>检查异常。</h4><h4 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h4><h4 id="读写操作"><a href="#读写操作" class="headerlink" title="读写操作"></a>读写操作</h4><h5 id="x2F-x2F-设置非阻塞"><a href="#x2F-x2F-设置非阻塞" class="headerlink" title="&#x2F;&#x2F;设置非阻塞"></a>&#x2F;&#x2F;设置非阻塞</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socketChannel.configureBlocking(false);</span><br></pre></td></tr></table></figure><h5 id="1-2"><a href="#1-2" class="headerlink" title="1"></a>1</h5><h5 id="2-1"><a href="#2-1" class="headerlink" title="2"></a>2</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">package com.qf.channel.socket;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line">import java.net.InetSocketAddress;</span><br><span class="line">import java.nio.ByteBuffer;</span><br><span class="line">import java.nio.channels.SocketChannel;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* SocketChannel</span><br><span class="line">* @author htt</span><br><span class="line">* doublepeach</span><br><span class="line">*/</span><br><span class="line">public class SocketChannelDemo &#123;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws IOException &#123;</span><br><span class="line">SocketChannel socketChannel = SocketChannel.open();</span><br><span class="line">socketChannel.connect(new</span><br><span class="line">InetSocketAddress(&quot;www.baidu.com&quot;, 80 ));</span><br><span class="line">//设置非阻塞</span><br><span class="line">socketChannel.configureBlocking(true);</span><br><span class="line">if(socketChannel.isConnectionPending())&#123;</span><br><span class="line">//完成连接</span><br><span class="line">socketChannel.finishConnect();</span><br><span class="line">&#125;</span><br><span class="line">ByteBuffer byteBuffer = ByteBuffer.allocate( 1024 );</span><br><span class="line">//如果是阻塞模式，则此处将阻塞</span><br><span class="line">socketChannel.read(byteBuffer);</span><br></pre></td></tr></table></figure><h5 id="-6"><a href="#-6" class="headerlink" title></a></h5><h4 id="设置参数"><a href="#设置参数" class="headerlink" title="设置参数"></a>设置参数</h4><h2 id="6-DatagramChannel详解"><a href="#6-DatagramChannel详解" class="headerlink" title="6.DatagramChannel详解"></a>6.DatagramChannel详解</h2><h4 id="DatagramChannel对象关联着一个DatagramSocket对象。"><a href="#DatagramChannel对象关联着一个DatagramSocket对象。" class="headerlink" title="DatagramChannel对象关联着一个DatagramSocket对象。"></a>DatagramChannel对象关联着一个DatagramSocket对象。</h4><h4 id="DatagramChannel基于UDP无连接协议，每个数据报都是一个自包含的实体，拥有"><a href="#DatagramChannel基于UDP无连接协议，每个数据报都是一个自包含的实体，拥有" class="headerlink" title="DatagramChannel基于UDP无连接协议，每个数据报都是一个自包含的实体，拥有"></a>DatagramChannel基于UDP无连接协议，每个数据报都是一个自包含的实体，拥有</h4><h4 id="它自己的目的地址及数据负载。DatagramChannel可以发送单独的数据报给不同的"><a href="#它自己的目的地址及数据负载。DatagramChannel可以发送单独的数据报给不同的" class="headerlink" title="它自己的目的地址及数据负载。DatagramChannel可以发送单独的数据报给不同的"></a>它自己的目的地址及数据负载。DatagramChannel可以发送单独的数据报给不同的</h4><h4 id="目的地，同样也可以接受来自于任意地址的数据报。"><a href="#目的地，同样也可以接受来自于任意地址的数据报。" class="headerlink" title="目的地，同样也可以接受来自于任意地址的数据报。"></a>目的地，同样也可以接受来自于任意地址的数据报。</h4><h4 id="发送方的实现"><a href="#发送方的实现" class="headerlink" title="发送方的实现"></a>发送方的实现</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(&quot;读取到的内容:&quot;+new</span><br><span class="line">String(byteBuffer.array()));</span><br><span class="line">socketChannel.close();</span><br><span class="line">System.out.println(&quot;完成读操作&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="-7"><a href="#-7" class="headerlink" title></a></h5><h5 id="x2F-x2F-设置参数"><a href="#x2F-x2F-设置参数" class="headerlink" title="&#x2F;&#x2F;设置参数"></a>&#x2F;&#x2F;设置参数</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">socketChannel.setOption(StandardSocketOptions.SO_RCVBUF, 2048 );</span><br><span class="line">socketChannel.setOption(StandardSocketOptions.SO_RCVBUF, 2048 );</span><br><span class="line">//获取参数</span><br><span class="line">socketChannel.getOption(StandardSocketOptions.SO_RCVBUF);</span><br></pre></td></tr></table></figure><h5 id="-8"><a href="#-8" class="headerlink" title></a></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testSend() throws Exception &#123;</span><br><span class="line">//获得DatagramChannel</span><br><span class="line">DatagramChannel datagramChannel = DatagramChannel.open();</span><br><span class="line">//创建地址对象</span><br><span class="line">InetSocketAddress socketAddress = new</span><br><span class="line">InetSocketAddress(&quot;127.0.0.1&quot;, 9001 );</span><br><span class="line">//创建Buffer</span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate( 1024 );</span><br><span class="line">buffer.put(&quot;hello datagram channel&quot;.getBytes());</span><br></pre></td></tr></table></figure><h5 id="-9"><a href="#-9" class="headerlink" title></a></h5><h4 id="接收方的实现"><a href="#接收方的实现" class="headerlink" title="接收方的实现"></a>接收方的实现</h4><h4 id="使用read和write来表示接收和发送"><a href="#使用read和write来表示接收和发送" class="headerlink" title="使用read和write来表示接收和发送"></a>使用read和write来表示接收和发送</h4><h4 id="DatagramChannel并不会建立连接通道，这里的read和write方法是在缓冲区中进行"><a href="#DatagramChannel并不会建立连接通道，这里的read和write方法是在缓冲区中进行" class="headerlink" title="DatagramChannel并不会建立连接通道，这里的read和write方法是在缓冲区中进行"></a>DatagramChannel并不会建立连接通道，这里的read和write方法是在缓冲区中进行</h4><h4 id="读写，来表达发送和接收的动作。"><a href="#读写，来表达发送和接收的动作。" class="headerlink" title="读写，来表达发送和接收的动作。"></a>读写，来表达发送和接收的动作。</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">buffer.flip();</span><br><span class="line">// ByteBuffer buffer = ByteBuffer.wrap(&quot;hello datagram</span><br><span class="line">channel&quot;.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">//发送消息</span><br><span class="line">datagramChannel.send(buffer,socketAddress);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="-10"><a href="#-10" class="headerlink" title></a></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testReceive() throws Exception &#123;</span><br><span class="line">//获得DatagramChannel</span><br><span class="line">DatagramChannel datagramChannel = DatagramChannel.open();</span><br><span class="line">//创建地址对象</span><br><span class="line">InetSocketAddress socketAddress = new</span><br><span class="line">InetSocketAddress( 9001 );</span><br><span class="line">//绑定端口到Channel上</span><br><span class="line">datagramChannel.bind(socketAddress);</span><br><span class="line">//创建Buffer</span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate( 1024 );</span><br><span class="line">//接收消息</span><br><span class="line">while(true)&#123;</span><br><span class="line">buffer.clear();</span><br><span class="line">SocketAddress address =</span><br><span class="line">datagramChannel.receive(buffer);</span><br><span class="line">buffer.flip();</span><br><span class="line">System.out.println(address.toString()+&quot;发来消息：&quot;+new</span><br><span class="line">String(buffer.array(), 0 ,buffer.limit()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="-11"><a href="#-11" class="headerlink" title></a></h5><h2 id="7-分散和聚集"><a href="#7-分散和聚集" class="headerlink" title="7.分散和聚集"></a>7.分散和聚集</h2><h4 id="Java-NIO的分散Scatter和聚集Gather允许用户通过channel一次读取到的数据存入到"><a href="#Java-NIO的分散Scatter和聚集Gather允许用户通过channel一次读取到的数据存入到" class="headerlink" title="Java NIO的分散Scatter和聚集Gather允许用户通过channel一次读取到的数据存入到"></a>Java NIO的分散Scatter和聚集Gather允许用户通过channel一次读取到的数据存入到</h4><h4 id="多个buffer中，或者一次将多个buffer中的数据写入到一个Channel中。分散和聚集"><a href="#多个buffer中，或者一次将多个buffer中的数据写入到一个Channel中。分散和聚集" class="headerlink" title="多个buffer中，或者一次将多个buffer中的数据写入到一个Channel中。分散和聚集"></a>多个buffer中，或者一次将多个buffer中的数据写入到一个Channel中。分散和聚集</h4><h4 id="的应用场景可以是将数据的多个部分存放在不同的buffer中来进行读写。"><a href="#的应用场景可以是将数据的多个部分存放在不同的buffer中来进行读写。" class="headerlink" title="的应用场景可以是将数据的多个部分存放在不同的buffer中来进行读写。"></a>的应用场景可以是将数据的多个部分存放在不同的buffer中来进行读写。</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testReadAndWrite() throws Exception &#123;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//获得DatagramChannel</span><br><span class="line">DatagramChannel datagramChannel = DatagramChannel.open();</span><br><span class="line">//绑定</span><br><span class="line">datagramChannel.bind(new InetSocketAddress( 9002 ));</span><br><span class="line">//连接</span><br><span class="line">datagramChannel.connect(new</span><br><span class="line">InetSocketAddress(&quot;127.0.0.1&quot;, 9002 ));</span><br><span class="line">//write</span><br><span class="line">datagramChannel.write(ByteBuffer.wrap(&quot;write</span><br><span class="line">message&quot;.getBytes()));</span><br><span class="line">//创建用于读数据的Buffer</span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate( 1024 );</span><br><span class="line">while(true)&#123;</span><br><span class="line">buffer.clear();</span><br><span class="line">datagramChannel.read(buffer);</span><br><span class="line">buffer.flip();</span><br><span class="line">System.out.println(&quot;收到消息：&quot;+new</span><br><span class="line">String(buffer.array(), 0 ,buffer.limit()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="-12"><a href="#-12" class="headerlink" title="}"></a>}</h5><h5 id="-13"><a href="#-13" class="headerlink" title></a></h5><h4 id="分散Scatter"><a href="#分散Scatter" class="headerlink" title="分散Scatter"></a>分散Scatter</h4><h4 id="在一个channel中读取的数据存入到多个buffer中。"><a href="#在一个channel中读取的数据存入到多个buffer中。" class="headerlink" title="在一个channel中读取的数据存入到多个buffer中。"></a>在一个channel中读取的数据存入到多个buffer中。</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">package com.qf.channel.scatterandgather;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import java.io.FileNotFoundException;</span><br><span class="line">import java.io.RandomAccessFile;</span><br><span class="line">import java.nio.ByteBuffer;</span><br><span class="line">import java.nio.channels.FileChannel;</span><br><span class="line">import java.util.Arrays;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 分散</span><br><span class="line">* @author htt</span><br><span class="line">* doublepeach</span><br><span class="line">*/</span><br><span class="line">public class Demo1 &#123;</span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">//随机访问流</span><br><span class="line">RandomAccessFile file = new</span><br><span class="line">RandomAccessFile(&quot;1.txt&quot;,&quot;rw&quot;);</span><br><span class="line">//得到FileChannel</span><br><span class="line">FileChannel fileChannel = file.getChannel();</span><br><span class="line">//创建buffer</span><br></pre></td></tr></table></figure><h5 id="-14"><a href="#-14" class="headerlink" title></a></h5><h4 id="聚集Gather"><a href="#聚集Gather" class="headerlink" title="聚集Gather"></a>聚集Gather</h4><h4 id="一次将多个buffer中的数据写入到一个channel中。"><a href="#一次将多个buffer中的数据写入到一个channel中。" class="headerlink" title="一次将多个buffer中的数据写入到一个channel中。"></a>一次将多个buffer中的数据写入到一个channel中。</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buffer1 = ByteBuffer.allocate( 3 );</span><br><span class="line">ByteBuffer buffer2 = ByteBuffer.allocate( 3 );</span><br><span class="line">;</span><br><span class="line">//fileChannel读取数据到buffer中</span><br><span class="line">long len = 0 ;</span><br><span class="line">while((len = fileChannel.read(new ByteBuffer[]</span><br><span class="line">&#123;buffer1,buffer2&#125;))!=- 1 )&#123;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">buffer1.flip();</span><br><span class="line">buffer2.flip();</span><br><span class="line">System.out.println(&quot;buffer1:&quot;+new</span><br><span class="line">String(buffer1.array(), 0 ,buffer1.limit()));</span><br><span class="line">System.out.println(&quot;buffer2:&quot;+new</span><br><span class="line">String(buffer2.array(), 0 ,buffer2.limit()));</span><br><span class="line">file.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="-15"><a href="#-15" class="headerlink" title></a></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">package com.qf.channel.scatterandgather;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import java.io.FileNotFoundException;</span><br><span class="line">import java.io.RandomAccessFile;</span><br><span class="line">import java.nio.ByteBuffer;</span><br><span class="line">import java.nio.channels.FileChannel;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 聚集</span><br><span class="line">* @author htt</span><br><span class="line">* doublepeach</span><br><span class="line">*/</span><br><span class="line">public class Demo2 &#123;</span><br></pre></td></tr></table></figure><h5 id="-16"><a href="#-16" class="headerlink" title></a></h5><h1 id="四、NIO-Buffer详解"><a href="#四、NIO-Buffer详解" class="headerlink" title="四、NIO-Buffer详解"></a>四、NIO-Buffer详解</h1><h2 id="1-Buffer概述"><a href="#1-Buffer概述" class="headerlink" title="1.Buffer概述"></a>1.Buffer概述</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">//创建随机访问流</span><br><span class="line">RandomAccessFile file = new</span><br><span class="line">RandomAccessFile(&quot;5.txt&quot;,&quot;rw&quot;);</span><br><span class="line">//获得FileChannel</span><br><span class="line">FileChannel fileChannel = file.getChannel();</span><br><span class="line">//创建 2 个buffer对象</span><br><span class="line">ByteBuffer byteBuffer1 = ByteBuffer.allocate( 1024 );</span><br><span class="line">ByteBuffer byteBuffer2 = ByteBuffer.allocate( 1024 );</span><br><span class="line">//数据 1</span><br><span class="line">String data1 = &quot;hello buffer1 channel&quot;;</span><br><span class="line">//存入buffer1</span><br><span class="line">byteBuffer1.put(data1.getBytes());</span><br><span class="line">//翻转buffer1</span><br><span class="line">byteBuffer1.flip();</span><br><span class="line">//数据 1</span><br><span class="line">String data2 = &quot;hello buffer2 channel&quot;;</span><br><span class="line">//存入buffer1</span><br><span class="line">byteBuffer2.put(data2.getBytes());</span><br><span class="line">//翻转buffer1</span><br><span class="line">byteBuffer2.flip();</span><br><span class="line">//fileChannel写数据到文件</span><br><span class="line">fileChannel.write(new ByteBuffer[]</span><br><span class="line">&#123;byteBuffer1,byteBuffer2&#125;);</span><br><span class="line">//关闭</span><br><span class="line">fileChannel.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="-17"><a href="#-17" class="headerlink" title></a></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">܉᲋රᙙJavaරᎸᴺ ̓ݩռلဳىJavaຝ຅຾̈́ӥ᫹ಅํ᧞ᑕդᎱ᧞կ݊ૡٍ ᦏದ๞ࢧ୭๜ᧆํጱᕍᶉѺ</span><br></pre></td></tr></table></figure><h2 id="1-Buffer概述-1"><a href="#1-Buffer概述-1" class="headerlink" title="1.Buffer概述"></a>1.Buffer概述</h2><h4 id="Buffer缓冲区实际上是内存中开辟的一块数组空间，用于存放数据。Java-NIO中的"><a href="#Buffer缓冲区实际上是内存中开辟的一块数组空间，用于存放数据。Java-NIO中的" class="headerlink" title="Buffer缓冲区实际上是内存中开辟的一块数组空间，用于存放数据。Java NIO中的"></a>Buffer缓冲区实际上是内存中开辟的一块数组空间，用于存放数据。Java NIO中的</h4><h4 id="buffer类提供了对这块数组缓冲区的基本操作。"><a href="#buffer类提供了对这块数组缓冲区的基本操作。" class="headerlink" title="buffer类提供了对这块数组缓冲区的基本操作。"></a>buffer类提供了对这块数组缓冲区的基本操作。</h4><h4 id="IO流的操作面向的是流对象，而NIO操作的数据都是面向Buffer缓冲区的。也就是"><a href="#IO流的操作面向的是流对象，而NIO操作的数据都是面向Buffer缓冲区的。也就是" class="headerlink" title="IO流的操作面向的是流对象，而NIO操作的数据都是面向Buffer缓冲区的。也就是"></a>IO流的操作面向的是流对象，而NIO操作的数据都是面向Buffer缓冲区的。也就是</h4><h4 id="说，读取数据是通过通道将数据存入到buffer中。写数据是将buffer缓冲区中的数据"><a href="#说，读取数据是通过通道将数据存入到buffer中。写数据是将buffer缓冲区中的数据" class="headerlink" title="说，读取数据是通过通道将数据存入到buffer中。写数据是将buffer缓冲区中的数据"></a>说，读取数据是通过通道将数据存入到buffer中。写数据是将buffer缓冲区中的数据</h4><h4 id="通过通道写到文件中。"><a href="#通过通道写到文件中。" class="headerlink" title="通过通道写到文件中。"></a>通过通道写到文件中。</h4><h4 id="Java-NIO提供了所有缓冲区的抽象基类Buffer。Buffer的具体实现类有很多，比如"><a href="#Java-NIO提供了所有缓冲区的抽象基类Buffer。Buffer的具体实现类有很多，比如" class="headerlink" title="Java NIO提供了所有缓冲区的抽象基类Buffer。Buffer的具体实现类有很多，比如"></a>Java NIO提供了所有缓冲区的抽象基类Buffer。Buffer的具体实现类有很多，比如</h4><h4 id="ByteBuffer、IntBuffer、LongBuffer、CharBuffer、DoubleBuffer、FloatBuffer、"><a href="#ByteBuffer、IntBuffer、LongBuffer、CharBuffer、DoubleBuffer、FloatBuffer、" class="headerlink" title="ByteBuffer、IntBuffer、LongBuffer、CharBuffer、DoubleBuffer、FloatBuffer、"></a>ByteBuffer、IntBuffer、LongBuffer、CharBuffer、DoubleBuffer、FloatBuffer、</h4><h4 id="HeapByteBuffer、MappedByteBuffer等等，这些具体的实现类实际上是依据Buffer数"><a href="#HeapByteBuffer、MappedByteBuffer等等，这些具体的实现类实际上是依据Buffer数" class="headerlink" title="HeapByteBuffer、MappedByteBuffer等等，这些具体的实现类实际上是依据Buffer数"></a>HeapByteBuffer、MappedByteBuffer等等，这些具体的实现类实际上是依据Buffer数</h4><h4 id="组中存放数据的数据类型来决定，比如ByteBuffer中存放的是字节数据、LongBuffer"><a href="#组中存放数据的数据类型来决定，比如ByteBuffer中存放的是字节数据、LongBuffer" class="headerlink" title="组中存放数据的数据类型来决定，比如ByteBuffer中存放的是字节数据、LongBuffer"></a>组中存放数据的数据类型来决定，比如ByteBuffer中存放的是字节数据、LongBuffer</h4><h4 id="中存放的long类型的数据。"><a href="#中存放的long类型的数据。" class="headerlink" title="中存放的long类型的数据。"></a>中存放的long类型的数据。</h4><h2 id="2-Buffer的关键属性"><a href="#2-Buffer的关键属性" class="headerlink" title="2.Buffer的关键属性"></a>2.Buffer的关键属性</h2><h4 id="Buffer的三大关键属性：capactity、limit、position。"><a href="#Buffer的三大关键属性：capactity、limit、position。" class="headerlink" title="Buffer的三大关键属性：capactity、limit、position。"></a>Buffer的三大关键属性：capactity、limit、position。</h4><h4 id="capacity"><a href="#capacity" class="headerlink" title="capacity:"></a>capacity:</h4><h4 id="缓冲区的容量是它包含的元素数。缓冲区的容量永远不会为负，也永远不会改"><a href="#缓冲区的容量是它包含的元素数。缓冲区的容量永远不会为负，也永远不会改" class="headerlink" title="缓冲区的容量是它包含的元素数。缓冲区的容量永远不会为负，也永远不会改"></a>缓冲区的容量是它包含的元素数。缓冲区的容量永远不会为负，也永远不会改</h4><h4 id="变。"><a href="#变。" class="headerlink" title="变。"></a>变。</h4><h4 id="limit"><a href="#limit" class="headerlink" title="limit:"></a>limit:</h4><h4 id="缓冲区的限制是不应读取或写入的第一个元素的索引。缓冲区的限制永远不会"><a href="#缓冲区的限制是不应读取或写入的第一个元素的索引。缓冲区的限制永远不会" class="headerlink" title="缓冲区的限制是不应读取或写入的第一个元素的索引。缓冲区的限制永远不会"></a>缓冲区的限制是不应读取或写入的第一个元素的索引。缓冲区的限制永远不会</h4><h4 id="为负，也永远不会大于其容量。"><a href="#为负，也永远不会大于其容量。" class="headerlink" title="为负，也永远不会大于其容量。"></a>为负，也永远不会大于其容量。</h4><h4 id="写数据时：limit与capacity相同"><a href="#写数据时：limit与capacity相同" class="headerlink" title="写数据时：limit与capacity相同"></a>写数据时：limit与capacity相同</h4><h4 id="读数据时：limit表示可读的数据位置，因此在上次写操作后需要通过flip方"><a href="#读数据时：limit表示可读的数据位置，因此在上次写操作后需要通过flip方" class="headerlink" title="读数据时：limit表示可读的数据位置，因此在上次写操作后需要通过flip方"></a>读数据时：limit表示可读的数据位置，因此在上次写操作后需要通过flip方</h4><h4 id="法，将position值赋给limit。"><a href="#法，将position值赋给limit。" class="headerlink" title="法，将position值赋给limit。"></a>法，将position值赋给limit。</h4><h4 id="position"><a href="#position" class="headerlink" title="position:"></a>position:</h4><h4 id="返回值类型-方法名-描述"><a href="#返回值类型-方法名-描述" class="headerlink" title="返回值类型 方法名 描述"></a>返回值类型 方法名 描述</h4><h4 id="abstract"><a href="#abstract" class="headerlink" title="abstract"></a>abstract</h4><h4 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h4><h4 id="array-返回缓冲区中的数组"><a href="#array-返回缓冲区中的数组" class="headerlink" title="array() 返回缓冲区中的数组"></a>array() 返回缓冲区中的数组</h4><h4 id="abstract-1"><a href="#abstract-1" class="headerlink" title="abstract"></a>abstract</h4><h4 id="int"><a href="#int" class="headerlink" title="int"></a>int</h4><h4 id="arrayOffset"><a href="#arrayOffset" class="headerlink" title="arrayOffset()"></a>arrayOffset()</h4><h4 id="返回缓冲区中数组的第一个元素"><a href="#返回缓冲区中数组的第一个元素" class="headerlink" title="返回缓冲区中数组的第一个元素"></a>返回缓冲区中数组的第一个元素</h4><h4 id="的位置"><a href="#的位置" class="headerlink" title="的位置"></a>的位置</h4><h4 id="int-capacity-返回缓冲区的容量"><a href="#int-capacity-返回缓冲区的容量" class="headerlink" title="int capacity() 返回缓冲区的容量"></a>int capacity() 返回缓冲区的容量</h4><h4 id="Buffer-clear-清空缓冲区中的内容"><a href="#Buffer-clear-清空缓冲区中的内容" class="headerlink" title="Buffer clear() 清空缓冲区中的内容"></a>Buffer clear() 清空缓冲区中的内容</h4><h4 id="Buffer-flip-翻转缓冲区"><a href="#Buffer-flip-翻转缓冲区" class="headerlink" title="Buffer flip() 翻转缓冲区"></a>Buffer flip() 翻转缓冲区</h4><h4 id="abstract-2"><a href="#abstract-2" class="headerlink" title="abstract"></a>abstract</h4><h4 id="boolean"><a href="#boolean" class="headerlink" title="boolean"></a>boolean</h4><h4 id="hasArray-是否缓冲区中有可访问的数组"><a href="#hasArray-是否缓冲区中有可访问的数组" class="headerlink" title="hasArray() 是否缓冲区中有可访问的数组"></a>hasArray() 是否缓冲区中有可访问的数组</h4><h4 id="boolean-hasRemaining"><a href="#boolean-hasRemaining" class="headerlink" title="boolean hasRemaining()"></a>boolean hasRemaining()</h4><h4 id="缓冲区中的position和limit之间"><a href="#缓冲区中的position和limit之间" class="headerlink" title="缓冲区中的position和limit之间"></a>缓冲区中的position和limit之间</h4><h4 id="是还存在元素"><a href="#是还存在元素" class="headerlink" title="是还存在元素"></a>是还存在元素</h4><h4 id="abstract-3"><a href="#abstract-3" class="headerlink" title="abstract"></a>abstract</h4><h4 id="boolean-1"><a href="#boolean-1" class="headerlink" title="boolean"></a>boolean</h4><h4 id="isDirect-此缓冲区是否是直接缓冲区"><a href="#isDirect-此缓冲区是否是直接缓冲区" class="headerlink" title="isDirect() 此缓冲区是否是直接缓冲区"></a>isDirect() 此缓冲区是否是直接缓冲区</h4><h4 id="abstract-4"><a href="#abstract-4" class="headerlink" title="abstract"></a>abstract</h4><h4 id="boolean-2"><a href="#boolean-2" class="headerlink" title="boolean"></a>boolean</h4><h4 id="isReadOnly-此缓冲区是否是只读缓冲区"><a href="#isReadOnly-此缓冲区是否是只读缓冲区" class="headerlink" title="isReadOnly() 此缓冲区是否是只读缓冲区"></a>isReadOnly() 此缓冲区是否是只读缓冲区</h4><h4 id="int-limit-返回此缓冲区的limit属性值"><a href="#int-limit-返回此缓冲区的limit属性值" class="headerlink" title="int limit() 返回此缓冲区的limit属性值"></a>int limit() 返回此缓冲区的limit属性值</h4><h4 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h4><h4 id="limit-int"><a href="#limit-int" class="headerlink" title="limit(int"></a>limit(int</h4><h4 id="newLimit"><a href="#newLimit" class="headerlink" title="newLimit)"></a>newLimit)</h4><h4 id="设置此缓冲区的limit属性值"><a href="#设置此缓冲区的limit属性值" class="headerlink" title="设置此缓冲区的limit属性值"></a>设置此缓冲区的limit属性值</h4><h4 id="缓冲区的位置是要读取或写入的下一个元素的索引。缓冲器的位置永远不会为"><a href="#缓冲区的位置是要读取或写入的下一个元素的索引。缓冲器的位置永远不会为" class="headerlink" title="缓冲区的位置是要读取或写入的下一个元素的索引。缓冲器的位置永远不会为"></a>缓冲区的位置是要读取或写入的下一个元素的索引。缓冲器的位置永远不会为</h4><h4 id="负，也永远不会大于其极限。"><a href="#负，也永远不会大于其极限。" class="headerlink" title="负，也永远不会大于其极限。"></a>负，也永远不会大于其极限。</h4><h2 id="3-Buffer的方法"><a href="#3-Buffer的方法" class="headerlink" title="3.Buffer的方法"></a>3.Buffer的方法</h2><h4 id="Buffer中的方法如下："><a href="#Buffer中的方法如下：" class="headerlink" title="Buffer中的方法如下："></a>Buffer中的方法如下：</h4><h4 id="Buffer-mark-标记当前缓冲区的position值"><a href="#Buffer-mark-标记当前缓冲区的position值" class="headerlink" title="Buffer mark() 标记当前缓冲区的position值"></a>Buffer mark() 标记当前缓冲区的position值</h4><h4 id="int-position-返回此缓冲区的position属性值"><a href="#int-position-返回此缓冲区的position属性值" class="headerlink" title="int position() 返回此缓冲区的position属性值"></a>int position() 返回此缓冲区的position属性值</h4><h4 id="Buffer-1"><a href="#Buffer-1" class="headerlink" title="Buffer"></a>Buffer</h4><h4 id="position-int"><a href="#position-int" class="headerlink" title="position(int"></a>position(int</h4><h4 id="newPosition"><a href="#newPosition" class="headerlink" title="newPosition)"></a>newPosition)</h4><h4 id="设置此缓冲区的position属性值"><a href="#设置此缓冲区的position属性值" class="headerlink" title="设置此缓冲区的position属性值"></a>设置此缓冲区的position属性值</h4><h4 id="int-remaining"><a href="#int-remaining" class="headerlink" title="int remaining()"></a>int remaining()</h4><h4 id="返回缓冲区中position和limit之"><a href="#返回缓冲区中position和limit之" class="headerlink" title="返回缓冲区中position和limit之"></a>返回缓冲区中position和limit之</h4><h4 id="间元素的个数"><a href="#间元素的个数" class="headerlink" title="间元素的个数"></a>间元素的个数</h4><h4 id="Buffer-reset"><a href="#Buffer-reset" class="headerlink" title="Buffer reset()"></a>Buffer reset()</h4><h4 id="重置缓冲区中position的值为之"><a href="#重置缓冲区中position的值为之" class="headerlink" title="重置缓冲区中position的值为之"></a>重置缓冲区中position的值为之</h4><h4 id="前mark的值"><a href="#前mark的值" class="headerlink" title="前mark的值"></a>前mark的值</h4><h4 id="Buffer-rewind-将position设置-0-，limit不变"><a href="#Buffer-rewind-将position设置-0-，limit不变" class="headerlink" title="Buffer rewind() 将position设置 0 ，limit不变"></a>Buffer rewind() 将position设置 0 ，limit不变</h4><h2 id="4-Buffer实现类的常用方法"><a href="#4-Buffer实现类的常用方法" class="headerlink" title="4.Buffer实现类的常用方法"></a>4.Buffer实现类的常用方法</h2><h4 id="以ByteBuffer为例，分类介绍ByteBuffer的常用方法。"><a href="#以ByteBuffer为例，分类介绍ByteBuffer的常用方法。" class="headerlink" title="以ByteBuffer为例，分类介绍ByteBuffer的常用方法。"></a>以ByteBuffer为例，分类介绍ByteBuffer的常用方法。</h4><h4 id="创建Buffer"><a href="#创建Buffer" class="headerlink" title="创建Buffer"></a>创建Buffer</h4><h4 id="ByteBuffer提供了allocate静态方法用来创建带有初始化数组的Buffer缓冲区。"><a href="#ByteBuffer提供了allocate静态方法用来创建带有初始化数组的Buffer缓冲区。" class="headerlink" title="ByteBuffer提供了allocate静态方法用来创建带有初始化数组的Buffer缓冲区。"></a>ByteBuffer提供了allocate静态方法用来创建带有初始化数组的Buffer缓冲区。</h4><h4 id="向Buffer中写数据"><a href="#向Buffer中写数据" class="headerlink" title="向Buffer中写数据"></a>向Buffer中写数据</h4><h4 id="将数据写入到buffer中有三种方式："><a href="#将数据写入到buffer中有三种方式：" class="headerlink" title="将数据写入到buffer中有三种方式："></a>将数据写入到buffer中有三种方式：</h4><h4 id="put-数据-：-将数据存入到buffer，此时position随之变化。"><a href="#put-数据-：-将数据存入到buffer，此时position随之变化。" class="headerlink" title="put(数据)： 将数据存入到buffer，此时position随之变化。"></a>put(数据)： 将数据存入到buffer，此时position随之变化。</h4><h4 id="wrap-数据-：将数据存入数据并返回buffer，此时position为-0-，limit为数据"><a href="#wrap-数据-：将数据存入数据并返回buffer，此时position为-0-，limit为数据" class="headerlink" title="wrap(数据)：将数据存入数据并返回buffer，此时position为 0 ，limit为数据"></a>wrap(数据)：将数据存入数据并返回buffer，此时position为 0 ，limit为数据</h4><h4 id="的⻓度"><a href="#的⻓度" class="headerlink" title="的⻓度"></a>的⻓度</h4><h4 id="channel-read-buffer-：将数据读入到buffer中。"><a href="#channel-read-buffer-：将数据读入到buffer中。" class="headerlink" title="channel.read(buffer)：将数据读入到buffer中。"></a>channel.read(buffer)：将数据读入到buffer中。</h4><h4 id="从Buffer中读取数据"><a href="#从Buffer中读取数据" class="headerlink" title="从Buffer中读取数据"></a>从Buffer中读取数据</h4><h4 id="从Buffer中读取数据有以下几种方式："><a href="#从Buffer中读取数据有以下几种方式：" class="headerlink" title="从Buffer中读取数据有以下几种方式："></a>从Buffer中读取数据有以下几种方式：</h4><h4 id="get相关的方法：获得当前position或指定position的数据"><a href="#get相关的方法：获得当前position或指定position的数据" class="headerlink" title="get相关的方法：获得当前position或指定position的数据"></a>get相关的方法：获得当前position或指定position的数据</h4><h4 id="array-：返回整个数组内容"><a href="#array-：返回整个数组内容" class="headerlink" title="array()：返回整个数组内容"></a>array()：返回整个数组内容</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 ByteBuffer buffer = ByteBuffer.allocate(1024);</span><br></pre></td></tr></table></figure><h4 id="channel-write-buffer-：使用channel获得buffer中的内容并写入到指定目标"><a href="#channel-write-buffer-：使用channel获得buffer中的内容并写入到指定目标" class="headerlink" title="channel.write(buffer)：使用channel获得buffer中的内容并写入到指定目标"></a>channel.write(buffer)：使用channel获得buffer中的内容并写入到指定目标</h4><h2 id="5-缓冲区分类"><a href="#5-缓冲区分类" class="headerlink" title="5.缓冲区分类"></a>5.缓冲区分类</h2><h4 id="子缓冲区"><a href="#子缓冲区" class="headerlink" title="子缓冲区"></a>子缓冲区</h4><h4 id="可以为Buffer创建子缓冲区，在现有缓冲区上分割出一块空间作为新的缓冲区。原"><a href="#可以为Buffer创建子缓冲区，在现有缓冲区上分割出一块空间作为新的缓冲区。原" class="headerlink" title="可以为Buffer创建子缓冲区，在现有缓冲区上分割出一块空间作为新的缓冲区。原"></a>可以为Buffer创建子缓冲区，在现有缓冲区上分割出一块空间作为新的缓冲区。原</h4><h4 id="缓冲区和子缓冲区共享同一片数据空间。"><a href="#缓冲区和子缓冲区共享同一片数据空间。" class="headerlink" title="缓冲区和子缓冲区共享同一片数据空间。"></a>缓冲区和子缓冲区共享同一片数据空间。</h4><h4 id="通过调用slice方法创建子缓冲区-。"><a href="#通过调用slice方法创建子缓冲区-。" class="headerlink" title="通过调用slice方法创建子缓冲区 。"></a>通过调用slice方法创建子缓冲区 。</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">package com.qf.channel.buffer;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import java.nio.ByteBuffer;</span><br><span class="line">import java.util.Arrays;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 子缓冲区</span><br><span class="line">* @author htt</span><br><span class="line">* doublepeach</span><br><span class="line">*/</span><br><span class="line">public class Demo1 &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">ByteBuffer buffer = ByteBuffer.wrap(new byte[]&#123; 1 , 2 , 3 , 4 ,</span><br><span class="line">5 , 6 , 7 , 8 , 9 &#125;);</span><br><span class="line">//设置position</span><br><span class="line">buffer.position( 4 );</span><br><span class="line">//设置limit</span><br><span class="line">buffer.limit( 8 );</span><br><span class="line">//获得子缓冲区</span><br><span class="line">ByteBuffer slice = buffer.slice();</span><br><span class="line">slice.put( 0 ,(byte) 50 );</span><br><span class="line">buffer.position( 0 );</span><br><span class="line">buffer.limit(buffer.capacity());</span><br><span class="line">byte[] array = buffer.array();</span><br></pre></td></tr></table></figure><h5 id="-18"><a href="#-18" class="headerlink" title></a></h5><h4 id="只读缓冲区"><a href="#只读缓冲区" class="headerlink" title="只读缓冲区"></a>只读缓冲区</h4><h4 id="通过buffer的asReadOnlyBuffer-方法获得一个新的只读缓冲区，所谓的只读缓冲区"><a href="#通过buffer的asReadOnlyBuffer-方法获得一个新的只读缓冲区，所谓的只读缓冲区" class="headerlink" title="通过buffer的asReadOnlyBuffer()方法获得一个新的只读缓冲区，所谓的只读缓冲区"></a>通过buffer的asReadOnlyBuffer()方法获得一个新的只读缓冲区，所谓的只读缓冲区</h4><h4 id="就是只能读不能写。只读缓冲区与原缓冲区共享同一片数据空间，原缓冲区数据发"><a href="#就是只能读不能写。只读缓冲区与原缓冲区共享同一片数据空间，原缓冲区数据发" class="headerlink" title="就是只能读不能写。只读缓冲区与原缓冲区共享同一片数据空间，原缓冲区数据发"></a>就是只能读不能写。只读缓冲区与原缓冲区共享同一片数据空间，原缓冲区数据发</h4><h4 id="生改变，只读缓冲区也能看到变化后的数据，因为它们共享同一片存储空间。"><a href="#生改变，只读缓冲区也能看到变化后的数据，因为它们共享同一片存储空间。" class="headerlink" title="生改变，只读缓冲区也能看到变化后的数据，因为它们共享同一片存储空间。"></a>生改变，只读缓冲区也能看到变化后的数据，因为它们共享同一片存储空间。</h4><h4 id="直接缓冲区"><a href="#直接缓冲区" class="headerlink" title="直接缓冲区"></a>直接缓冲区</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(&quot;buffer:&quot;+ Arrays.toString(array));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="-19"><a href="#-19" class="headerlink" title></a></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">package com.qf.channel.buffer;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import java.nio.ByteBuffer;</span><br><span class="line">import java.util.Arrays;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 只读缓冲区</span><br><span class="line">* @author htt</span><br><span class="line">* doublepeach</span><br><span class="line">*/</span><br><span class="line">public class Demo2 &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">ByteBuffer buffer = ByteBuffer.wrap(new byte[]&#123; 1 , 2 , 3 , 4 ,</span><br><span class="line">5 , 6 , 7 , 8 , 9 &#125;);</span><br><span class="line">ByteBuffer readOnlyBuffer = buffer.asReadOnlyBuffer();</span><br><span class="line">buffer.put( 4 ,(byte) 50 );</span><br><span class="line">while(readOnlyBuffer.hasRemaining())&#123;</span><br><span class="line">System.out.println(readOnlyBuffer.get());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="-20"><a href="#-20" class="headerlink" title></a></h5><h4 id="直接缓冲区，Java虚拟机将尽最大努力直接对其执行本机I-x2F-O操作。也就是说，它将"><a href="#直接缓冲区，Java虚拟机将尽最大努力直接对其执行本机I-x2F-O操作。也就是说，它将" class="headerlink" title="直接缓冲区，Java虚拟机将尽最大努力直接对其执行本机I&#x2F;O操作。也就是说，它将"></a>直接缓冲区，Java虚拟机将尽最大努力直接对其执行本机I&#x2F;O操作。也就是说，它将</h4><h4 id="试图避免在每次调用底层操作系统的本机I-x2F-O操作之前（或之后），将缓冲区的内容"><a href="#试图避免在每次调用底层操作系统的本机I-x2F-O操作之前（或之后），将缓冲区的内容" class="headerlink" title="试图避免在每次调用底层操作系统的本机I&#x2F;O操作之前（或之后），将缓冲区的内容"></a>试图避免在每次调用底层操作系统的本机I&#x2F;O操作之前（或之后），将缓冲区的内容</h4><h4 id="复制到中间缓冲区（或从中间缓冲区复制）。"><a href="#复制到中间缓冲区（或从中间缓冲区复制）。" class="headerlink" title="复制到中间缓冲区（或从中间缓冲区复制）。"></a>复制到中间缓冲区（或从中间缓冲区复制）。</h4><h4 id="可以通过调用此类的allocateDirect工厂方法来创建直接字节缓冲区。此方法返回的"><a href="#可以通过调用此类的allocateDirect工厂方法来创建直接字节缓冲区。此方法返回的" class="headerlink" title="可以通过调用此类的allocateDirect工厂方法来创建直接字节缓冲区。此方法返回的"></a>可以通过调用此类的allocateDirect工厂方法来创建直接字节缓冲区。此方法返回的</h4><h4 id="缓冲区通常比非直接缓冲区具有更高的分配和释放成本。直接缓冲区的内容可能位"><a href="#缓冲区通常比非直接缓冲区具有更高的分配和释放成本。直接缓冲区的内容可能位" class="headerlink" title="缓冲区通常比非直接缓冲区具有更高的分配和释放成本。直接缓冲区的内容可能位"></a>缓冲区通常比非直接缓冲区具有更高的分配和释放成本。直接缓冲区的内容可能位</h4><h4 id="于正常垃圾收集堆之外，因此它们对应用程序内存占用的影响可能不明显。"><a href="#于正常垃圾收集堆之外，因此它们对应用程序内存占用的影响可能不明显。" class="headerlink" title="于正常垃圾收集堆之外，因此它们对应用程序内存占用的影响可能不明显。"></a>于正常垃圾收集堆之外，因此它们对应用程序内存占用的影响可能不明显。</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">package com.qf.channel.buffer;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileNotFoundException;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.nio.ByteBuffer;</span><br><span class="line">import java.nio.channels.FileChannel;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 直接缓冲区</span><br><span class="line">* @author htt</span><br><span class="line">* doublepeach</span><br><span class="line">*/</span><br><span class="line">public class Demo3 &#123;</span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">FileInputStream fis = new FileInputStream(&quot;1.txt&quot;);</span><br><span class="line">FileChannel fisChannel = fis.getChannel();</span><br><span class="line">FileOutputStream fos = new FileOutputStream(&quot;7.txt&quot;);</span><br><span class="line">FileChannel fosChannel = fos.getChannel();</span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocateDirect( 1024 );</span><br><span class="line">int len = 0 ;</span><br><span class="line">while((len = fisChannel.read(buffer))&gt; 0 )&#123;</span><br><span class="line">buffer.flip();</span><br><span class="line">fosChannel.write(buffer);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;复制完毕&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="-21"><a href="#-21" class="headerlink" title></a></h5><h4 id="基于内存映射的Buffer"><a href="#基于内存映射的Buffer" class="headerlink" title="基于内存映射的Buffer"></a>基于内存映射的Buffer</h4><h4 id="MappedByteBuffer采用direct-buffer的方式读写文件内容-这种方式就是内存映射。"><a href="#MappedByteBuffer采用direct-buffer的方式读写文件内容-这种方式就是内存映射。" class="headerlink" title="MappedByteBuffer采用direct buffer的方式读写文件内容,这种方式就是内存映射。"></a>MappedByteBuffer采用direct buffer的方式读写文件内容,这种方式就是内存映射。</h4><h4 id="这种方式直接调用系统底层的缓存-没有JVM和系统之间的复制操作，所以效率非常"><a href="#这种方式直接调用系统底层的缓存-没有JVM和系统之间的复制操作，所以效率非常" class="headerlink" title="这种方式直接调用系统底层的缓存,没有JVM和系统之间的复制操作，所以效率非常"></a>这种方式直接调用系统底层的缓存,没有JVM和系统之间的复制操作，所以效率非常</h4><h4 id="高，主要用于操作大文件。"><a href="#高，主要用于操作大文件。" class="headerlink" title="高，主要用于操作大文件。"></a>高，主要用于操作大文件。</h4><h4 id="通过FileChannel的map方法得到MappedByteBuffer，MappedByteBuffer把磁盘中文"><a href="#通过FileChannel的map方法得到MappedByteBuffer，MappedByteBuffer把磁盘中文" class="headerlink" title="通过FileChannel的map方法得到MappedByteBuffer，MappedByteBuffer把磁盘中文"></a>通过FileChannel的map方法得到MappedByteBuffer，MappedByteBuffer把磁盘中文</h4><h4 id="件的内容映射到计算机的虚拟内存中，操作MappedByteBuffer直接操作内存中的数"><a href="#件的内容映射到计算机的虚拟内存中，操作MappedByteBuffer直接操作内存中的数" class="headerlink" title="件的内容映射到计算机的虚拟内存中，操作MappedByteBuffer直接操作内存中的数"></a>件的内容映射到计算机的虚拟内存中，操作MappedByteBuffer直接操作内存中的数</h4><h4 id="据，而无需每次通过IO来读取物理磁盘中的文件，效率极高。"><a href="#据，而无需每次通过IO来读取物理磁盘中的文件，效率极高。" class="headerlink" title="据，而无需每次通过IO来读取物理磁盘中的文件，效率极高。"></a>据，而无需每次通过IO来读取物理磁盘中的文件，效率极高。</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">package com.qf.channel.buffer;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.RandomAccessFile;</span><br><span class="line">import java.nio.ByteBuffer;</span><br><span class="line">import java.nio.MappedByteBuffer;</span><br><span class="line">import java.nio.channels.FileChannel;</span><br><span class="line">import java.util.Arrays;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 内存映射缓冲区</span><br><span class="line">* @author htt</span><br><span class="line">* doublepeach</span><br><span class="line">*/</span><br><span class="line">public class Demo4 &#123;</span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">File file = new File(&quot;1.txt&quot;);</span><br><span class="line">RandomAccessFile fis = new RandomAccessFile(file,&quot;rw&quot;);</span><br><span class="line">FileChannel fisChannel = fis.getChannel();</span><br><span class="line">MappedByteBuffer mappedByteBuffer =</span><br><span class="line">fisChannel.map(FileChannel.MapMode.READ_ONLY, 0 ,file.length());</span><br><span class="line">while(mappedByteBuffer.hasRemaining())&#123;</span><br><span class="line">System.out.print((char)mappedByteBuffer.get());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="-22"><a href="#-22" class="headerlink" title></a></h5><h1 id="五、NIO-Selector详解"><a href="#五、NIO-Selector详解" class="headerlink" title="五、NIO-Selector详解"></a>五、NIO-Selector详解</h1><h2 id="1-Selector概述"><a href="#1-Selector概述" class="headerlink" title="1.Selector概述"></a>1.Selector概述</h2><h4 id="Selector选择器，也可以称为多路复用器。它是Java-NIO的核心组件之一，用于检查"><a href="#Selector选择器，也可以称为多路复用器。它是Java-NIO的核心组件之一，用于检查" class="headerlink" title="Selector选择器，也可以称为多路复用器。它是Java NIO的核心组件之一，用于检查"></a>Selector选择器，也可以称为多路复用器。它是Java NIO的核心组件之一，用于检查</h4><h4 id="一个或多个Channel的状态是否处于可读、可写、可连接、可接收等。通过一个"><a href="#一个或多个Channel的状态是否处于可读、可写、可连接、可接收等。通过一个" class="headerlink" title="一个或多个Channel的状态是否处于可读、可写、可连接、可接收等。通过一个"></a>一个或多个Channel的状态是否处于可读、可写、可连接、可接收等。通过一个</h4><h4 id="Selector选择器管理多个Channel，可以实现一个线程管理多个Channel对应的网络"><a href="#Selector选择器管理多个Channel，可以实现一个线程管理多个Channel对应的网络" class="headerlink" title="Selector选择器管理多个Channel，可以实现一个线程管理多个Channel对应的网络"></a>Selector选择器管理多个Channel，可以实现一个线程管理多个Channel对应的网络</h4><h4 id="连接。使用单线程管理多个Channel可以避免多线程的线程上下文切换带来的额外"><a href="#连接。使用单线程管理多个Channel可以避免多线程的线程上下文切换带来的额外" class="headerlink" title="连接。使用单线程管理多个Channel可以避免多线程的线程上下文切换带来的额外"></a>连接。使用单线程管理多个Channel可以避免多线程的线程上下文切换带来的额外</h4><h4 id="开销。"><a href="#开销。" class="headerlink" title="开销。"></a>开销。</h4><h2 id="2-SelectableChannel可选择通道"><a href="#2-SelectableChannel可选择通道" class="headerlink" title="2.SelectableChannel可选择通道"></a>2.SelectableChannel可选择通道</h2><h4 id="只有SelectableChannel才能被Selector管理，比如所有的Socket通道。而FileChannel"><a href="#只有SelectableChannel才能被Selector管理，比如所有的Socket通道。而FileChannel" class="headerlink" title="只有SelectableChannel才能被Selector管理，比如所有的Socket通道。而FileChannel"></a>只有SelectableChannel才能被Selector管理，比如所有的Socket通道。而FileChannel</h4><h4 id="并没有继承SelectableChannel，因此不能被Selector管理。"><a href="#并没有继承SelectableChannel，因此不能被Selector管理。" class="headerlink" title="并没有继承SelectableChannel，因此不能被Selector管理。"></a>并没有继承SelectableChannel，因此不能被Selector管理。</h4><h2 id="3-Channel注册到Selector上"><a href="#3-Channel注册到Selector上" class="headerlink" title="3.Channel注册到Selector上"></a>3.Channel注册到Selector上</h2><h5 id="27"><a href="#27" class="headerlink" title="27 }"></a>27 }</h5><h5 id="28"><a href="#28" class="headerlink" title="28"></a>28</h5><h4 id="Channel通过注册的方式关联Selector。一个Channel可以注册到多个Selector上，但"><a href="#Channel通过注册的方式关联Selector。一个Channel可以注册到多个Selector上，但" class="headerlink" title="Channel通过注册的方式关联Selector。一个Channel可以注册到多个Selector上，但"></a>Channel通过注册的方式关联Selector。一个Channel可以注册到多个Selector上，但</h4><h4 id="在某一个Selector上只能注册一次。注册时需要告知Selector，Selector需要对通道"><a href="#在某一个Selector上只能注册一次。注册时需要告知Selector，Selector需要对通道" class="headerlink" title="在某一个Selector上只能注册一次。注册时需要告知Selector，Selector需要对通道"></a>在某一个Selector上只能注册一次。注册时需要告知Selector，Selector需要对通道</h4><h4 id="的哪个操作感兴趣。"><a href="#的哪个操作感兴趣。" class="headerlink" title="的哪个操作感兴趣。"></a>的哪个操作感兴趣。</h4><h4 id="通道的操作如下："><a href="#通道的操作如下：" class="headerlink" title="通道的操作如下："></a>通道的操作如下：</h4><h4 id="可读：SelectionKey-OP-READ"><a href="#可读：SelectionKey-OP-READ" class="headerlink" title="可读：SelectionKey.OP_READ"></a>可读：SelectionKey.OP_READ</h4><h4 id="可写：SelectionKey-OP-WRITE"><a href="#可写：SelectionKey-OP-WRITE" class="headerlink" title="可写：SelectionKey.OP_WRITE"></a>可写：SelectionKey.OP_WRITE</h4><h4 id="可连接：SelectionKey-OP-CONNECT"><a href="#可连接：SelectionKey-OP-CONNECT" class="headerlink" title="可连接：SelectionKey.OP_CONNECT"></a>可连接：SelectionKey.OP_CONNECT</h4><h4 id="可接收：SelectionKey-OP-ACCEPT"><a href="#可接收：SelectionKey-OP-ACCEPT" class="headerlink" title="可接收：SelectionKey.OP_ACCEPT"></a>可接收：SelectionKey.OP_ACCEPT</h4><h4 id="比如channel调用register方法进行注册到Selector，并告知Selector对哪个操作感兴"><a href="#比如channel调用register方法进行注册到Selector，并告知Selector对哪个操作感兴" class="headerlink" title="比如channel调用register方法进行注册到Selector，并告知Selector对哪个操作感兴"></a>比如channel调用register方法进行注册到Selector，并告知Selector对哪个操作感兴</h4><h4 id="趣："><a href="#趣：" class="headerlink" title="趣："></a>趣：</h4><h4 id="也可以同时注册多个操作："><a href="#也可以同时注册多个操作：" class="headerlink" title="也可以同时注册多个操作："></a>也可以同时注册多个操作：</h4><h4 id="选择器会查询每个一个channel的操作事件，如果是该channel注册的操作已就绪，"><a href="#选择器会查询每个一个channel的操作事件，如果是该channel注册的操作已就绪，" class="headerlink" title="选择器会查询每个一个channel的操作事件，如果是该channel注册的操作已就绪，"></a>选择器会查询每个一个channel的操作事件，如果是该channel注册的操作已就绪，</h4><h4 id="则进行响应。注意，这里channel的操作指的是channel完成某个操作的条件，表示"><a href="#则进行响应。注意，这里channel的操作指的是channel完成某个操作的条件，表示" class="headerlink" title="则进行响应。注意，这里channel的操作指的是channel完成某个操作的条件，表示"></a>则进行响应。注意，这里channel的操作指的是channel完成某个操作的条件，表示</h4><h4 id="该channel对于该操作已处于就绪状态。比如ServerSocketChannel已准备好接收新"><a href="#该channel对于该操作已处于就绪状态。比如ServerSocketChannel已准备好接收新" class="headerlink" title="该channel对于该操作已处于就绪状态。比如ServerSocketChannel已准备好接收新"></a>该channel对于该操作已处于就绪状态。比如ServerSocketChannel已准备好接收新</h4><h4 id="的连接，那么它注册的SelectionKey-OP-ACCEPT操作就处于就绪状态。又比如"><a href="#的连接，那么它注册的SelectionKey-OP-ACCEPT操作就处于就绪状态。又比如" class="headerlink" title="的连接，那么它注册的SelectionKey.OP_ACCEPT操作就处于就绪状态。又比如"></a>的连接，那么它注册的SelectionKey.OP_ACCEPT操作就处于就绪状态。又比如</h4><h4 id="SocketChannel已准备好去连接Server服务器，那么它注册的"><a href="#SocketChannel已准备好去连接Server服务器，那么它注册的" class="headerlink" title="SocketChannel已准备好去连接Server服务器，那么它注册的"></a>SocketChannel已准备好去连接Server服务器，那么它注册的</h4><h4 id="SelectionKey-OP-CONNECT操作就处于就绪状态。于是Selector就可以触发之后"><a href="#SelectionKey-OP-CONNECT操作就处于就绪状态。于是Selector就可以触发之后" class="headerlink" title="SelectionKey.OP_CONNECT操作就处于就绪状态。于是Selector就可以触发之后"></a>SelectionKey.OP_CONNECT操作就处于就绪状态。于是Selector就可以触发之后</h4><h4 id="的动作。"><a href="#的动作。" class="headerlink" title="的动作。"></a>的动作。</h4><h2 id="4-SelectionKey选择键"><a href="#4-SelectionKey选择键" class="headerlink" title="4.SelectionKey选择键"></a>4.SelectionKey选择键</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public final SelectionKey register(Selector sel, int ops)</span><br><span class="line">throws ClosedChannelException</span><br><span class="line">&#123;</span><br><span class="line">return register(sel, ops, null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="-23"><a href="#-23" class="headerlink" title></a></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 channel.register(selector,SelectionKey.OP_READ);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">channel.register(selector,SelectionKey.OP_READ |</span><br><span class="line">SelectionKey.OP_WRITE);</span><br></pre></td></tr></table></figure><h5 id="-24"><a href="#-24" class="headerlink" title></a></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">܉᲋රᙙJavaරᎸᴺ ̓ݩռلဳىJavaຝ຅຾̈́ӥ᫹ಅํ᧞ᑕդᎱ᧞կ݊ૡٍ ᦏದ๞ࢧ୭๜ᧆํጱᕍᶉѺ</span><br></pre></td></tr></table></figure><h2 id="4-SelectionKey选择键-1"><a href="#4-SelectionKey选择键-1" class="headerlink" title="4.SelectionKey选择键"></a>4.SelectionKey选择键</h2><h4 id="SelectionKey封装了Channel和注册的操作。"><a href="#SelectionKey封装了Channel和注册的操作。" class="headerlink" title="SelectionKey封装了Channel和注册的操作。"></a>SelectionKey封装了Channel和注册的操作。</h4><h4 id="当Selector调用select-方法时，会轮询所有注册在它身上的Channel，查看是否有处"><a href="#当Selector调用select-方法时，会轮询所有注册在它身上的Channel，查看是否有处" class="headerlink" title="当Selector调用select()方法时，会轮询所有注册在它身上的Channel，查看是否有处"></a>当Selector调用select()方法时，会轮询所有注册在它身上的Channel，查看是否有处</h4><h4 id="于某个操作（已注册到selector上的）就绪状态的Channel，把这些Channel放入到"><a href="#于某个操作（已注册到selector上的）就绪状态的Channel，把这些Channel放入到" class="headerlink" title="于某个操作（已注册到selector上的）就绪状态的Channel，把这些Channel放入到"></a>于某个操作（已注册到selector上的）就绪状态的Channel，把这些Channel放入到</h4><h4 id="SelectionKey的集合中。"><a href="#SelectionKey的集合中。" class="headerlink" title="SelectionKey的集合中。"></a>SelectionKey的集合中。</h4><h2 id="5-Selector的使用"><a href="#5-Selector的使用" class="headerlink" title="5.Selector的使用"></a>5.Selector的使用</h2><h4 id="创建Selector"><a href="#创建Selector" class="headerlink" title="创建Selector"></a>创建Selector</h4><h4 id="通过Selector的open方法创建Selector对象。"><a href="#通过Selector的open方法创建Selector对象。" class="headerlink" title="通过Selector的open方法创建Selector对象。"></a>通过Selector的open方法创建Selector对象。</h4><h4 id="Channel注册到Selector上"><a href="#Channel注册到Selector上" class="headerlink" title="Channel注册到Selector上"></a>Channel注册到Selector上</h4><h4 id="Channel必须处于非阻塞模式才能注册到Selector上。"><a href="#Channel必须处于非阻塞模式才能注册到Selector上。" class="headerlink" title="Channel必须处于非阻塞模式才能注册到Selector上。"></a>Channel必须处于非阻塞模式才能注册到Selector上。</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//创建Selector</span><br><span class="line">Selector selector = Selector.open();</span><br></pre></td></tr></table></figure><h5 id="-25"><a href="#-25" class="headerlink" title></a></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">package com.qf.selector;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line">import java.net.InetSocketAddress;</span><br><span class="line">import java.nio.channels.SelectionKey;</span><br><span class="line">import java.nio.channels.Selector;</span><br><span class="line">import java.nio.channels.ServerSocketChannel;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* Selector的使用</span><br><span class="line">* @author htt</span><br><span class="line">* doublepeach</span><br><span class="line">*/</span><br><span class="line">public class Demo1 &#123;</span><br><span class="line">public static void main(String[] args) throws IOException &#123;</span><br></pre></td></tr></table></figure><h5 id="-26"><a href="#-26" class="headerlink" title></a></h5><h4 id="Selector轮询就绪状态的Channel"><a href="#Selector轮询就绪状态的Channel" class="headerlink" title="Selector轮询就绪状态的Channel"></a>Selector轮询就绪状态的Channel</h4><h4 id="Selector通过调用select方法轮询已就绪的通道操作。select方法是阻塞的，直到至"><a href="#Selector通过调用select方法轮询已就绪的通道操作。select方法是阻塞的，直到至" class="headerlink" title="Selector通过调用select方法轮询已就绪的通道操作。select方法是阻塞的，直到至"></a>Selector通过调用select方法轮询已就绪的通道操作。select方法是阻塞的，直到至</h4><h4 id="少有一个通道的注册操作已就绪。当完成select方法调用后，被选中的已就绪的所"><a href="#少有一个通道的注册操作已就绪。当完成select方法调用后，被选中的已就绪的所" class="headerlink" title="少有一个通道的注册操作已就绪。当完成select方法调用后，被选中的已就绪的所"></a>少有一个通道的注册操作已就绪。当完成select方法调用后，被选中的已就绪的所</h4><h4 id="有channel通过Selector的selectedKeys-方法获得，该方法获得的是一个"><a href="#有channel通过Selector的selectedKeys-方法获得，该方法获得的是一个" class="headerlink" title="有channel通过Selector的selectedKeys()方法获得，该方法获得的是一个"></a>有channel通过Selector的selectedKeys()方法获得，该方法获得的是一个</h4><h4 id="SelectionKey集合，其中每一个SelectionKey都表示一个Channel。于是可以根据"><a href="#SelectionKey集合，其中每一个SelectionKey都表示一个Channel。于是可以根据" class="headerlink" title="SelectionKey集合，其中每一个SelectionKey都表示一个Channel。于是可以根据"></a>SelectionKey集合，其中每一个SelectionKey都表示一个Channel。于是可以根据</h4><h4 id="SelectionKey的注册操作来做具体的业务处理。"><a href="#SelectionKey的注册操作来做具体的业务处理。" class="headerlink" title="SelectionKey的注册操作来做具体的业务处理。"></a>SelectionKey的注册操作来做具体的业务处理。</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//创建Selector</span><br><span class="line">Selector selector = Selector.open();</span><br><span class="line">//创建ServerSocketChannel</span><br><span class="line">ServerSocketChannel serverSocketChannel =</span><br><span class="line">ServerSocketChannel.open();</span><br><span class="line">//设置为非阻塞模式</span><br><span class="line">serverSocketChannel.configureBlocking(false);</span><br><span class="line">//绑定端口</span><br><span class="line">serverSocketChannel.bind(new InetSocketAddress( 9001 ));</span><br><span class="line">//注册channel并指明注册的操作</span><br><span class="line">SelectionKey selectionKey =</span><br><span class="line">serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="-27"><a href="#-27" class="headerlink" title></a></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">package com.qf.selector;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line">import java.net.InetSocketAddress;</span><br><span class="line">import java.nio.channels.SelectionKey;</span><br><span class="line">import java.nio.channels.Selector;</span><br><span class="line">import java.nio.channels.ServerSocketChannel;</span><br><span class="line">import java.util.Iterator;</span><br><span class="line">import java.util.Set;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* @author htt</span><br><span class="line">* doublepeach</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><h5 id="-28"><a href="#-28" class="headerlink" title></a></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public class Demo2 &#123;</span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">//创建Selector</span><br><span class="line">Selector selector = Selector.open();</span><br><span class="line">//创建ServerSocketChannel</span><br><span class="line">ServerSocketChannel serverSocketChannel =</span><br><span class="line">ServerSocketChannel.open();</span><br><span class="line">//设置为非阻塞模式</span><br><span class="line">serverSocketChannel.configureBlocking(false);</span><br><span class="line">//绑定端口</span><br><span class="line">serverSocketChannel.bind(new InetSocketAddress( 9001 ));</span><br><span class="line">//注册channel并指明注册的操作</span><br><span class="line">SelectionKey selectionKey =</span><br><span class="line">serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">while(true)&#123;</span><br><span class="line">//阻塞等待某个操作就绪状态的Channel</span><br><span class="line">selector.select();</span><br><span class="line">//获得这一次发生操作的多个channel的集合</span><br><span class="line">Set&lt;SelectionKey&gt; selectionKeys =</span><br><span class="line">selector.selectedKeys();</span><br><span class="line">//获得集合的迭代器</span><br><span class="line">Iterator&lt;SelectionKey&gt; iterator =</span><br><span class="line">selectionKeys.iterator();</span><br><span class="line">//遍历集合</span><br><span class="line">while(iterator.hasNext())&#123;</span><br><span class="line">SelectionKey key = iterator.next();</span><br><span class="line">if(key.isReadable())&#123;</span><br><span class="line">//处理读状态的业务</span><br><span class="line">&#125;else if(key.isWritable())&#123;</span><br><span class="line">//处理写状态的业务</span><br><span class="line">&#125;else if(key.isAcceptable())&#123;</span><br><span class="line">//处理接收状态的业务</span><br><span class="line">&#125;else if(key.isConnectable())&#123;</span><br><span class="line">//处理连接状态的业务</span><br><span class="line">&#125;</span><br><span class="line">//保证下次channel就绪可以再被选中</span><br><span class="line">iterator.remove();</span><br></pre></td></tr></table></figure><h5 id="-29"><a href="#-29" class="headerlink" title></a></h5><h2 id="6-Selector示例"><a href="#6-Selector示例" class="headerlink" title="6.Selector示例"></a>6.Selector示例</h2><h4 id="实现NIO通信的客户端"><a href="#实现NIO通信的客户端" class="headerlink" title="实现NIO通信的客户端"></a>实现NIO通信的客户端</h4><h5 id="-30"><a href="#-30" class="headerlink" title></a></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">package com.qf.selector;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line">import java.net.InetSocketAddress;</span><br><span class="line">import java.nio.ByteBuffer;</span><br><span class="line">import java.nio.channels.SocketChannel;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 客户端实现</span><br><span class="line">* @author htt</span><br><span class="line">* doublepeach</span><br><span class="line">*/</span><br><span class="line">public class NIOClient &#123;</span><br><span class="line">public static void main(String[] args) throws IOException &#123;</span><br><span class="line">//创建Channel</span><br></pre></td></tr></table></figure><h5 id="-31"><a href="#-31" class="headerlink" title></a></h5><h4 id="实现NIO通信的服务端"><a href="#实现NIO通信的服务端" class="headerlink" title="实现NIO通信的服务端"></a>实现NIO通信的服务端</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">SocketChannel socketChannel = SocketChannel.open(new</span><br><span class="line">InetSocketAddress(&quot;127.0.0.1&quot;, 9001 ));</span><br><span class="line">//设置非阻塞模式</span><br><span class="line">socketChannel.configureBlocking(false);</span><br><span class="line">//创建buffer</span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate( 1024 );</span><br><span class="line">//buffer中写入数据</span><br><span class="line">buffer.put(&quot;hello selector&quot;.getBytes());</span><br><span class="line">//将buffer中的数据写入通道</span><br><span class="line">buffer.flip();</span><br><span class="line">socketChannel.write(buffer);</span><br><span class="line">//关闭</span><br><span class="line">socketChannel.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="-32"><a href="#-32" class="headerlink" title></a></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">package com.qf.selector;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line">import java.net.InetSocketAddress;</span><br><span class="line">import java.nio.ByteBuffer;</span><br><span class="line">import java.nio.channels.*;</span><br><span class="line">import java.util.Iterator;</span><br><span class="line">import java.util.Set;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 服务端</span><br><span class="line">* @author htt</span><br><span class="line">* doublepeach</span><br><span class="line">*/</span><br><span class="line">public class NIOServer &#123;</span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">//获得Channel</span><br><span class="line">ServerSocketChannel serverSocketChannel =</span><br><span class="line">ServerSocketChannel.open();</span><br></pre></td></tr></table></figure><h5 id="-33"><a href="#-33" class="headerlink" title></a></h5><h5 id="x2F-x2F-设置成非阻塞的模式"><a href="#x2F-x2F-设置成非阻塞的模式" class="headerlink" title="&#x2F;&#x2F;设置成非阻塞的模式"></a>&#x2F;&#x2F;设置成非阻塞的模式</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">serverSocketChannel.configureBlocking(false);</span><br><span class="line">//绑定端口号</span><br><span class="line">serverSocketChannel.bind(new InetSocketAddress( 9001 ));</span><br><span class="line">//获得selector</span><br><span class="line">Selector selector = Selector.open();</span><br><span class="line">//注册channel到selector上</span><br><span class="line">serverSocketChannel.register(selector,</span><br><span class="line">SelectionKey.OP_ACCEPT);</span><br><span class="line">//选择器轮询监听</span><br><span class="line">while(true)&#123;</span><br><span class="line">//阻塞等待通道就绪</span><br><span class="line">selector.select();</span><br><span class="line">Set&lt;SelectionKey&gt; selectionKeys =</span><br><span class="line">selector.selectedKeys();</span><br><span class="line">//遍历selectionKeys</span><br><span class="line">Iterator&lt;SelectionKey&gt; iterator =</span><br><span class="line">selectionKeys.iterator();</span><br><span class="line">while(iterator.hasNext())&#123;</span><br><span class="line">SelectionKey key = iterator.next();</span><br><span class="line">if(key.isAcceptable())&#123;</span><br><span class="line">//准备好接收客户端的连接</span><br><span class="line">//通过key获得channel，并且强转成</span><br><span class="line">ServerSocketChannel</span><br><span class="line">ServerSocketChannel channel =</span><br><span class="line">(ServerSocketChannel) key.channel();</span><br><span class="line">//调用channel的accept方法获得SocketChannel</span><br><span class="line">SocketChannel socketChannel =</span><br><span class="line">channel.accept();</span><br><span class="line">//设置成非阻塞</span><br><span class="line">socketChannel.configureBlocking(false);</span><br><span class="line">//将channel注册到selector上，并让selector对读感兴</span><br><span class="line">趣，为下次读数据做准备</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">socketChannel.register(selector,SelectionKey.OP_READ);</span><br><span class="line">&#125;else if(key.isReadable())&#123;</span><br><span class="line">//准备好读取数据</span><br></pre></td></tr></table></figure><h5 id="-34"><a href="#-34" class="headerlink" title></a></h5><h1 id="六、NIO包中的其他类"><a href="#六、NIO包中的其他类" class="headerlink" title="六、NIO包中的其他类"></a>六、NIO包中的其他类</h1><h2 id="1-Pipe"><a href="#1-Pipe" class="headerlink" title="1.Pipe"></a>1.Pipe</h2><h4 id="Java-NIO包中提供了Pipe类，用来实现两个线程之间的单向数据连接。Pipe类中有"><a href="#Java-NIO包中提供了Pipe类，用来实现两个线程之间的单向数据连接。Pipe类中有" class="headerlink" title="Java NIO包中提供了Pipe类，用来实现两个线程之间的单向数据连接。Pipe类中有"></a>Java NIO包中提供了Pipe类，用来实现两个线程之间的单向数据连接。Pipe类中有</h4><h4 id="两个Channel，分别是Sink-Channel和Source-Channel。"><a href="#两个Channel，分别是Sink-Channel和Source-Channel。" class="headerlink" title="两个Channel，分别是Sink Channel和Source Channel。"></a>两个Channel，分别是Sink Channel和Source Channel。</h4><h4 id="Sink-Channel：线程将数据写入到Sink-Channel"><a href="#Sink-Channel：线程将数据写入到Sink-Channel" class="headerlink" title="Sink Channel：线程将数据写入到Sink Channel"></a>Sink Channel：线程将数据写入到Sink Channel</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//通过key获得channel，并且强转成SocketChannel</span><br><span class="line">SocketChannel socketChannel = (SocketChannel)</span><br><span class="line">key.channel();</span><br><span class="line">//设置成非阻塞</span><br><span class="line">socketChannel.configureBlocking(false);</span><br><span class="line">//创建Buffer</span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate( 1024 );</span><br><span class="line">//读数据</span><br><span class="line">int len = 0 ;</span><br><span class="line">while((len = socketChannel.read(buffer))&gt; 0 )&#123;</span><br><span class="line">buffer.flip();</span><br><span class="line">System.out.println(new</span><br><span class="line">String(buffer.array(), 0 ,len));</span><br><span class="line">buffer.clear();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//删除key</span><br><span class="line">iterator.remove();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="-35"><a href="#-35" class="headerlink" title></a></h5><h4 id="Source-Channel：线程从Source-Channel中获取数据"><a href="#Source-Channel：线程从Source-Channel中获取数据" class="headerlink" title="Source Channel：线程从Source Channel中获取数据"></a>Source Channel：线程从Source Channel中获取数据</h4><h4 id="具体的两个线程通过Pipe管道实现数据传输的例子如下："><a href="#具体的两个线程通过Pipe管道实现数据传输的例子如下：" class="headerlink" title="具体的两个线程通过Pipe管道实现数据传输的例子如下："></a>具体的两个线程通过Pipe管道实现数据传输的例子如下：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">package com.qf.other;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line">import java.nio.ByteBuffer;</span><br><span class="line">import java.nio.channels.Pipe;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* @author htt</span><br><span class="line">* doublepeach</span><br><span class="line">*/</span><br><span class="line">public class PipeDemo &#123;</span><br><span class="line">public static void main(String[] args) throws IOException &#123;</span><br><span class="line">//获得pipe</span><br><span class="line">Pipe pipe = Pipe.open();</span><br><span class="line">//负责写的线程</span><br><span class="line">Thread t1 = new Thread1(pipe);</span><br><span class="line">//负责读的线程</span><br><span class="line">Thread t2 = new Thread2(pipe);</span><br><span class="line">//开启线程</span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class Thread1 extends Thread&#123;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private Pipe pipe;</span><br><span class="line">public Thread1(Pipe pipe)&#123;</span><br><span class="line">this.pipe = pipe;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">try &#123;</span><br></pre></td></tr></table></figure><h5 id="-36"><a href="#-36" class="headerlink" title></a></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//创建Buffer</span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate( 1024 );</span><br><span class="line">buffer.put(&quot;hello pipe&quot;.getBytes());</span><br><span class="line">buffer.flip();</span><br><span class="line">//获得SinkChannel</span><br><span class="line">Pipe.SinkChannel sinkChannel = pipe.sink();</span><br><span class="line">//将数据写入SinkChannel</span><br><span class="line">sinkChannel.write(buffer);</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class Thread2 extends Thread&#123;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private Pipe pipe;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public Thread2(Pipe pipe) &#123;</span><br><span class="line">this.pipe = pipe;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">try &#123;</span><br><span class="line">//获得SourceChannel</span><br><span class="line">Pipe.SourceChannel sourceChannel = pipe.source();</span><br><span class="line">//创建buffer</span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate( 1024 );</span><br><span class="line">int len = 0 ;</span><br><span class="line">while((len = sourceChannel.read(buffer))&gt; 0 )&#123;</span><br><span class="line">buffer.flip();</span><br><span class="line">//显示buffer中的数据</span><br><span class="line">System.out.println(new</span><br><span class="line">String(buffer.array(), 0 ,len));</span><br><span class="line">&#125;</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br></pre></td></tr></table></figure><h5 id="-37"><a href="#-37" class="headerlink" title></a></h5><h2 id="2-FileLock"><a href="#2-FileLock" class="headerlink" title="2.FileLock"></a>2.FileLock</h2><h4 id="FileLock表示文件锁，通过JVM进程对要操作的文件上锁，在同一时间只允许一个进"><a href="#FileLock表示文件锁，通过JVM进程对要操作的文件上锁，在同一时间只允许一个进" class="headerlink" title="FileLock表示文件锁，通过JVM进程对要操作的文件上锁，在同一时间只允许一个进"></a>FileLock表示文件锁，通过JVM进程对要操作的文件上锁，在同一时间只允许一个进</h4><h4 id="程访问上锁的文件。FileLock文件锁是进程级别，在同一个进程中的多个线程可以"><a href="#程访问上锁的文件。FileLock文件锁是进程级别，在同一个进程中的多个线程可以" class="headerlink" title="程访问上锁的文件。FileLock文件锁是进程级别，在同一个进程中的多个线程可以"></a>程访问上锁的文件。FileLock文件锁是进程级别，在同一个进程中的多个线程可以</h4><h4 id="同时对文件进行操作。"><a href="#同时对文件进行操作。" class="headerlink" title="同时对文件进行操作。"></a>同时对文件进行操作。</h4><h4 id="FileLock文件锁又分成了排它锁和共享锁。"><a href="#FileLock文件锁又分成了排它锁和共享锁。" class="headerlink" title="FileLock文件锁又分成了排它锁和共享锁。"></a>FileLock文件锁又分成了排它锁和共享锁。</h4><h4 id="排它锁：只有获得锁的进程能读写文件。"><a href="#排它锁：只有获得锁的进程能读写文件。" class="headerlink" title="排它锁：只有获得锁的进程能读写文件。"></a>排它锁：只有获得锁的进程能读写文件。</h4><h4 id="共享锁：获得锁的线程可以读文件，但不能写文件。"><a href="#共享锁：获得锁的线程可以读文件，但不能写文件。" class="headerlink" title="共享锁：获得锁的线程可以读文件，但不能写文件。"></a>共享锁：获得锁的线程可以读文件，但不能写文件。</h4><h4 id="具体的实现案例："><a href="#具体的实现案例：" class="headerlink" title="具体的实现案例："></a>具体的实现案例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="-38"><a href="#-38" class="headerlink" title></a></h5><h5 id="x2F-x2F-获得排它锁方式一：阻塞方式获得锁，如果锁被其他进程持有则阻塞"><a href="#x2F-x2F-获得排它锁方式一：阻塞方式获得锁，如果锁被其他进程持有则阻塞" class="headerlink" title="&#x2F;&#x2F;获得排它锁方式一：阻塞方式获得锁，如果锁被其他进程持有则阻塞"></a>&#x2F;&#x2F;获得排它锁方式一：阻塞方式获得锁，如果锁被其他进程持有则阻塞</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">FileLock fileLock = fisChannel.lock();</span><br><span class="line">//获得排它锁方式二：参数1:锁文件的具体哪一部分内容的起始位置，参数2:⻓度，</span><br><span class="line">参数3:是否共享</span><br><span class="line">fisChannel.lock( 0 ,file.length(),false);</span><br><span class="line">//获得排它锁方式三：非阻塞的方式获得锁，如果锁被其他进程持有则直接返回</span><br><span class="line">null，不阻塞</span><br><span class="line">FileLock fileLock = fisChannel.tryLock();</span><br><span class="line">//获得排它锁方式四：非阻塞的方式获得锁</span><br><span class="line">FileLock fileLock = fisChannel.tryLock( 0 ,file.length(),false);</span><br></pre></td></tr></table></figure><h5 id="1-2-3-4-5-6-7-8"><a href="#1-2-3-4-5-6-7-8" class="headerlink" title="1 2 3 4 5 6 7 8"></a>1 2 3 4 5 6 7 8</h5><h5 id="x2F-x2F-获得共享锁方，参数1-锁文件的具体哪一部分内容的起始位置，参数2-⻓度，参数"><a href="#x2F-x2F-获得共享锁方，参数1-锁文件的具体哪一部分内容的起始位置，参数2-⻓度，参数" class="headerlink" title="&#x2F;&#x2F;获得共享锁方，参数1:锁文件的具体哪一部分内容的起始位置，参数2:⻓度，参数"></a>&#x2F;&#x2F;获得共享锁方，参数1:锁文件的具体哪一部分内容的起始位置，参数2:⻓度，参数</h5><h5 id="3-是否共享"><a href="#3-是否共享" class="headerlink" title="3:是否共享"></a>3:是否共享</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fisChannel.lock( 0 ,file.length(),true)</span><br><span class="line">//获得排它锁方式三：非阻塞的方式获得锁，如果锁被其他进程持有则直接返回</span><br><span class="line">null，不阻塞</span><br><span class="line">FileLock fileLock = fisChannel.tryLock( 0 ,file.length(),true);</span><br></pre></td></tr></table></figure><h5 id="-39"><a href="#-39" class="headerlink" title></a></h5><h4 id="进程一：获得锁后阻塞"><a href="#进程一：获得锁后阻塞" class="headerlink" title="进程一：获得锁后阻塞"></a>进程一：获得锁后阻塞</h4><h4 id="进程二：尝试获得锁并写数据"><a href="#进程二：尝试获得锁并写数据" class="headerlink" title="进程二：尝试获得锁并写数据"></a>进程二：尝试获得锁并写数据</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">package com.qf.other;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileNotFoundException;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.nio.channels.FileChannel;</span><br><span class="line">import java.nio.channels.FileLock;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* FileLock文件锁</span><br><span class="line">* @author htt</span><br><span class="line">* doublepeach</span><br><span class="line">*/</span><br><span class="line">public class FileLockDemo1 &#123;</span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">File file = new File(&quot;1.txt&quot;);</span><br><span class="line">FileOutputStream fis = new FileOutputStream(file);</span><br><span class="line">//获得FileChannel</span><br><span class="line">FileChannel fisChannel = fis.getChannel();</span><br><span class="line">//获得拍它锁</span><br><span class="line">FileLock fileLock = fisChannel.lock();</span><br><span class="line">Thread.sleep(100000l);</span><br><span class="line">fileLock.release();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="-40"><a href="#-40" class="headerlink" title></a></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">package com.qf.other;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.nio.ByteBuffer;</span><br></pre></td></tr></table></figure><h5 id="-41"><a href="#-41" class="headerlink" title></a></h5><h2 id="3-Path"><a href="#3-Path" class="headerlink" title="3.Path"></a>3.Path</h2><h4 id="Path类在JDK7中已经加入到NIO包内，Path表示文件系统中的路径，和java的io包下"><a href="#Path类在JDK7中已经加入到NIO包内，Path表示文件系统中的路径，和java的io包下" class="headerlink" title="Path类在JDK7中已经加入到NIO包内，Path表示文件系统中的路径，和java的io包下"></a>Path类在JDK7中已经加入到NIO包内，Path表示文件系统中的路径，和java的io包下</h4><h4 id="的File类十分相似。"><a href="#的File类十分相似。" class="headerlink" title="的File类十分相似。"></a>的File类十分相似。</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import java.nio.channels.FileChannel;</span><br><span class="line">import java.nio.channels.FileLock;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* FileLock文件锁</span><br><span class="line">* @author htt</span><br><span class="line">* doublepeach</span><br><span class="line">*/</span><br><span class="line">public class FileLockDemo2 &#123;</span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">File file = new File(&quot;1.txt&quot;);</span><br><span class="line">FileOutputStream fis = new FileOutputStream(file);</span><br><span class="line">//获得FileChannel</span><br><span class="line">FileChannel fisChannel = fis.getChannel();</span><br><span class="line">//获得拍它锁</span><br><span class="line">FileLock fileLock = fisChannel.lock();</span><br><span class="line">fisChannel.write(ByteBuffer.wrap(&quot;hello</span><br><span class="line">lock&quot;.getBytes()));</span><br><span class="line">System.out.println(&quot;写入完毕&quot;);</span><br><span class="line">//释放锁</span><br><span class="line">fileLock.release();</span><br><span class="line">fisChannel.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="-42"><a href="#-42" class="headerlink" title></a></h5><h4 id="Path可以表示绝对路径，即盘符在内的完整路径。Path也可以表示相对路径，即相"><a href="#Path可以表示绝对路径，即盘符在内的完整路径。Path也可以表示相对路径，即相" class="headerlink" title="Path可以表示绝对路径，即盘符在内的完整路径。Path也可以表示相对路径，即相"></a>Path可以表示绝对路径，即盘符在内的完整路径。Path也可以表示相对路径，即相</h4><h4 id="对于其他路径的文件或目录的路径。"><a href="#对于其他路径的文件或目录的路径。" class="headerlink" title="对于其他路径的文件或目录的路径。"></a>对于其他路径的文件或目录的路径。</h4><h2 id="4-Files"><a href="#4-Files" class="headerlink" title="4.Files"></a>4.Files</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">package com.qf.other;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import java.nio.file.Path;</span><br><span class="line">import java.nio.file.Paths;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* Path</span><br><span class="line">* @author htt</span><br><span class="line">* doublepeach</span><br><span class="line">*/</span><br><span class="line">public class PathDemo &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">//创建相对路径</span><br><span class="line">Path path = Paths.get(&quot;1.txt&quot;);</span><br><span class="line">//判断是否是绝对路径</span><br><span class="line">System.out.println(path.isAbsolute());</span><br><span class="line">Path path1 = Paths.get(&quot;/Documents/io-demo/1.txt&quot;);</span><br><span class="line">System.out.println(path1.isAbsolute());</span><br><span class="line">//创建Path的另一种方式</span><br><span class="line">Path path2 = Paths.get(&quot;/Documents/io-demo/&quot;, &quot;2.txt&quot;);</span><br><span class="line">System.out.println(path2.isAbsolute());</span><br><span class="line">//获得父文件夹路径</span><br><span class="line">System.out.println(path1.getParent());</span><br><span class="line">//获得文件名</span><br><span class="line">System.out.println(path1.getFileName());</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="-43"><a href="#-43" class="headerlink" title></a></h5><h4 id="NIO包中的Files类提供了操作文件及目录的一些常用方法。Files需要和Path一起使"><a href="#NIO包中的Files类提供了操作文件及目录的一些常用方法。Files需要和Path一起使" class="headerlink" title="NIO包中的Files类提供了操作文件及目录的一些常用方法。Files需要和Path一起使"></a>NIO包中的Files类提供了操作文件及目录的一些常用方法。Files需要和Path一起使</h4><h4 id="用。"><a href="#用。" class="headerlink" title="用。"></a>用。</h4><h4 id="创建目录的方法：createDirectory"><a href="#创建目录的方法：createDirectory" class="headerlink" title="创建目录的方法：createDirectory()"></a>创建目录的方法：createDirectory()</h4><h4 id="根据Path对象创建一个新目录"><a href="#根据Path对象创建一个新目录" class="headerlink" title="根据Path对象创建一个新目录"></a>根据Path对象创建一个新目录</h4><h4 id="拷⻉文件：copy"><a href="#拷⻉文件：copy" class="headerlink" title="拷⻉文件：copy()"></a>拷⻉文件：copy()</h4><h4 id="实现拷⻉文件的功能，可以通过可选的参数实现文件的覆盖。"><a href="#实现拷⻉文件的功能，可以通过可选的参数实现文件的覆盖。" class="headerlink" title="实现拷⻉文件的功能，可以通过可选的参数实现文件的覆盖。"></a>实现拷⻉文件的功能，可以通过可选的参数实现文件的覆盖。</h4><h4 id="移动文件：move"><a href="#移动文件：move" class="headerlink" title="移动文件：move()"></a>移动文件：move()</h4><h4 id="将文件移动到另一个目录内，如果移动到了同级目录，则为重命名的效果。"><a href="#将文件移动到另一个目录内，如果移动到了同级目录，则为重命名的效果。" class="headerlink" title="将文件移动到另一个目录内，如果移动到了同级目录，则为重命名的效果。"></a>将文件移动到另一个目录内，如果移动到了同级目录，则为重命名的效果。</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">Path path = Paths.get(&quot;myDir&quot;);</span><br><span class="line">//创建目录</span><br><span class="line">Files.createDirectory(path);</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="-44"><a href="#-44" class="headerlink" title></a></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">Path srcPath = Paths.get(&quot;1.txt&quot;);</span><br><span class="line">Path destPath = Paths.get(&quot;9.txt&quot;);</span><br><span class="line">// Files.copy(srcPath,destPath);</span><br><span class="line">//覆盖已存在的文件</span><br><span class="line">Files.copy(srcPath,destPath,</span><br><span class="line">StandardCopyOption.REPLACE_EXISTING);</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="-45"><a href="#-45" class="headerlink" title></a></h5><h4 id="删除文件：delete"><a href="#删除文件：delete" class="headerlink" title="删除文件：delete()"></a>删除文件：delete()</h4><h4 id="删除指定文件。"><a href="#删除指定文件。" class="headerlink" title="删除指定文件。"></a>删除指定文件。</h4><h4 id="遍历目录：walkFileTree"><a href="#遍历目录：walkFileTree" class="headerlink" title="遍历目录：walkFileTree()"></a>遍历目录：walkFileTree()</h4><h4 id="通过walkFileTree-Path-path-FileVisitor-fv-方法可以实现目录的遍历，"><a href="#通过walkFileTree-Path-path-FileVisitor-fv-方法可以实现目录的遍历，" class="headerlink" title="通过walkFileTree(Path path,FileVisitor fv)方法可以实现目录的遍历，"></a>通过walkFileTree(Path path,FileVisitor fv)方法可以实现目录的遍历，</h4><h4 id="通过提供FileVisitor接口的实现类对象来告知遍历文件的具体措施。其中通过返回的"><a href="#通过提供FileVisitor接口的实现类对象来告知遍历文件的具体措施。其中通过返回的" class="headerlink" title="通过提供FileVisitor接口的实现类对象来告知遍历文件的具体措施。其中通过返回的"></a>通过提供FileVisitor接口的实现类对象来告知遍历文件的具体措施。其中通过返回的</h4><h4 id="FileVisitResult告知遍历每一个文件时的具体下一步动作是什么，比如：继续"><a href="#FileVisitResult告知遍历每一个文件时的具体下一步动作是什么，比如：继续" class="headerlink" title="FileVisitResult告知遍历每一个文件时的具体下一步动作是什么，比如：继续"></a>FileVisitResult告知遍历每一个文件时的具体下一步动作是什么，比如：继续</h4><h4 id="（CONTINUE）、终止（TERMINATE）、跳过同级（SKIP-SIBLING）、跳过子级"><a href="#（CONTINUE）、终止（TERMINATE）、跳过同级（SKIP-SIBLING）、跳过子级" class="headerlink" title="（CONTINUE）、终止（TERMINATE）、跳过同级（SKIP_SIBLING）、跳过子级"></a>（CONTINUE）、终止（TERMINATE）、跳过同级（SKIP_SIBLING）、跳过子级</h4><h4 id="（SKIP-SUBTREE）。"><a href="#（SKIP-SUBTREE）。" class="headerlink" title="（SKIP_SUBTREE）。"></a>（SKIP_SUBTREE）。</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">Path srcPath = Paths.get(&quot;1.txt&quot;);</span><br><span class="line">Path destPath = Paths.get(&quot;11.txt&quot;);</span><br><span class="line">Files.move(srcPath,destPath);</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="-46"><a href="#-46" class="headerlink" title></a></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">Path path = Paths.get(&quot;11.txt&quot;);</span><br><span class="line">Files.delete(path);</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="-47"><a href="#-47" class="headerlink" title></a></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Path path = Paths.get(&quot;myDir&quot;);</span><br><span class="line">Files.walkFileTree(path,new SimpleFileVisitor&lt;Path&gt;()&#123;</span><br><span class="line">//具体的遍历操作</span><br><span class="line">@Override</span><br><span class="line">public FileVisitResult visitFile(Path file,</span><br><span class="line">BasicFileAttributes attrs) throws IOException &#123;</span><br><span class="line">//获得当前文件的文件名</span><br><span class="line">String fileName = file.getFileName().toString();</span><br><span class="line">if(&quot;2.txt&quot;.equals(fileName))&#123;</span><br><span class="line">//如果找到则返回文件的绝对路径</span><br></pre></td></tr></table></figure><h5 id="-48"><a href="#-48" class="headerlink" title></a></h5><h2 id="5-AsynchronousFileChannel"><a href="#5-AsynchronousFileChannel" class="headerlink" title="5.AsynchronousFileChannel"></a>5.AsynchronousFileChannel</h2><h4 id="在Java7中加入了支持异步操作的文件通道AsynchronousFileChannel，首先要理解"><a href="#在Java7中加入了支持异步操作的文件通道AsynchronousFileChannel，首先要理解" class="headerlink" title="在Java7中加入了支持异步操作的文件通道AsynchronousFileChannel，首先要理解"></a>在Java7中加入了支持异步操作的文件通道AsynchronousFileChannel，首先要理解</h4><h4 id="什么是异步操作。所谓的异步，就是在对文件读写的过程中，程序不需要等待文件"><a href="#什么是异步操作。所谓的异步，就是在对文件读写的过程中，程序不需要等待文件" class="headerlink" title="什么是异步操作。所谓的异步，就是在对文件读写的过程中，程序不需要等待文件"></a>什么是异步操作。所谓的异步，就是在对文件读写的过程中，程序不需要等待文件</h4><h4 id="读写完毕，就可以直接执行之后的代码。可以设置监听程序执行读写完毕之后的操"><a href="#读写完毕，就可以直接执行之后的代码。可以设置监听程序执行读写完毕之后的操" class="headerlink" title="读写完毕，就可以直接执行之后的代码。可以设置监听程序执行读写完毕之后的操"></a>读写完毕，就可以直接执行之后的代码。可以设置监听程序执行读写完毕之后的操</h4><h4 id="作。"><a href="#作。" class="headerlink" title="作。"></a>作。</h4><h4 id="创建异步文件通道"><a href="#创建异步文件通道" class="headerlink" title="创建异步文件通道"></a>创建异步文件通道</h4><h4 id="第一个参数是要异步操作的文件路径，第二个参数是指明使用读操作。"><a href="#第一个参数是要异步操作的文件路径，第二个参数是指明使用读操作。" class="headerlink" title="第一个参数是要异步操作的文件路径，第二个参数是指明使用读操作。"></a>第一个参数是要异步操作的文件路径，第二个参数是指明使用读操作。</h4><h4 id="读取数据的方式一：获得Future的读"><a href="#读取数据的方式一：获得Future的读" class="headerlink" title="读取数据的方式一：获得Future的读"></a>读取数据的方式一：获得Future的读</h4><h4 id="通过异步的读数据，返回Future对象，读数据过程中立即返回Future对象，即时读"><a href="#通过异步的读数据，返回Future对象，读数据过程中立即返回Future对象，即时读" class="headerlink" title="通过异步的读数据，返回Future对象，读数据过程中立即返回Future对象，即时读"></a>通过异步的读数据，返回Future对象，读数据过程中立即返回Future对象，即时读</h4><h4 id="操作还未完成。可以通过Future对象中的isDone-方法得知读操作是否已完成。"><a href="#操作还未完成。可以通过Future对象中的isDone-方法得知读操作是否已完成。" class="headerlink" title="操作还未完成。可以通过Future对象中的isDone()方法得知读操作是否已完成。"></a>操作还未完成。可以通过Future对象中的isDone()方法得知读操作是否已完成。</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(&quot;find</span><br><span class="line">2.txt:&quot;+file.toAbsolutePath());</span><br><span class="line">//终止遍历</span><br><span class="line">return FileVisitResult.TERMINATE;</span><br><span class="line">&#125;</span><br><span class="line">//继续遍历</span><br><span class="line">return FileVisitResult.CONTINUE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="-49"><a href="#-49" class="headerlink" title></a></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Path path = Paths.get(&quot;7.txt&quot;);</span><br><span class="line">AsynchronousFileChannel asyncFileChannel =</span><br><span class="line">AsynchronousFileChannel.open(path, StandardOpenOption.READ);</span><br></pre></td></tr></table></figure><h5 id="-50"><a href="#-50" class="headerlink" title></a></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">package com.qf.other;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line">import java.nio.ByteBuffer;</span><br><span class="line">import java.nio.channels.AsynchronousFileChannel;</span><br><span class="line">import java.nio.file.Path;</span><br></pre></td></tr></table></figure><h5 id="-51"><a href="#-51" class="headerlink" title></a></h5><h4 id="读取数据的方式二：使用异步监听的方式"><a href="#读取数据的方式二：使用异步监听的方式" class="headerlink" title="读取数据的方式二：使用异步监听的方式"></a>读取数据的方式二：使用异步监听的方式</h4><h4 id="当读取完成后，会调用CompletionHandler对象的completed方法，在方法中做读取"><a href="#当读取完成后，会调用CompletionHandler对象的completed方法，在方法中做读取" class="headerlink" title="当读取完成后，会调用CompletionHandler对象的completed方法，在方法中做读取"></a>当读取完成后，会调用CompletionHandler对象的completed方法，在方法中做读取</h4><h4 id="数据完毕后的操作。"><a href="#数据完毕后的操作。" class="headerlink" title="数据完毕后的操作。"></a>数据完毕后的操作。</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import java.nio.file.Paths;</span><br><span class="line">import java.nio.file.StandardOpenOption;</span><br><span class="line">import java.util.concurrent.Future;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* AsynchronousFileChannel</span><br><span class="line">* @author htt</span><br><span class="line">* doublepeach</span><br><span class="line">*/</span><br><span class="line">public class AsyncFileChannelDemo &#123;</span><br><span class="line">public static void main(String[] args) throws IOException &#123;</span><br><span class="line">//创建AsynchronousFileChannel</span><br><span class="line">Path path = Paths.get(&quot;7.txt&quot;);</span><br><span class="line">AsynchronousFileChannel asyncFileChannel =</span><br><span class="line">AsynchronousFileChannel.open(path, StandardOpenOption.READ);</span><br><span class="line">//创建buffer</span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate( 1024 );</span><br><span class="line">//读取数据到buffer中</span><br><span class="line">Future&lt;Integer&gt; future = asyncFileChannel.read(buffer, 0 );</span><br><span class="line">//循环等待，直到读完为止，这也是异步的体现</span><br><span class="line">while(!future.isDone());</span><br><span class="line">//翻转buffer</span><br><span class="line">buffer.flip();</span><br><span class="line">//打印数据</span><br><span class="line">System.out.println(new String(buffer.array()));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="-52"><a href="#-52" class="headerlink" title></a></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">package com.qf.other;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line">import java.nio.ByteBuffer;</span><br><span class="line">import java.nio.channels.AsynchronousFileChannel;</span><br></pre></td></tr></table></figure><h5 id="-53"><a href="#-53" class="headerlink" title></a></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import java.nio.channels.CompletionHandler;</span><br><span class="line">import java.nio.file.Path;</span><br><span class="line">import java.nio.file.Paths;</span><br><span class="line">import java.nio.file.StandardOpenOption;</span><br><span class="line">import java.util.concurrent.Future;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* AsynchronousFileChannel</span><br><span class="line">* @author htt</span><br><span class="line">* doublepeach</span><br><span class="line">*/</span><br><span class="line">public class AsyncFileChannelDemo2 &#123;</span><br><span class="line">public static void main(String[] args) throws IOException &#123;</span><br><span class="line">//创建AsynchronousFileChannel</span><br><span class="line">Path path = Paths.get(&quot;9.txt&quot;);</span><br><span class="line">AsynchronousFileChannel asyncFileChannel =</span><br><span class="line">AsynchronousFileChannel.open(path, StandardOpenOption.READ);</span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate( 1024 );</span><br><span class="line">asyncFileChannel.read(buffer, 0 , buffer, new</span><br><span class="line">CompletionHandler&lt;Integer, ByteBuffer&gt;() &#123;</span><br><span class="line">@Override</span><br><span class="line">public void completed(Integer result, ByteBuffer</span><br><span class="line">attachment) &#123;</span><br><span class="line">//返回读取的字节个数</span><br><span class="line">System.out.println(&quot;result:&quot;+result);</span><br><span class="line">//打印读取内容</span><br><span class="line">attachment.flip();</span><br><span class="line">System.out.println(new</span><br><span class="line">String(attachment.array()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void failed(Throwable exc, ByteBuffer</span><br><span class="line">attachment) &#123;</span><br><span class="line">System.out.println(&quot;failed&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="-54"><a href="#-54" class="headerlink" title></a></h5><h4 id="写入数据的方式一：获得Future的写"><a href="#写入数据的方式一：获得Future的写" class="headerlink" title="写入数据的方式一：获得Future的写"></a>写入数据的方式一：获得Future的写</h4><h4 id="通过异步的写数据，返回Future对象，写数据过程中立即返回Future对象，即时写"><a href="#通过异步的写数据，返回Future对象，写数据过程中立即返回Future对象，即时写" class="headerlink" title="通过异步的写数据，返回Future对象，写数据过程中立即返回Future对象，即时写"></a>通过异步的写数据，返回Future对象，写数据过程中立即返回Future对象，即时写</h4><h4 id="操作还未完成。可以通过Future对象中的isDone-方法得知写操作是否已完成。"><a href="#操作还未完成。可以通过Future对象中的isDone-方法得知写操作是否已完成。" class="headerlink" title="操作还未完成。可以通过Future对象中的isDone()方法得知写操作是否已完成。"></a>操作还未完成。可以通过Future对象中的isDone()方法得知写操作是否已完成。</h4><h5 id="x2F-x2F-为了查看效果，让程序等待异步的执行结果"><a href="#x2F-x2F-为了查看效果，让程序等待异步的执行结果" class="headerlink" title="&#x2F;&#x2F;为了查看效果，让程序等待异步的执行结果"></a>&#x2F;&#x2F;为了查看效果，让程序等待异步的执行结果</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">Thread.sleep(10000l);</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="-55"><a href="#-55" class="headerlink" title></a></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">package com.qf.other;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line">import java.nio.ByteBuffer;</span><br><span class="line">import java.nio.channels.AsynchronousFileChannel;</span><br><span class="line">import java.nio.file.Path;</span><br><span class="line">import java.nio.file.Paths;</span><br><span class="line">import java.nio.file.StandardOpenOption;</span><br><span class="line">import java.util.concurrent.Future;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* AsynchronousFileChannel的写</span><br><span class="line">* @author htt</span><br><span class="line">* doublepeach</span><br><span class="line">*/</span><br><span class="line">public class AsyncFileChannelDemo3 &#123;</span><br><span class="line">public static void main(String[] args) throws IOException &#123;</span><br><span class="line">//创建AsynchronousFileChannel,注意，文件必须存在</span><br><span class="line">Path path = Paths.get(&quot;11.txt&quot;);</span><br><span class="line">AsynchronousFileChannel asyncFileChannel =</span><br><span class="line">AsynchronousFileChannel.open(path, StandardOpenOption.WRITE);</span><br><span class="line">//创建buffer</span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate( 1024 );</span><br></pre></td></tr></table></figure><h5 id="-56"><a href="#-56" class="headerlink" title></a></h5><h4 id="写入数据的方式二：使用异步监听的方式"><a href="#写入数据的方式二：使用异步监听的方式" class="headerlink" title="写入数据的方式二：使用异步监听的方式"></a>写入数据的方式二：使用异步监听的方式</h4><h4 id="当写数据完成后，会调用CompletionHandler对象的completed方法，在方法中做写"><a href="#当写数据完成后，会调用CompletionHandler对象的completed方法，在方法中做写" class="headerlink" title="当写数据完成后，会调用CompletionHandler对象的completed方法，在方法中做写"></a>当写数据完成后，会调用CompletionHandler对象的completed方法，在方法中做写</h4><h4 id="数据完毕后的操作。-1"><a href="#数据完毕后的操作。-1" class="headerlink" title="数据完毕后的操作。"></a>数据完毕后的操作。</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">buffer.put(&quot;hello async file channel&quot;.getBytes());</span><br><span class="line">buffer.flip();</span><br><span class="line">//写数据</span><br><span class="line">Future&lt;Integer&gt; future = asyncFileChannel.write(buffer,</span><br><span class="line">0 );</span><br><span class="line">//循环等待，直到写完为止，这也是异步的体现</span><br><span class="line">while(!future.isDone());</span><br><span class="line">System.out.println(&quot;写入完成&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">package com.qf.other;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line">import java.nio.ByteBuffer;</span><br><span class="line">import java.nio.channels.AsynchronousFileChannel;</span><br><span class="line">import java.nio.channels.CompletionHandler;</span><br><span class="line">import java.nio.file.Path;</span><br><span class="line">import java.nio.file.Paths;</span><br><span class="line">import java.nio.file.StandardOpenOption;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* AsynchronousFileChannel</span><br><span class="line">* @author htt</span><br><span class="line">* doublepeach</span><br><span class="line">*/</span><br><span class="line">public class AsyncFileChannelDemo4 &#123;</span><br><span class="line">public static void main(String[] args) throws IOException &#123;</span><br><span class="line">//创建AsynchronousFileChannel</span><br><span class="line">Path path = Paths.get(&quot;11.txt&quot;);</span><br><span class="line">AsynchronousFileChannel asyncFileChannel =</span><br><span class="line">AsynchronousFileChannel.open(path, StandardOpenOption.WRITE);</span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate( 1024 );</span><br></pre></td></tr></table></figure><h5 id="-57"><a href="#-57" class="headerlink" title></a></h5><h1 id="七、NIO综合案例-聊天室"><a href="#七、NIO综合案例-聊天室" class="headerlink" title="七、NIO综合案例-聊天室"></a>七、NIO综合案例-聊天室</h1><h2 id="1-聊天室服务端编写"><a href="#1-聊天室服务端编写" class="headerlink" title="1.聊天室服务端编写"></a>1.聊天室服务端编写</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">buffer.put(&quot;hello file channel async&quot;.getBytes());</span><br><span class="line">buffer.flip();</span><br><span class="line">asyncFileChannel.write(buffer, 0 , buffer, new</span><br><span class="line">CompletionHandler&lt;Integer, ByteBuffer&gt;() &#123;</span><br><span class="line">@Override</span><br><span class="line">public void completed(Integer result, ByteBuffer</span><br><span class="line">attachment) &#123;</span><br><span class="line">//返回写入的字节个数</span><br><span class="line">System.out.println(&quot;result:&quot;+result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void failed(Throwable exc, ByteBuffer</span><br><span class="line">attachment) &#123;</span><br><span class="line">System.out.println(&quot;failed&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">//为了查看效果，让程序等待异步的执行结果</span><br><span class="line">try &#123;</span><br><span class="line">Thread.sleep(10000l);</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">܉᲋රᙙJavaරᎸᴺ ̓ݩռلဳىJavaຝ຅຾̈́ӥ᫹ಅํ᧞ᑕդᎱ᧞կ݊ૡٍ ᦏದ๞ࢧ୭๜ᧆํጱᕍᶉѺ</span><br></pre></td></tr></table></figure><h2 id="1-聊天室服务端编写-1"><a href="#1-聊天室服务端编写-1" class="headerlink" title="1.聊天室服务端编写"></a>1.聊天室服务端编写</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">package com.qf.chat.server;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line">import java.net.InetSocketAddress;</span><br><span class="line">import java.nio.ByteBuffer;</span><br><span class="line">import java.nio.channels.*;</span><br><span class="line">import java.nio.charset.StandardCharsets;</span><br><span class="line">import java.util.Iterator;</span><br><span class="line">import java.util.Set;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* @author htt</span><br><span class="line">* doublepeach</span><br><span class="line">*/</span><br><span class="line">public class ChatServer &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">//创建ServerSocketChannel</span><br><span class="line">ServerSocketChannel serverSocketChannel =</span><br><span class="line">ServerSocketChannel.open();</span><br><span class="line">//绑定端口</span><br><span class="line">serverSocketChannel.bind(new</span><br><span class="line">InetSocketAddress( 9001 ));</span><br><span class="line">//设置成非阻塞模式</span><br><span class="line">serverSocketChannel.configureBlocking(false);</span><br><span class="line">//获得Selector</span><br><span class="line">Selector selector = Selector.open();</span><br><span class="line">//注册Channel到Selector上,并让Selector对接收操作感兴趣</span><br><span class="line">serverSocketChannel.register(selector,</span><br><span class="line">SelectionKey.OP_ACCEPT);</span><br><span class="line">System.out.println(&quot;聊天室服务器已启动&quot;);</span><br><span class="line">//循环等待新客户端的连接</span><br><span class="line">while(true)&#123;</span><br><span class="line">//获得当前已处于就绪状态的Channel的数量</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">int select = selector.select();</span><br><span class="line">if(select== 0 )&#123;</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">//获得就绪状态的Channel集合</span><br><span class="line">Set&lt;SelectionKey&gt; selectionKeys =</span><br><span class="line">selector.selectedKeys();</span><br><span class="line">//遍历Channel集合</span><br><span class="line">Iterator&lt;SelectionKey&gt; iterator =</span><br><span class="line">selectionKeys.iterator();</span><br><span class="line">while(iterator.hasNext())&#123;</span><br><span class="line">SelectionKey key = iterator.next();</span><br><span class="line">//判断channel属于哪个就绪动作</span><br><span class="line">if(key.isAcceptable())&#123;</span><br><span class="line">//有客户端发送连接请求,处理连接请求</span><br><span class="line">handleAccept(key);</span><br><span class="line">&#125;</span><br><span class="line">if(key.isReadable())&#123;</span><br><span class="line">//有客户端向服务端写数据，读取数据</span><br><span class="line">handleRead(key);</span><br><span class="line">&#125;</span><br><span class="line">//移除当前key</span><br><span class="line">iterator.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="-58"><a href="#-58" class="headerlink" title="}"></a>}</h5><h5 id="x2F-1"><a href="#x2F-1" class="headerlink" title="&#x2F;**"></a>&#x2F;**</h5><h5 id="处理客户端写数据的请求——服务端处于读操作的就绪状态"><a href="#处理客户端写数据的请求——服务端处于读操作的就绪状态" class="headerlink" title="* 处理客户端写数据的请求——服务端处于读操作的就绪状态"></a>* 处理客户端写数据的请求——服务端处于读操作的就绪状态</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* @param key</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">private static void handleRead(SelectionKey key) &#123;</span><br><span class="line">//获得SocketChannel</span><br><span class="line">SocketChannel socketChannel = (SocketChannel)</span><br><span class="line">key.channel();</span><br><span class="line">//获得Selector</span><br><span class="line">Selector selector = key.selector();</span><br><span class="line">//创建Buffer</span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate( 1024 );</span><br><span class="line">try &#123;</span><br><span class="line">//读取数据到buffer中</span><br><span class="line">int len = 0 ;</span><br><span class="line">String message = &quot;&quot;;</span><br><span class="line">while((len = socketChannel.read(buffer))&gt; 0 )&#123;</span><br><span class="line">buffer.flip();</span><br><span class="line">//封装message</span><br><span class="line">message += new</span><br><span class="line">String(buffer.array(), 0 ,len,StandardCharsets.UTF_8);</span><br><span class="line">&#125;</span><br><span class="line">//把客户端发送的消息，广播给所有客户端</span><br><span class="line">if(message.length()&gt; 0 )&#123;</span><br><span class="line">//服务端本地打印消息</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(socketChannel.getRemoteAddress()+&quot;:&quot;+message)</span><br><span class="line">;</span><br><span class="line">//广播消息</span><br><span class="line">handleMessage(message,key);</span><br><span class="line">&#125;</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 广播消息给其他客户端</span><br><span class="line">* @param message</span><br></pre></td></tr></table></figure><h5 id="-59"><a href="#-59" class="headerlink" title></a></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">* @param key</span><br><span class="line">*/</span><br><span class="line">private static void handleMessage(String message,</span><br><span class="line">SelectionKey key) &#123;</span><br><span class="line">//获得selector</span><br><span class="line">Selector selector = key.selector();</span><br><span class="line">//获得所有注册的channel</span><br><span class="line">Set&lt;SelectionKey&gt; keys = selector.keys();</span><br><span class="line">//遍历</span><br><span class="line">for (SelectionKey selectionKey : keys) &#123;</span><br><span class="line">//获得channel</span><br><span class="line">SelectableChannel channel = selectionKey.channel();</span><br><span class="line">//不发给自己</span><br><span class="line">if(channel != key.channel() &amp;&amp; channel instanceof</span><br><span class="line">SocketChannel)&#123;</span><br><span class="line">SocketChannel socketChannel = (SocketChannel)</span><br><span class="line">channel;</span><br><span class="line">try &#123;</span><br><span class="line">//发送消息</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">socketChannel.write(ByteBuffer.wrap(message.getBytes(StandardCha</span><br><span class="line">rsets.UTF_8)));</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 处理客户端的连接请求</span><br><span class="line">* @param key</span><br><span class="line">*/</span><br><span class="line">private static void handleAccept(SelectionKey key) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">//获得ServerSocketChannel</span><br></pre></td></tr></table></figure><h5 id="-60"><a href="#-60" class="headerlink" title></a></h5><h2 id="2-聊天室客户端编写"><a href="#2-聊天室客户端编写" class="headerlink" title="2.聊天室客户端编写"></a>2.聊天室客户端编写</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ServerSocketChannel channel = (ServerSocketChannel)</span><br><span class="line">key.channel();</span><br><span class="line">//获得selector</span><br><span class="line">Selector selector = key.selector();</span><br><span class="line">//获得SocketChannel</span><br><span class="line">SocketChannel socketChannel = channel.accept();</span><br><span class="line">//设置成非阻塞</span><br><span class="line">socketChannel.configureBlocking(false);</span><br><span class="line">//注册到selector上,并让Selector对读操作感兴趣</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">socketChannel.register(selector,SelectionKey.OP_READ);</span><br><span class="line">//服务端向客户端回复消息</span><br><span class="line">socketChannel.write(ByteBuffer.wrap(&quot;欢迎进入千锋聊天</span><br><span class="line">室&quot;.getBytes(StandardCharsets.UTF_8)));</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="-61"><a href="#-61" class="headerlink" title></a></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">package com.qf.chat.client;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line">import java.net.InetSocketAddress;</span><br><span class="line">import java.nio.ByteBuffer;</span><br><span class="line">import java.nio.channels.SelectionKey;</span><br><span class="line">import java.nio.channels.Selector;</span><br><span class="line">import java.nio.channels.SocketChannel;</span><br><span class="line">import java.nio.charset.StandardCharsets;</span><br><span class="line">import java.nio.file.StandardOpenOption;</span><br><span class="line">import java.util.Iterator;</span><br><span class="line">import java.util.Scanner;</span><br></pre></td></tr></table></figure><h5 id="-62"><a href="#-62" class="headerlink" title></a></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Set;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 客户端程序</span><br><span class="line">* 1.发送数据到服务端</span><br><span class="line">* 2.接收服务端发来的消息</span><br><span class="line">* @author htt</span><br><span class="line">* doublepeach</span><br><span class="line">*/</span><br><span class="line">public class ChatClient &#123;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 启动客户端的方法</span><br><span class="line">* @param name 聊天室昵称</span><br><span class="line">*/</span><br><span class="line">public void start(String name)&#123;</span><br><span class="line">try &#123;</span><br><span class="line">//创建Channel</span><br><span class="line">SocketChannel socketChannel = SocketChannel.open(new</span><br><span class="line">InetSocketAddress(&quot;127.0.0.1&quot;, 9001 ));</span><br><span class="line">//设置成非阻塞</span><br><span class="line">socketChannel.configureBlocking(false);</span><br><span class="line">//获得Selector</span><br><span class="line">Selector selector = Selector.open();</span><br><span class="line">//注册channel到selector上，让selector对其读操作感兴趣,用于</span><br><span class="line">读取服务端发送来的消息</span><br><span class="line">socketChannel.register(selector,</span><br><span class="line">SelectionKey.OP_READ);</span><br><span class="line">//创建线程，专⻔负责发送消息</span><br><span class="line">new SendMessageThread(socketChannel,name).start();</span><br><span class="line">//循环selector</span><br><span class="line">while(true)&#123;</span><br><span class="line">//获得这次就绪状态的channel的数量</span><br><span class="line">int select = selector.select();</span><br><span class="line">if(select == 0 )&#123;</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="-63"><a href="#-63" class="headerlink" title></a></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">//获得所有的就绪状态的channel</span><br><span class="line">Set&lt;SelectionKey&gt; selectionKeys =</span><br><span class="line">selector.selectedKeys();</span><br><span class="line">Iterator&lt;SelectionKey&gt; iterator =</span><br><span class="line">selectionKeys.iterator();</span><br><span class="line">//遍历</span><br><span class="line">while(iterator.hasNext())&#123;</span><br><span class="line">SelectionKey key = iterator.next();</span><br><span class="line">if(key.isReadable())&#123;</span><br><span class="line">//如果是读操作就绪，说明服务端广播数据了</span><br><span class="line">//获得channel</span><br><span class="line">SocketChannel channel = (SocketChannel)</span><br><span class="line">key.channel();</span><br><span class="line">//创建buffer</span><br><span class="line">ByteBuffer buffer =</span><br><span class="line">ByteBuffer.allocate( 1024 );</span><br><span class="line">//读取</span><br><span class="line">int len = 0 ;</span><br><span class="line">String message = &quot;&quot;;</span><br><span class="line">while((len = channel.read(buffer))&gt; 0 )&#123;</span><br><span class="line">buffer.flip();</span><br><span class="line">//封装message</span><br><span class="line">message += new</span><br><span class="line">String(buffer.array(), 0 ,len, StandardCharsets.UTF_8);</span><br><span class="line">&#125;</span><br><span class="line">//打印消息</span><br><span class="line">System.out.println(message);</span><br><span class="line">//把channel再次注册到selector上，并让</span><br><span class="line">selector对读感兴趣额</span><br><span class="line">channel.register(selector,</span><br><span class="line">SelectionKey.OP_READ);</span><br><span class="line">&#125;</span><br><span class="line">//移除key</span><br><span class="line">iterator.remove();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="-64"><a href="#-64" class="headerlink" title></a></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="-65"><a href="#-65" class="headerlink" title="}"></a>}</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class SendMessageThread extends Thread&#123;</span><br><span class="line">//要发消息的socketchannel</span><br><span class="line">private SocketChannel socketChannel;</span><br><span class="line">//自己的昵称</span><br><span class="line">private String name;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public SendMessageThread(SocketChannel socketChannel, String</span><br><span class="line">name) &#123;</span><br><span class="line">this.socketChannel = socketChannel;</span><br><span class="line">this.name = name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">//控制台输入</span><br><span class="line">Scanner scanner = new Scanner(System.in);</span><br><span class="line">while(scanner.hasNextLine())&#123;</span><br><span class="line">String message = scanner.nextLine();</span><br><span class="line">//带上名字</span><br><span class="line">String sendMessage = name + &quot;:&quot; + message;</span><br><span class="line">//发消息到channel</span><br><span class="line">if(message.length()&gt; 0 )&#123;</span><br><span class="line">try &#123;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">socketChannel.write(ByteBuffer.wrap(sendMessage.getBytes(Standar</span><br><span class="line">dCharsets.UTF_8)));</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br></pre></td></tr></table></figure><h5 id="-66"><a href="#-66" class="headerlink" title></a></h5><h1 id="八、Java-AIO"><a href="#八、Java-AIO" class="headerlink" title="八、Java-AIO"></a>八、Java-AIO</h1><h2 id="1-AIO概述"><a href="#1-AIO概述" class="headerlink" title="1.AIO概述"></a>1.AIO概述</h2><h4 id="Asynchronous-IO也称为AIO，即异步非阻塞IO。Java7提供了改进版的NIO，引入了-1"><a href="#Asynchronous-IO也称为AIO，即异步非阻塞IO。Java7提供了改进版的NIO，引入了-1" class="headerlink" title="Asynchronous IO也称为AIO，即异步非阻塞IO。Java7提供了改进版的NIO，引入了"></a>Asynchronous IO也称为AIO，即异步非阻塞IO。Java7提供了改进版的NIO，引入了</h4><h4 id="异步非阻塞的IO，由操作系统完成后回调通知服务端程序启动线程去处理。一般适"><a href="#异步非阻塞的IO，由操作系统完成后回调通知服务端程序启动线程去处理。一般适" class="headerlink" title="异步非阻塞的IO，由操作系统完成后回调通知服务端程序启动线程去处理。一般适"></a>异步非阻塞的IO，由操作系统完成后回调通知服务端程序启动线程去处理。一般适</h4><h4 id="用于连接数较多且连接时间较⻓的应用。"><a href="#用于连接数较多且连接时间较⻓的应用。" class="headerlink" title="用于连接数较多且连接时间较⻓的应用。"></a>用于连接数较多且连接时间较⻓的应用。</h4><h2 id="2-AIO具体实现"><a href="#2-AIO具体实现" class="headerlink" title="2.AIO具体实现"></a>2.AIO具体实现</h2><h4 id="服务端实现"><a href="#服务端实现" class="headerlink" title="服务端实现"></a>服务端实现</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">package com.qf.aio;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line">import java.net.InetSocketAddress;</span><br><span class="line">import java.nio.ByteBuffer;</span><br><span class="line">import java.nio.channels.AsynchronousServerSocketChannel;</span><br><span class="line">import java.nio.channels.AsynchronousSocketChannel;</span><br><span class="line">import java.nio.channels.CompletionHandler;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* AIO</span><br><span class="line">* @author htt</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">* doublepeach</span><br><span class="line">*/</span><br><span class="line">public class AIOServer &#123;</span><br><span class="line">public static void main(String[] args) throws IOException,</span><br><span class="line">InterruptedException &#123;</span><br><span class="line">//创建异步的Server Socket Channel</span><br><span class="line">AsynchronousServerSocketChannel serverSocketChannel =</span><br><span class="line">AsynchronousServerSocketChannel.open();</span><br><span class="line">//绑定端口</span><br><span class="line">serverSocketChannel.bind(new InetSocketAddress( 9001 ));</span><br><span class="line">//异步接收</span><br><span class="line">serverSocketChannel.accept(null, new</span><br><span class="line">CompletionHandler&lt;AsynchronousSocketChannel, Object&gt;() &#123;</span><br><span class="line">/**</span><br><span class="line">* 当有连接发生时调用的方法</span><br><span class="line">*/</span><br><span class="line">@Override</span><br><span class="line">public void completed(AsynchronousSocketChannel</span><br><span class="line">socketChannel, Object attachment) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">//开启接收</span><br><span class="line">serverSocketChannel.accept(attachment,this);</span><br><span class="line">System.out.println(&quot;消息来自</span><br><span class="line">于：&quot;+socketChannel.getRemoteAddress());</span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate( 1024 );</span><br><span class="line">socketChannel.read(buffer, buffer, new</span><br><span class="line">CompletionHandler&lt;Integer, ByteBuffer&gt;() &#123;</span><br><span class="line">@Override</span><br><span class="line">public void completed(Integer result,</span><br><span class="line">ByteBuffer byteBuffer) &#123;</span><br><span class="line">byteBuffer.flip();</span><br><span class="line">//打印收到的消息</span><br><span class="line">System.out.println(new</span><br><span class="line">String(buffer.array(), 0 ,result));</span><br><span class="line">//向客户端返回消息</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socketChannel.write(ByteBuffer.wrap(&quot;hello client&quot;.getBytes()));</span><br></pre></td></tr></table></figure><h4 id="客户端实现"><a href="#客户端实现" class="headerlink" title="客户端实现"></a>客户端实现</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void failed(Throwable exc,</span><br><span class="line">ByteBuffer attachment) &#123;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 当连接失败时调用的方法</span><br><span class="line">*/</span><br><span class="line">@Override</span><br><span class="line">public void failed(Throwable exc, Object attachment) &#123;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(&quot;main thread&quot;);</span><br><span class="line">Thread.sleep(Integer.MAX_VALUE);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">package com.qf.aio;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line">import java.net.InetSocketAddress;</span><br><span class="line">import java.nio.ByteBuffer;</span><br><span class="line">import java.nio.channels.AsynchronousSocketChannel;</span><br></pre></td></tr></table></figure><h5 id="-67"><a href="#-67" class="headerlink" title></a></h5><h5 id="x2F-2"><a href="#x2F-2" class="headerlink" title="&#x2F;**"></a>&#x2F;**</h5><h5 id="AIO客户端"><a href="#AIO客户端" class="headerlink" title="* AIO客户端"></a>* AIO客户端</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">* @author htt</span><br><span class="line">* doublepeach</span><br><span class="line">*/</span><br><span class="line">public class AIOClient &#123;</span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">AsynchronousSocketChannel socketChannel =</span><br><span class="line">AsynchronousSocketChannel.open();</span><br><span class="line">//调用get方法完成连接</span><br><span class="line">socketChannel.connect(new</span><br><span class="line">InetSocketAddress(&quot;127.0.0.1&quot;, 9001 )).get();</span><br><span class="line">//发送数据</span><br><span class="line">socketChannel.write(ByteBuffer.wrap(&quot;hello</span><br><span class="line">server&quot;.getBytes()));</span><br><span class="line">//获得返回的数据</span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate( 1024 );</span><br><span class="line">int len = 0 ;</span><br><span class="line">//调用get方法实现同步</span><br><span class="line">while((len = socketChannel.read(buffer).get())&gt; 0 )&#123;</span><br><span class="line">System.out.println(&quot;服务端返回的消息：&quot;+new</span><br><span class="line">String(buffer.array(), 0 ,len));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-BIO、NIO、AIO对比"><a href="#3-BIO、NIO、AIO对比" class="headerlink" title="3.BIO、NIO、AIO对比"></a>3.BIO、NIO、AIO对比</h2><h5 id="BIONIOAIO"><a href="#BIONIOAIO" class="headerlink" title="BIONIOAIO"></a>BIONIOAIO</h5><p>IO模型同步阻塞同步非阻塞异步非阻塞</p><p>编程难度简单复杂复杂</p><p>可靠性查好好</p><p>吞吐量低高高</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>本地部署外部Javaweb、SSM、SpringBoot项目的经验小记</title>
      <link href="/DoublePeach/myblog/2023/06/29/%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E5%A4%96%E9%83%A8Javaweb%E3%80%81SSM%E3%80%81SpringBoot%E9%A1%B9%E7%9B%AE%E7%9A%84%E7%BB%8F%E9%AA%8C%E5%B0%8F%E8%AE%B0/"/>
      <url>/DoublePeach/myblog/2023/06/29/%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E5%A4%96%E9%83%A8Javaweb%E3%80%81SSM%E3%80%81SpringBoot%E9%A1%B9%E7%9B%AE%E7%9A%84%E7%BB%8F%E9%AA%8C%E5%B0%8F%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>这几天我在搞小学期任务时，帮别人部署了很多次项目，其中包含：</p><pre><code>基于Servlet写的Javaweb项目-图书管理系统基于SSM的-学生宿舍管理系统基于SpringBoot的-ERP仓库管理系统</code></pre><p>现总结一下，这三种不同框架在部署时应当如何正确有效地在本地跑起来</p><h1 id="一、JavaWeb项目部署"><a href="#一、JavaWeb项目部署" class="headerlink" title="一、JavaWeb项目部署"></a>一、JavaWeb项目部署</h1><p>以下是基于servlet的javaweb项目部署流程，以图书管理系统为例</p><h2 id="1-导入项目和数据库"><a href="#1-导入项目和数据库" class="headerlink" title="1. 导入项目和数据库"></a>1. 导入项目和数据库</h2><p>将拉取到的项目在IDEA中打开，注意要打开项目的根目录</p><p>然后导入数据库，打开navicat导入已有的.sql数据库文件</p><img src="/2023/06/29/%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E5%A4%96%E9%83%A8Javaweb%E3%80%81SSM%E3%80%81SpringBoot%E9%A1%B9%E7%9B%AE%E7%9A%84%E7%BB%8F%E9%AA%8C%E5%B0%8F%E8%AE%B0/87e364f9bfad8165736de8ae38e799be.png" class><p>在项目的对于数据库配置中，修改为自己本地的配置</p><img src="/2023/06/29/%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E5%A4%96%E9%83%A8Javaweb%E3%80%81SSM%E3%80%81SpringBoot%E9%A1%B9%E7%9B%AE%E7%9A%84%E7%BB%8F%E9%AA%8C%E5%B0%8F%E8%AE%B0/a634f27428da6f6d0c5bf00caabc60df.png" class><h2 id="2-设置项目字符集"><a href="#2-设置项目字符集" class="headerlink" title="2. 设置项目字符集"></a>2. 设置项目字符集</h2><p>设置字符集：</p><pre><code>打开设置--&gt;编辑器--&gt;File Encoding--&gt;将字符集统一为UTF-8</code></pre><img src="/2023/06/29/%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E5%A4%96%E9%83%A8Javaweb%E3%80%81SSM%E3%80%81SpringBoot%E9%A1%B9%E7%9B%AE%E7%9A%84%E7%BB%8F%E9%AA%8C%E5%B0%8F%E8%AE%B0/382482e5c1bc27824ef8ee42126c7846.png" class><h2 id="3-设置项目结构"><a href="#3-设置项目结构" class="headerlink" title="3. 设置项目结构"></a>3. 设置项目结构</h2><h3 id="3-1设置JDK"><a href="#3-1设置JDK" class="headerlink" title="3.1设置JDK"></a>3.1设置JDK</h3><img src="/2023/06/29/%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E5%A4%96%E9%83%A8Javaweb%E3%80%81SSM%E3%80%81SpringBoot%E9%A1%B9%E7%9B%AE%E7%9A%84%E7%BB%8F%E9%AA%8C%E5%B0%8F%E8%AE%B0/9aa8300503b7efca6b9dee041f32f143.png" class><h3 id="3-2-设置src文件夹为代码源"><a href="#3-2-设置src文件夹为代码源" class="headerlink" title="3.2 设置src文件夹为代码源"></a>3.2 设置src文件夹为代码源</h3><img src="/2023/06/29/%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E5%A4%96%E9%83%A8Javaweb%E3%80%81SSM%E3%80%81SpringBoot%E9%A1%B9%E7%9B%AE%E7%9A%84%E7%BB%8F%E9%AA%8C%E5%B0%8F%E8%AE%B0/8ad374fa038178f4afef06481f73a283.png" class><h3 id="3-3-添加Web框架支持"><a href="#3-3-添加Web框架支持" class="headerlink" title="3.3 添加Web框架支持"></a>3.3 添加Web框架支持</h3><img src="/2023/06/29/%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E5%A4%96%E9%83%A8Javaweb%E3%80%81SSM%E3%80%81SpringBoot%E9%A1%B9%E7%9B%AE%E7%9A%84%E7%BB%8F%E9%AA%8C%E5%B0%8F%E8%AE%B0/61e8f3e8796ccc842f77a634a4aef02f.png" class><p>添加Web Application4.0框架支持</p><img src="/2023/06/29/%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E5%A4%96%E9%83%A8Javaweb%E3%80%81SSM%E3%80%81SpringBoot%E9%A1%B9%E7%9B%AE%E7%9A%84%E7%BB%8F%E9%AA%8C%E5%B0%8F%E8%AE%B0/cc87e10289e5138d1747f4ba3e8cc2e2.png" class><p>删除自动生成的web模块，并且在模块中将Web资源目录修改为项目中的Web资源路径：</p><img src="/2023/06/29/%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E5%A4%96%E9%83%A8Javaweb%E3%80%81SSM%E3%80%81SpringBoot%E9%A1%B9%E7%9B%AE%E7%9A%84%E7%BB%8F%E9%AA%8C%E5%B0%8F%E8%AE%B0/83f085591d689778b3ddc8646835f54f.png" class><h3 id="3-4-添加依赖"><a href="#3-4-添加依赖" class="headerlink" title="3.4 添加依赖"></a>3.4 添加依赖</h3><p>将必要的依赖库全部添加进来</p><img src="/2023/06/29/%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E5%A4%96%E9%83%A8Javaweb%E3%80%81SSM%E3%80%81SpringBoot%E9%A1%B9%E7%9B%AE%E7%9A%84%E7%BB%8F%E9%AA%8C%E5%B0%8F%E8%AE%B0/98963d3bed48db4c8e1a4260c79809d8.png" class><h3 id="3-5-指定输出路径"><a href="#3-5-指定输出路径" class="headerlink" title="3.5 指定输出路径"></a>3.5 指定输出路径</h3><p>指定输出路径为项目下的out目录，没有就自己新建</p><p>注意：这里指定了输出路径后，Tomcat可能会无法点击运行，重启一下IDEA就好</p><h2 id="4-部署到Tomcat服务器"><a href="#4-部署到Tomcat服务器" class="headerlink" title="4. 部署到Tomcat服务器"></a>4. 部署到Tomcat服务器</h2><p>新建一个本地tomcat服务</p><p>部署工件Exploded，修改应用程序上下文</p><img src="/2023/06/29/%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E5%A4%96%E9%83%A8Javaweb%E3%80%81SSM%E3%80%81SpringBoot%E9%A1%B9%E7%9B%AE%E7%9A%84%E7%BB%8F%E9%AA%8C%E5%B0%8F%E8%AE%B0/dff4b9723978e18a4a93aef2321d7f78.png" class><h2 id="5-运行项目成功"><a href="#5-运行项目成功" class="headerlink" title="5. 运行项目成功"></a>5. 运行项目成功</h2><img src="/2023/06/29/%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E5%A4%96%E9%83%A8Javaweb%E3%80%81SSM%E3%80%81SpringBoot%E9%A1%B9%E7%9B%AE%E7%9A%84%E7%BB%8F%E9%AA%8C%E5%B0%8F%E8%AE%B0/695b307fcabb1b633b3cee3c1c3c077f.png" class><br><h1 id="二、基于SSM的Web项目部署"><a href="#二、基于SSM的Web项目部署" class="headerlink" title="二、基于SSM的Web项目部署"></a>二、基于SSM的Web项目部署</h1><p>以下演示基于SSM的Web项目部署，以宿舍管理系统为例</p><p>SSM的部署与上面的Sevlet项目部署方式基本相同，只有以下两点略不同：</p><ul><li>添加依赖库的时候，添加的库有所不同</li><li>代码中的数据库配置信息位置不同，SSM的在resources文件夹中，记住要标记此文件夹为资源根才能使配置信息生效</li></ul><br><h1 id="三、基于SpringBoot项目部署"><a href="#三、基于SpringBoot项目部署" class="headerlink" title="三、基于SpringBoot项目部署"></a>三、基于SpringBoot项目部署</h1><p>这个也是很熟悉了，以下是大致过程：<br><strong>1. 导入maven项目<br>2. 设置项目JDK与pom文件中版本保持一致<br>3. 本地安装maven，并且修改maven根目录下conf文件夹内的setting.xml中的配置<br>4. 在setting.xml中找到 <localRepository>标签，设置本地的仓库路径，例如：</localRepository></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;localRepository&gt;&quot;这部分填写你本地的仓库位置，自己建一个文件夹即可&quot;&lt;/localRepository&gt;</span><br></pre></td></tr></table></figure><p><strong>5. 在setting.xml中找到<mirror>标签，配置maven中央仓库的镜像为aliyun镜像，可以提高maven拉取依赖时的下载速度（直接复制在对应的位置）</mirror></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;mirror&gt;</span><br><span class="line">    &lt;id&gt;alimaven&lt;/id&gt;</span><br><span class="line">    &lt;name&gt;aliyun maven&lt;/name&gt;</span><br><span class="line">    &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;</span><br><span class="line">    &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;       </span><br><span class="line">  &lt;/mirror&gt; </span><br></pre></td></tr></table></figure><p><strong>6. 在IDEA中配置刚刚下好的maven的主目录位置、配置文件位置、仓库位置<br>7. 刷新maven导入依赖<br>8. 导入数据库信息，并在yml中修改数据库配置为本地信息<br>9. 启动SpringBoot项目</strong></p>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚拟机网络配置</title>
      <link href="/DoublePeach/myblog/2023/06/26/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/"/>
      <url>/DoublePeach/myblog/2023/06/26/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>今天在学习Hadoop时解决了一直以来对虚拟机网络配置的迷惑，之前总是不知道该如何配置虚拟机静态IP网络，现将这些问题总结一下，并以流程形式一步一步配置一个静态IP的虚拟机网络</p><h2 id="（1）使用VMware创建CentOS7的虚拟机"><a href="#（1）使用VMware创建CentOS7的虚拟机" class="headerlink" title="（1）使用VMware创建CentOS7的虚拟机"></a>（1）使用VMware创建CentOS7的虚拟机</h2><h2 id="（2）修改VM虚拟机网络IP配置"><a href="#（2）修改VM虚拟机网络IP配置" class="headerlink" title="（2）修改VM虚拟机网络IP配置"></a>（2）修改VM虚拟机网络IP配置</h2><ul><li><p>查看Linux虚拟机的虚拟网络编辑器，编辑-&gt;虚拟网络编辑器-&gt;VMnet8</p><ul><li>选择NAT模式</li><li>在VMnet8中设置子网IP：192.168.xx.0</li><li>在NAT设置中将网关修改为：192.168.xx.2</li></ul></li><li><p>查看Windows系统适配器VMware Network Adapter VMnet8的IP地址</p></li><li><p>保证Linux系统ifcfg-ens33文件中IP地址、虚拟网络编辑器地址和Windows系统VM8网络IP地址相同。</p><ul><li>把这里的默认网关修改为VM中NAT里设置的网关即可</li><li>注：图中的DNS服务器最好还是不要修改，因为这里虽然改的是虚拟机VM8的网卡配置，但是你在主机上访问浏览器上网时，会默认加载已经修改过DNS的网卡，所以此时你上网时会网速变慢</li></ul></li></ul><h2 id="（3）修改网络配置信息："><a href="#（3）修改网络配置信息：" class="headerlink" title="（3）修改网络配置信息："></a>（3）修改网络配置信息：</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/sysconfig/network-scripts/ifcfg-ens33</span><br></pre></td></tr></table></figure><ul><li>修改BOOTPROTO为static</li><li>修改ONBOOT为yes</li><li>添加IPADDR、GATWAY、DNS，这些信息要保持与VM中配置的一致</li></ul><h2 id="（4）修改主机名"><a href="#（4）修改主机名" class="headerlink" title="（4）修改主机名"></a>（4）修改主机名</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/hostname</span><br></pre></td></tr></table></figure><h2 id="（5）Linux克隆机主机名称映射hosts文件，打开-x2F-etc-x2F-hosts-添加对应的配置"><a href="#（5）Linux克隆机主机名称映射hosts文件，打开-x2F-etc-x2F-hosts-添加对应的配置" class="headerlink" title="（5）Linux克隆机主机名称映射hosts文件，打开&#x2F;etc&#x2F;hosts 添加对应的配置"></a>（5）Linux克隆机主机名称映射hosts文件，打开&#x2F;etc&#x2F;hosts 添加对应的配置</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">192.168.10.100 hadoop100</span><br><span class="line">192.168.10.101 hadoop101</span><br><span class="line">192.168.10.102 hadoop102</span><br></pre></td></tr></table></figure><p>以上配置指的是虚拟机中只要含hadoop100就对应192.168.10.100的主机，便于统一管理</p><h2 id="（6）修改本地hosts配置文件主机映射"><a href="#（6）修改本地hosts配置文件主机映射" class="headerlink" title="（6）修改本地hosts配置文件主机映射"></a>（6）修改本地hosts配置文件主机映射</h2><p>（a）进入C:\Windows\System32\drivers\etc路径<br>（b）拷贝hosts文件到桌面<br>（c）打开桌面hosts文件并添加如下内容</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">192.168.10.100 hadoop100</span><br><span class="line">192.168.10.101 hadoop101</span><br><span class="line">192.168.10.102 hadoop102</span><br></pre></td></tr></table></figure><p>这样就将虚拟机的网络与主机相对应</p><p>（d）将桌面hosts文件覆盖C:\Windows\System32\drivers\etc路径hosts文件</p><h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>这样我们就得到了一个与主机共享网络，且IP不会变化的虚拟机Linux系统</p>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>部署微服务项目小记</title>
      <link href="/DoublePeach/myblog/2023/05/01/%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%A1%B9%E7%9B%AE%E5%90%8E%E7%AB%AF%E7%A8%8B%E5%BA%8F%E5%B0%8F%E8%AE%B0/"/>
      <url>/DoublePeach/myblog/2023/05/01/%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%A1%B9%E7%9B%AE%E5%90%8E%E7%AB%AF%E7%A8%8B%E5%BA%8F%E5%B0%8F%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>   最近做了一个关于农业的微服务项目，项目体量还是挺大的，前端和后端应用加起来一共有9个微服务（每次测试跑起来还是蛮费力的哈哈）<br>项目做完后该打包部署上线到Linux服务器，为此我还整了4台云服务器（本来只有两台但是不够用，项目太大部署上去直接崩了…）<br>现总结一下我部署后端程序时的操作流程：</p><p>对于微服务项目的打包部署，步骤如下：</p><h1>1.父项目(root项目)中添加依赖：</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><h1>2.maven打包</h1><p>（1）切换跳过测试模式，不然test中有错误打包会报错</p><img src="/2023/05/01/%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%A1%B9%E7%9B%AE%E5%90%8E%E7%AB%AF%E7%A8%8B%E5%BA%8F%E5%B0%8F%E8%AE%B0/6d328461030044e5582d47dcddbebbad.png" class><p>（2）生命周期中clean一下，然后再install</p><p>（3）就会在每个子模块下生成target文件夹</p><img src="/2023/05/01/%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%A1%B9%E7%9B%AE%E5%90%8E%E7%AB%AF%E7%A8%8B%E5%BA%8F%E5%B0%8F%E8%AE%B0/b5c1aeb0ff539dafb374f6edc41f6ebb.png" class><p>（4）将其中每个模块中的target中打包好.jar包分别复制上传到云服务器中对应的文件夹中</p><img src="/2023/05/01/%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%A1%B9%E7%9B%AE%E5%90%8E%E7%AB%AF%E7%A8%8B%E5%BA%8F%E5%B0%8F%E8%AE%B0/16b8b03f26cfdb97da2636efad02a581.png" class><h1>3.编写Dockerfile文件，并使用命令构建镜像</h1><img src="/2023/05/01/%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%A1%B9%E7%9B%AE%E5%90%8E%E7%AB%AF%E7%A8%8B%E5%BA%8F%E5%B0%8F%E8%AE%B0/f81e9104b42ff9e8234c86bb3461618c.png" class><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build service-gateway-1.0/ -t service-gateway-1.0</span><br></pre></td></tr></table></figure><h1>4.运行构建好的docker镜像,启动服务</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 8110:8110 service-core-1.0</span><br></pre></td></tr></table></figure><p><strong>这样就完成了其中一个微服务的部署，其余模块的微服务项目也同理，依次将各个有启动类的微服务项目打包部署，完成整个项目的上线。</strong></p><br><p><strong>注意：部署时，有注册中心的先启动注册中心，然后再部署网关服务，再部署其他的子微服务，要按顺序来，才能确保整个服务平稳上线</strong></p>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通用工具之代码生成器和日志配置</title>
      <link href="/DoublePeach/myblog/2023/04/09/%E9%80%9A%E7%94%A8%E5%B7%A5%E5%85%B7%E4%B9%8B%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8%E5%92%8C%E6%97%A5%E5%BF%97%E9%85%8D%E7%BD%AE/"/>
      <url>/DoublePeach/myblog/2023/04/09/%E9%80%9A%E7%94%A8%E5%B7%A5%E5%85%B7%E4%B9%8B%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8%E5%92%8C%E6%97%A5%E5%BF%97%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>以下的代码生成器和日志文件配置是我从srb项目中学习到的，其中的代码生成器和我以前用的mybatis逆向生成器截然不同<br>这个生成器更加全面一些。日志配置在大型项目中也很有用，可以更快的定位到问题的发生，其中包含了本地文件日志记录</p><h1 id="•-代码生成器："><a href="#•-代码生成器：" class="headerlink" title="• 代码生成器："></a>• 代码生成器：</h1><h2 id="代码生成器，需要导入的依赖有"><a href="#代码生成器，需要导入的依赖有" class="headerlink" title="代码生成器，需要导入的依赖有"></a>代码生成器，需要导入的依赖有</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mybatis-plus.version</span>&gt;</span>3.4.1<span class="tag">&lt;/<span class="name">mybatis-plus.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">velocity.version</span>&gt;</span>2.0<span class="tag">&lt;/<span class="name">velocity.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!--mybatis-plus--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mybatis-plus.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--mybatis-plus 代码生成器--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-generator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mybatis-plus.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- Mybatis Plus 代码生成器模板引擎,  --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.velocity<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>velocity-engine-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;velocity.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="创建测试类，复制如下的生成代码，根据具体需要修改配置："><a href="#创建测试类，复制如下的生成代码，根据具体需要修改配置：" class="headerlink" title="创建测试类，复制如下的生成代码，根据具体需要修改配置："></a>创建测试类，复制如下的生成代码，根据具体需要修改配置：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.DbType;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.annotation.IdType;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.AutoGenerator;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.config.DataSourceConfig;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.config.GlobalConfig;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.config.PackageConfig;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.config.StrategyConfig;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.config.rules.NamingStrategy;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CodeGenerator</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">genCode</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1、创建代码生成器</span></span><br><span class="line">        <span class="type">AutoGenerator</span> <span class="variable">mpg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AutoGenerator</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、全局配置</span></span><br><span class="line">        <span class="type">GlobalConfig</span> <span class="variable">gc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GlobalConfig</span>();</span><br><span class="line">        <span class="type">String</span> <span class="variable">projectPath</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;user.dir&quot;</span>);</span><br><span class="line">        gc.setOutputDir(projectPath + <span class="string">&quot;/src/main/java&quot;</span>);</span><br><span class="line">        gc.setAuthor(<span class="string">&quot;HTT&quot;</span>);</span><br><span class="line">        gc.setOpen(<span class="literal">false</span>); <span class="comment">//生成后是否打开资源管理器</span></span><br><span class="line">        gc.setServiceName(<span class="string">&quot;%sService&quot;</span>);    <span class="comment">//去掉Service接口的首字母I</span></span><br><span class="line">        gc.setIdType(IdType.AUTO); <span class="comment">//主键策略</span></span><br><span class="line">        gc.setSwagger2(<span class="literal">true</span>);<span class="comment">//开启Swagger2模式</span></span><br><span class="line">        mpg.setGlobalConfig(gc);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、数据源配置</span></span><br><span class="line">        <span class="type">DataSourceConfig</span> <span class="variable">dsc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataSourceConfig</span>();</span><br><span class="line">        dsc.setUrl(<span class="string">&quot;jdbc:mysql://47.92.69.43:3306/srb?serverTimezone=GMT%2B8&amp;characterEncoding=utf-8&quot;</span>);</span><br><span class="line">        dsc.setDriverName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">        dsc.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        dsc.setPassword(<span class="string">&quot;333&quot;</span>);</span><br><span class="line">        dsc.setDbType(DbType.MYSQL);</span><br><span class="line">        mpg.setDataSource(dsc);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4、包配置</span></span><br><span class="line">        <span class="type">PackageConfig</span> <span class="variable">pc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PackageConfig</span>();</span><br><span class="line">        pc.setParent(<span class="string">&quot;com.htt.srb.core&quot;</span>);</span><br><span class="line">        pc.setEntity(<span class="string">&quot;pojo.entity&quot;</span>); <span class="comment">//此对象与数据库表结构一一对应，通过 DAO 层向上传输数据源对象。</span></span><br><span class="line">        mpg.setPackageInfo(pc);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5、策略配置</span></span><br><span class="line">        <span class="type">StrategyConfig</span> <span class="variable">strategy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StrategyConfig</span>();</span><br><span class="line">        strategy.setNaming(NamingStrategy.underline_to_camel);<span class="comment">//数据库表映射到实体的命名策略</span></span><br><span class="line"></span><br><span class="line">        strategy.setColumnNaming(NamingStrategy.underline_to_camel);<span class="comment">//数据库表字段映射到实体的命名策略</span></span><br><span class="line">        strategy.setEntityLombokModel(<span class="literal">true</span>); <span class="comment">// lombok</span></span><br><span class="line">        strategy.setLogicDeleteFieldName(<span class="string">&quot;is_deleted&quot;</span>);<span class="comment">//逻辑删除字段名</span></span><br><span class="line">        strategy.setEntityBooleanColumnRemoveIsPrefix(<span class="literal">true</span>);<span class="comment">//去掉布尔值的is_前缀（确保tinyint(1)）</span></span><br><span class="line">        strategy.setRestControllerStyle(<span class="literal">true</span>); <span class="comment">//restful api风格控制器</span></span><br><span class="line">        mpg.setStrategy(strategy);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6、执行</span></span><br><span class="line">        mpg.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="•-日志配置："><a href="#•-日志配置：" class="headerlink" title="• 日志配置："></a>• 日志配置：</h1><h2 id="在resources下创建logback-spring-xml文件，内容如下"><a href="#在resources下创建logback-spring-xml文件，内容如下" class="headerlink" title="在resources下创建logback-spring.xml文件，内容如下"></a>在resources下创建logback-spring.xml文件，内容如下</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">contextName</span>&gt;</span>HttSrb<span class="tag">&lt;/<span class="name">contextName</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 日志的输出目录 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;log.path&quot;</span> <span class="attr">value</span>=<span class="string">&quot;E:/项目/srb/srb_log/core&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--控制台日志格式：彩色日志--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- magenta:洋红 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- boldMagenta:粗红--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- cyan:青色 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- white:白色 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- magenta:洋红 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;CONSOLE_LOG_PATTERN&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">value</span>=<span class="string">&quot;%yellow(%date&#123;yyyy-MM-dd HH:mm:ss&#125;) %highlight([%-5level]) %green(%logger) %msg%n&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--文件日志格式--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;FILE_LOG_PATTERN&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">value</span>=<span class="string">&quot;%date&#123;yyyy-MM-dd HH:mm:ss&#125; [%-5level] %thread %file:%line %logger %msg%n&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--编码--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;ENCODING&quot;</span></span></span><br><span class="line"><span class="tag">              <span class="attr">value</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 控制台日志 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;CONSOLE&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>$&#123;CONSOLE_LOG_PATTERN&#125;<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">charset</span>&gt;</span>$&#123;ENCODING&#125;<span class="tag">&lt;/<span class="name">charset</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 文件日志 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;FILE&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.FileAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">file</span>&gt;</span>$&#123;log.path&#125;/log.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">append</span>&gt;</span>true<span class="tag">&lt;/<span class="name">append</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>$&#123;FILE_LOG_PATTERN&#125;<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">charset</span>&gt;</span>$&#123;ENCODING&#125;<span class="tag">&lt;/<span class="name">charset</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--滚动日志防止单日志文件过大--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;ROLLING_FILE&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--  要区别于其他的appender中的文件名字  --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">file</span>&gt;</span>$&#123;log.path&#125;/log-rolling.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>$&#123;FILE_LOG_PATTERN&#125;<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">charset</span>&gt;</span>$&#123;ENCODING&#125;<span class="tag">&lt;/<span class="name">charset</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 设置滚动日志记录的滚动策略 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 日志归档路径以及格式 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>$&#123;log.path&#125;/info/log-rolling-%d&#123;yyyy-MM-dd&#125;.%i.log<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--归档日志文件保留的最大数量--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maxHistory</span>&gt;</span>15<span class="tag">&lt;/<span class="name">maxHistory</span>&gt;</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">&lt;!--归档日志触发时机--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">timeBasedFileNamingAndTriggeringPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">maxFileSize</span>&gt;</span>10KB<span class="tag">&lt;/<span class="name">maxFileSize</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">timeBasedFileNamingAndTriggeringPolicy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 开发环境和测试环境 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">&quot;dev,test&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;com.htt&quot;</span> <span class="attr">level</span>=<span class="string">&quot;INFO&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;CONSOLE&quot;</span> /&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--&lt;appender-ref ref=&quot;ROLLING_FILE&quot; /&gt;--&gt;</span> </span><br><span class="line">        <span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 生产环境 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">&quot;prod&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;com.htt&quot;</span> <span class="attr">level</span>=<span class="string">&quot;ERROR&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;CONSOLE&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;ROLLING_FILE&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 实用工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 标签 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot项目中静态资源访问的处理</title>
      <link href="/DoublePeach/myblog/2022/12/09/SpringBoot%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E8%AE%BF%E9%97%AE%E7%9A%84%E5%A4%84%E7%90%86/"/>
      <url>/DoublePeach/myblog/2022/12/09/SpringBoot%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E8%AE%BF%E9%97%AE%E7%9A%84%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="1、问题："><a href="#1、问题：" class="headerlink" title="1、问题："></a>1、问题：</h2><p>使用SpringBoot项目写一个文件上传的需求，发现在项目启动后无法直接访问resources&#x2F;templates下的静态资源页面（html页面）。</p><h2 id="2、问题原因："><a href="#2、问题原因：" class="headerlink" title="2、问题原因："></a>2、问题原因：</h2><p>SpringBoot项目中<strong>resources&#x2F;templates下的静态资源是不能直接访问的</strong>，原因是没有开放访问权限的，因为templates下可能存放有后台管理的页面资源，当templates对外开放就会产生安全隐患，所以templates下的资源需要通过<strong>ViewResolver(视图解析器)去解析访问</strong>，大体流程：<strong>前端request请求-&gt;DispatcherServlet（前端控制器）-&gt; Controller层的跳转方法 -&gt; ViewResslver（视图解析器）-&gt;templates下的静态资源</strong>（SpringMVC的工作流程）。</p><h2 id="3、解决办法："><a href="#3、解决办法：" class="headerlink" title="3、解决办法："></a>3、解决办法：</h2><p><strong>通过访问Controller层方法跳转到需要访问的静态资源</strong></p><h2 id="4、注意："><a href="#4、注意：" class="headerlink" title="4、注意："></a>4、注意：</h2><p>1、这里需要<strong>使用@Controller</strong>，不能使用RestController，不然会以Json格式响应到页面，不会进行视图解析。以下是正常的访问方式：</p><img src="/2022/12/09/SpringBoot%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E8%AE%BF%E9%97%AE%E7%9A%84%E5%A4%84%E7%90%86/771a2af43ba4e043fdb00f4c4d43b076.png" class><img src="/2022/12/09/SpringBoot%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E8%AE%BF%E9%97%AE%E7%9A%84%E5%A4%84%E7%90%86/3ae2a5f42a73f6bc17c6624b6a9fa509.png" class><p><strong>如果通过Controller层方法还是不能跳转成功并且显示：</strong></p><img src="/2022/12/09/SpringBoot%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E8%AE%BF%E9%97%AE%E7%9A%84%E5%A4%84%E7%90%86/3ba3ee48e47b7c1a56c1529ae3a8cde7.png" class><p><strong>原因可能是没有添加模板引擎</strong>，SpringBoot访问静态资源只支持静态模板引擎（SpringBoot默认不支持jsp作为视图），所以这里我添加了thymeleaf：<br><br></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>再通过控制层url访问时就成功了</p>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>随笔2022-11-25</title>
      <link href="/DoublePeach/myblog/2022/11/25/%E9%9A%8F%E7%AC%942022-11-25/"/>
      <url>/DoublePeach/myblog/2022/11/25/%E9%9A%8F%E7%AC%942022-11-25/</url>
      
        <content type="html"><![CDATA[<p>   好久不写博客了，今天更一篇我最近很郁闷的一件事，最近在学习各种分布式框架技术，都要用到<strong>VMware虚拟机中的CentOS7系统环境进行操作</strong>。但是频繁的出现bug让我难受的一批。</p><p>目前为止，我已经卸载重新安装了两次CentOS7系统了。</p><p><strong>第一次</strong>好像在十月末，那次是因为Linux虚拟主机的IP地址频繁自动更换，虽然后面通过网上的方式将虚拟主机IP更改为静态地址，但是在使用XShell进行连接的时候经常连接不上，<strong>反复确认了em33的IP无误，端口号也试过很多，但还是连接不上</strong>，非常的郁闷啊谁懂~</p><p>   然后我在想是不是之前设置了一些东西搞坏了配置的原因，所以我就把挂载的CentOS卸载了，重新安装了一次。<strong>安装好系统之后的第一件事情就是在配置文件中配置静态地址</strong>（被动态IP消耗了太多时间了-麻了…）</p><p>编辑em33网关配置文件的命令：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/sysconfig/network-scripts/ifcfg-ens33</span><br></pre></td></tr></table></figure><p><strong>将动态IP更改为static静态地址，即将BOOTPROTO&#x3D;”static”，并且指定了IPADDR&#x3D;”192.168.195.128”</strong></p><p>   然后就大功告成了，<strong>又可以正常通过终端连接和操作虚拟主机，迎来了一个多月的安稳学习时间</strong>，但是天有不测风云啊…就在我以为一劳永逸的时候，现实又给了我狠狠一暴击…</p><br><p>   <strong>第二次</strong>是让我最郁闷的一次，也是最近我最烦心的，前前后后消耗了我大量的时间和精力…最后还没解决，只能再次重装虚拟机</p><p>   那天我高高兴兴的打开电脑、启动VM、启动CentOS、开启XShell、连接虚拟主机，嗯~非常顺利-非常丝滑，<strong>但当我开始使用docker进行pull资源时，一直报mirror问题</strong>，拉不下来。</p><p>   我一看觉得应该是<strong>配置镜像加速器</strong>的问题导致的，然后我就重新按部就班的配置了一遍阿里云镜像加速器，没想到还是报超时错误，我百思不得其解。</p><p>   后面网上debug的时候说是<strong>DNS解析问题</strong>，我又按照网上的方式进行dns配置，修改了好多东西，期间使用yum命令获取一些必要的东西时发现，<strong>yum命令也不能使用</strong>，阿西吧郁闷，我又去整yum的问题，卸载了yum，<strong>重装yum源的时候，需要用wget命令进行yum源的配置</strong>，但让我又又又郁闷了，<strong>wget命令也使用不了</strong>，报错：</p><p><code>wget: unable to resolve host address ‘tel.mirrors.163.com’</code></p><p>   啊！！！兜兜转转还是<strong>网络服务的问题</strong>啊，ping <a href="http://www.baidu.com/">www.baidu.com</a> 时发现确实我的虚拟主机现在连网络都跑不通，以我的直觉来说，应该又是什么东西自动修改了，就跟第一次重装时IP自动变化一样，我只能想到应该是DNS，但是按照网上的方式修改了好久还是那样。。。那我心想，<strong>会不会是我之前修改的一些配置导致的</strong>。。。</p><p>此时已经前前后后折磨了我快一个星期了，导致学习卡顿，天天打开电脑就是处理这玩意儿。。。第二天，<strong>果断卸载重装虚拟机</strong>，希望不会有这种事情发生了！保佑保佑保佑！！！</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker常用命令总结</title>
      <link href="/DoublePeach/myblog/2022/10/20/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/"/>
      <url>/DoublePeach/myblog/2022/10/20/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p><strong>学习了这么久Docker，我今天突然觉得，是时候对Docker的众多命令做一个总结了</strong><br><strong>Docker作为一个容器化镜像技术，无论是开发人员还是运维人员都是必须掌握的技能</strong><br><strong>以下总结列出了Docker中32条常用的命令以及它的参数选项等，方便自己或者他人日后查阅使用！</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1、 docker login </span><br><span class="line">    docker login [OPTIONS] [SERVER]</span><br><span class="line">    [SERVER] 远程仓库地址</span><br><span class="line">    [OPTIONS]的常用值</span><br><span class="line">    -u string 用户名</span><br><span class="line">    -p string 密码</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">2、 docker search</span><br><span class="line">    docker search [OPTIONS] TERM</span><br><span class="line">    [OPTIONS]</span><br><span class="line">    -f filter 根据条件过滤镜像 </span><br><span class="line">    -no-trunc 显示完整镜像描述。默认情况下，搜索出来的镜像的描述太长会隐藏，no-trunc参数会让镜像信息完整展示出来</span><br><span class="line">    --limit 限制搜索出来的镜像个数，最大不超过100个，默认25个</span><br><span class="line">    --format 指定镜像显示的格式</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    -f参数表示根据条件过滤搜索出来的镜像 语法如下：</span><br><span class="line">    docker search -f KEY=VALUE TERM</span><br><span class="line">    KEY的选值如下：</span><br><span class="line">    stars int 根据热度过滤 如：stars=10表示过滤热度大于10的镜像</span><br><span class="line">    is-automated boolean 根据是否自动构建过滤，如：is-automated=false表示过滤非官方发布的镜像</span><br><span class="line">    is-official boolean 根据是否官方发布过滤 如：is-official=false表示过滤非官方发布的镜像</span><br><span class="line">    </span><br><span class="line">    --format参数用来指定搜索出来的镜像的显示的格式，语法如下：table表示使用表格的方式显示，支持\t格式</span><br><span class="line">    docker search --format &quot;[table] &#123;&#123;COLUMN&#125;&#125;[&#123;&#123;COLUMN&#125;&#125;...]&quot; TERM</span><br><span class="line">    COLUMN的可选值如下：</span><br><span class="line">    .NAME 显示镜像的名称列</span><br><span class="line">    .Description 显示镜像的描述列</span><br><span class="line">    .StarCount 显示镜像的热度一列</span><br><span class="line">    .IsOfficial 显示镜像是否是官方发布一列</span><br><span class="line">    .IsAutomated 显示镜像是否自动构建一列</span><br><span class="line">    如：docker search -f is-official=false --format &quot;table&#123;&#123;.Name&#125;&#125;\t&#123;&#123;.StarCount&#125;&#125;&quot; centos</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">3、 docker push</span><br><span class="line">    docker push [OPTIONS] NAME[:TAG]</span><br><span class="line">    [OPTIONS]:可选参数</span><br><span class="line">    NAME：镜像名称</span><br><span class="line">    TAG：镜像版本号，可省略，默认是latest</span><br><span class="line">    </span><br><span class="line">    [OPTIONS]常用值</span><br><span class="line">    --disable-content-trust:推送时远程仓库不校验签名，默认true</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">4、 docker pull</span><br><span class="line">    docker pull [OPTIONS] NAME[:TAG|@DIGEST]</span><br><span class="line">    [OPTIONS]:可选参数</span><br><span class="line">    NAME:镜像名称</span><br><span class="line">    TAG:镜像版本号，可省略，默认是latest</span><br><span class="line">    DIGEST:镜像的摘要，每个镜像都有对应的名称、id、摘要信息，每个摘要信息能唯一代表一个镜像，如</span><br><span class="line">    </span><br><span class="line">    OPTIONS常用值</span><br><span class="line">    -a:拉去镜像的所有版本号</span><br><span class="line">    --disable-count-trust:拉取时远程仓库不校验签名，默认true</span><br><span class="line">    -q:安静拉取,拉取过程中不展示详细信息</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">5、 docker images</span><br><span class="line">    docker images [OPTIONS] [REPOSITORY[:TAG]]</span><br><span class="line">    OPTIONS：可选参数</span><br><span class="line">    REPOSITORY:镜像路径</span><br><span class="line">    TAG：镜像版本号</span><br><span class="line">    </span><br><span class="line">    OPTIONS的常用值</span><br><span class="line">    -a:显示所有镜像，包含中间映像(默认中间映像是隐藏的)</span><br><span class="line">    -f filter :根据条件过滤镜像</span><br><span class="line">    -q：只显示镜像id</span><br><span class="line">    no-trunc：显示完整的镜像id。默认情况下，镜像id只显示前12位，no-trunc参数会将镜像id完整的显示出来</span><br><span class="line">    --digests：显示镜像的摘要信息</span><br><span class="line">    --format：指定镜像显示的格式</span><br><span class="line">    </span><br><span class="line">    docker images -f KEY=VALUE [REPOSITORY[:TAG]]</span><br><span class="line">    KEY的可选值如下:</span><br><span class="line">    dangling boolean:过滤悬挂的镜像，如：dangling=true表示只显示悬挂的镜像</span><br><span class="line">    label string：根据标签过滤，如:label=version表示显示有version标签的镜像，lavel=version=1.0表示显示</span><br><span class="line">    version=1.0的镜像</span><br><span class="line">    before image:显示在某个镜像之前创建的镜像，如 before=centos:5.8表示显示在centos:5.8这个镜像之前创建的镜像</span><br><span class="line">    since image: 显示在某个存在之后创建的镜像，如：since=centos:5.8表示显示在centos:5.8这个镜像存在之后的镜像</span><br><span class="line">    reference string:模糊匹配 如：reference=cent*:5.*,显示名称以cent开头版本号以5开头的镜像</span><br><span class="line">    </span><br><span class="line">    --format参数用来指定镜像显示格式，语法如下。table表示使用表格的方式显示，支持\t格式</span><br><span class="line">    docker images --format &quot;[table]&#123;&#123;COLUMN&#125;&#125;[&#123;&#123;COLUMN&#125;&#125;...]&quot; [REPOSITORY[:TAG]]</span><br><span class="line">    COLUMN的可选值如下：</span><br><span class="line">    .ID:显示进行的名称列</span><br><span class="line">    .Repository:显示进行的描述列</span><br><span class="line">    .Tag：显示镜像的热度一列</span><br><span class="line">    .Digest：显示镜像是狗屎官方发布的一列</span><br><span class="line">    .CreateSince：显示镜像是否是自动构建的一列</span><br><span class="line">    .CreatedAt:显示镜像是否自动构建的一列</span><br><span class="line">    .Size：显示镜像是否自动构建的一列</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">6、 docker rmi  可以删除一个或者多个本地镜像，通常情况应该用rm表示删除命令，但是在dokcer命令中rm表示删除容器，</span><br><span class="line">所以用rmi表示删除镜像，其中i是image的首字母</span><br><span class="line">    docker rmi [OPTIONS] IMAGE [IMAGE...]</span><br><span class="line">    OPTIONS:可选参数</span><br><span class="line">    IMAGE:镜像id或者仓库路径名称</span><br><span class="line">    </span><br><span class="line">    OPTIONS的常用值</span><br><span class="line">    -f :强制删除，如果镜像有对应的容器正在运行，则不允许直接删除镜像，需要强制删除</span><br><span class="line">    --no-prune：不删除该镜像的过程镜像，默认是删除的</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">7、 docker tag 命令可以基于一个镜像，创建一个新版本的镜像并归入本地仓库，吃屎该镜像在仓库中存在两个版本，</span><br><span class="line">可以根据这两个镜像创建不同的容器</span><br><span class="line">    docker tag SOURCE_IMAGE[:TAG] TARGET_IMAGE[:TAG]</span><br><span class="line">    SOURCE_IMAGE:原镜像</span><br><span class="line">    TARGET_IMAGE:新镜像</span><br><span class="line">    TAG:镜像版本号</span><br><span class="line">    </span><br><span class="line">    常用写法如：</span><br><span class="line">    基于redis:latest镜像创建my-redis1.0镜像，并把新镜像归入redis-lib仓库</span><br><span class="line">    docker tag redis:latest redis-lib/my-redis:1.0</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">8、 docker history 查看某一个镜像的创建历史。也就是镜像的提交记录</span><br><span class="line">    docker history [OPTIONS] IMAGE</span><br><span class="line">    OPTIONS :可选参数</span><br><span class="line">    IMAGE:镜像</span><br><span class="line">    </span><br><span class="line">    OPTIONS常用值：</span><br><span class="line">    -H boolean:已可读的格式打印日期和大小，默认true</span><br><span class="line">    -q:只显示镜像id</span><br><span class="line">    no-trunc：输出结果不截取，正常情况下查看到的结果如果某一列太长会被截取</span><br><span class="line">    --format string:指定镜像现实的格式</span><br><span class="line">    </span><br><span class="line">    --format用来指定镜像的显示格式，语法如下。table表示是用表格的方式显示，支持\t格式</span><br><span class="line">    docker history --format &quot;[table]&#123;&#123;COLUMN&#125;&#125;[&#123;&#123;COLUMN&#125;&#125;...]&quot; IMAGE</span><br><span class="line">    COLUMN可选值如下：</span><br><span class="line">    .ID：镜像的ID</span><br><span class="line">    .CreateSince：镜像的创建时长</span><br><span class="line">    .CreatedAt:镜像创建的时间戳</span><br><span class="line">    .CreatedBy:镜像创建使用的命令</span><br><span class="line">    .Size:镜像的大小</span><br><span class="line">    .Comment：镜像的评论</span><br><span class="line">    </span><br><span class="line">    常用写法如：</span><br><span class="line">    docker history --format &quot;table&#123;&#123;.ID&#125;&#125;\t&#123;&#123;.CreatedAt&#125;&#125;\t&#123;&#123;.CreatedBy&#125;&#125;&quot; centos</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">9、 docker save 把一个镜像或者多个镜像打包到一个文件，需要注意和export命令的区别</span><br><span class="line">    save命令打包的是镜像，包含镜像的所有信息</span><br><span class="line">    export命令打包的是容器，只是保存容器当时的快照，历史记录和云数据信息将会丢失</span><br><span class="line">    </span><br><span class="line">    docker save [OPTIONS] IMAGE [IMAGE...]</span><br><span class="line">    OPTIONS：可选参数</span><br><span class="line">    IMAGE:镜像</span><br><span class="line">    </span><br><span class="line">    OPTIONS的常用值</span><br><span class="line">    -o string :指定目标文件，和linux原生命令&gt;有相同作用</span><br><span class="line">    </span><br><span class="line">    常见用法如：</span><br><span class="line">    docker save centos  redis &gt; /home/my-images.tar</span><br><span class="line">    docker save -o /home/my-images.tar centos redis</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">10、docker load 从指定文件中加载镜像，该文件需要是save命令保存的文件</span><br><span class="line">    docker load [OPTIONS]</span><br><span class="line">    OPTIONS：可选参数</span><br><span class="line">    </span><br><span class="line">    OPTIONS的常用值</span><br><span class="line">    -i string :指定文件路径</span><br><span class="line">    -q:安静模式输出</span><br><span class="line">    </span><br><span class="line">    常见用法：</span><br><span class="line">    docker load &lt; /home/my-images.tar</span><br><span class="line">    docker load -i /home/my-images.tar</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">11、docker run 创建一个容器并运行，如果创建容器的镜像不存在则会从远程镜像仓库下载</span><br><span class="line">               运行容器的同事还能给容器发用一个命令</span><br><span class="line">    docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br><span class="line">    OPTIONS:可选参数</span><br><span class="line">    IMAGE:镜像</span><br><span class="line">    COMMAND:需要运行的命令</span><br><span class="line">    ARG:命令的参数</span><br><span class="line">    </span><br><span class="line">    OPTIONS的常用值：</span><br><span class="line">    由于run命令的OPTIONS的可选值比较较多，这里列出使用频率最高的一些。</span><br><span class="line">    -i:以交互模式运行，通常鱼-t一起使用</span><br><span class="line">    -t:为容器分配一个伪终端，通常与-i一起使用</span><br><span class="line">    -d:后台模式运行容器，并返回容器id</span><br><span class="line">    -p list:指定端口映射，格式为宿主机端口：容器端口</span><br><span class="line">    -p:随机分配端口映射</span><br><span class="line">    --name  string：给容器制定一个名称</span><br><span class="line">    -m bytes:限制容器可以使用的内存大小，单位可选b/k/m/g</span><br><span class="line">    -v list：把宿主机的磁盘路径挂载到容器的某个路径</span><br><span class="line">    --volumes-from list:绑定别的容器某个路径到此容器的某个路径</span><br><span class="line">    -w:指定容器的工作目录，默认是根目录</span><br><span class="line">    --rm:当容器停止运行是自动删除</span><br><span class="line">    --hostname string:指定容器的主机名</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">12、docker start 启动一个或者多个已停止的容器</span><br><span class="line">    docker start [OPTIONS] CONTAINER [CONTAINER...]</span><br><span class="line">    OPTIONS:可选参数</span><br><span class="line">    CONTAINER：容器</span><br><span class="line">    </span><br><span class="line">    OPTIONS的常用值：</span><br><span class="line">    -a:讲哦容器的标准输出或者标准错误附加到终端</span><br><span class="line">    -i:为容器附加一个标准输入终端</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">13、docker restart 对一个或者多个容器进行重启。如果容器是未启动的则会重启，正在运行的则会重启</span><br><span class="line">    docker restart [OPTIONS] CONTAINER [CONTAINER...]</span><br><span class="line">    OPTIONS:可选参数</span><br><span class="line">    CONTAINER:容器</span><br><span class="line">    </span><br><span class="line">    OPTIONS的常用值</span><br><span class="line">    -t int:在重启之前等待几秒，默认10秒</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">14、docker stop 停止一个或者多个正在运行的容器</span><br><span class="line">    kill命令也可以停止容器</span><br><span class="line">    不同的是stop命令允许容器在停止之前有一定的时间来进行额外操作，如释放连接，关闭请求等</span><br><span class="line">    kill命令则会直接强制杀死容器</span><br><span class="line">    docker stop [OPTIONS] CONTAINER [CONTAINER...]</span><br><span class="line">    OPTIONS:可选参数</span><br><span class="line">    CONTAINER:容器</span><br><span class="line">    </span><br><span class="line">    OPTIONS常用值：</span><br><span class="line">    -t int：等待n秒后如果还没停止，直接杀死，默认10秒</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>15、docker kill 可以杀死一个或者多个正在运行的容器<br>docker kill [OPTIONS] CONTAINER [CONTAINER…]</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">OPTIONS：可选值</span><br><span class="line">CONTAINER:容器</span><br><span class="line"></span><br><span class="line">OPTIONS的常用值：</span><br><span class="line">-s string:给容器发用一个信号，信号编号和linux原生命令kill的幸好编号一致，默认值9，</span><br><span class="line">-s参数信号编号常用值</span><br><span class="line">1：杀死并重新加载，也可用HUP</span><br><span class="line">9：强制杀死，也可用KILL</span><br><span class="line">15：正常停止，也可用TERM</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">16、docker rm 删除一个或者多个容器</span><br><span class="line">              如果容器正在运行，则需要通过-f参数强制删除</span><br><span class="line">    docker rm [OPTIONS] CONTAINER [CONTAINER...]</span><br><span class="line">    OPTIONS：可选参数</span><br><span class="line">    CONTAINER:容器</span><br><span class="line">    </span><br><span class="line">    OPTIONS的常用值</span><br><span class="line">    -f:强制删除，即容器正在运行也可以删除</span><br><span class="line">    -l:删除容器之间的网络关系，而不是容器本身</span><br><span class="line">    -v:删除容器和它挂载的卷</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">17、docker pause 暂停一个或者多个正在运行的容器</span><br><span class="line">    docker pause CONTAINER [CONTAINER...]</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">18、docker unpause 可以对一个或者多个暂停的容器取消暂停</span><br><span class="line">    docker unpause CONTAINER [CONTAINER...]</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">19、docker create 可以创建一个容器，但不运行它，在需要的时候可以start命令启动，和run命令的用法几乎一致，</span><br><span class="line">都会创建一个容器，如果容器依赖的镜像不存在都会从远程仓库拉取</span><br><span class="line">    run命令创建容器后并运行容器</span><br><span class="line">    create命令只创建容器，不运行</span><br><span class="line">    docker create [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br><span class="line">    OPTIONS：可选参数</span><br><span class="line">    IMAGE：镜像</span><br><span class="line">    COMMAND：需要运行的命令</span><br><span class="line">    ARG：命令的参数</span><br><span class="line">    </span><br><span class="line">    OPTIONS的常用值</span><br><span class="line">    参数比较多，只列出一些常用的。</span><br><span class="line">    -i ：以交互模式运，通常与-t一起使用</span><br><span class="line">    -t ：为容器分配一个伪终端，通常与-i一起使用</span><br><span class="line">    -d ：后台模式运行容器，并返回容器id</span><br><span class="line">    -p list ：指定端口映射，格式为 宿主机端口：容器端口</span><br><span class="line">    -p ：随机分配端口映射</span><br><span class="line">    --name string : 给容器指定一个名称</span><br><span class="line">    -m bytes : 限制容器可以使用的内存大小</span><br><span class="line">    -v list ：把宿主机的磁盘路径挂载到容器的某个路径</span><br><span class="line">    --volumes-from list : 绑定别的容器某个路径到此容器的某个路径</span><br><span class="line">    -w ：指定容器的工作目录，默认是根目录</span><br><span class="line">    --rm ：当容器停止运行时自动删除</span><br><span class="line">    --hostname string ：指定容器的主机名</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">20、docker exec 在一个运行中的容器中执行一个命令</span><br><span class="line">    docker exec [OPTIONS] CONTAINER COMMAND [ARG...]</span><br><span class="line">    OPTIONS:可选参数</span><br><span class="line">    CONTAINER:容器</span><br><span class="line">    COMMAND:要执行的命令</span><br><span class="line">    ARG：命令参数</span><br><span class="line">    </span><br><span class="line">    OPTIONS的常用值</span><br><span class="line">    -d:命令在后台执行</span><br><span class="line">    -i:保持标准输入，通常与-t一起使用</span><br><span class="line">    -t:分配一个伪终端，通常与-i一起使用</span><br><span class="line">    -w string:指定容器的路径</span><br><span class="line">    </span><br><span class="line">    常见用法：</span><br><span class="line">    在容器中执行pwd命令</span><br><span class="line">    docker exec centos pwd</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">21、docker ps 列出所有容器列表，查看容器基本信息。不加任何参数情况下，默认列出正在运行的容器</span><br><span class="line">    CONTAINER ID ：容器id</span><br><span class="line">    IMAGE：对应的镜像</span><br><span class="line">    COMMAND：容器启动时运行的命令</span><br><span class="line">    CREATED：创建时间</span><br><span class="line">    PORTS：绑定的端口</span><br><span class="line">    NAMES：容器的名称</span><br><span class="line">    </span><br><span class="line">    docker ps [OPTIONS]</span><br><span class="line">    OPTIONS:可选参数</span><br><span class="line">    </span><br><span class="line">    OPTIONS的常用值</span><br><span class="line">    -a :显示所有容器，默认只显示正在运行的</span><br><span class="line">    -f filter:根据条件过滤容器</span><br><span class="line">    -n int : 显示最后创建的几个容器，包含所有状态</span><br><span class="line">    -l:显示最新创建的容器，包含所有状态</span><br><span class="line">    -q:只显示容器id</span><br><span class="line">    -s:显示容器的大小，默认不显示该列</span><br><span class="line">    --no-trunc:显示内容不截断，默认情况下显示的容器是截断后的信息</span><br><span class="line">    </span><br><span class="line">    docker ps -f KEY=VALUE</span><br><span class="line">    KEY的可选值</span><br><span class="line">    id:根据容器id过滤</span><br><span class="line">    name:查看容器名称中包含的给定字段的容器</span><br><span class="line">    exited:根据容器退出的错误码进行过滤</span><br><span class="line">    status:根据容器的状态进行过滤，状态可选值有：created、paused、exited、dead、running、restarting、removing</span><br><span class="line">    before:只显示在某个容器之前创建的容器</span><br><span class="line">    since:只显示在某个容器之后创建的容器</span><br><span class="line">    volume:过滤绑定了某个目录的容器，只针对运行中的容器</span><br><span class="line">    publish:根据宿主机的端口过滤，只针对运行中的容器</span><br><span class="line">    expose:根据容器端口过滤，只针对运行中的容器</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">22、docker inspect 获取容器或者镜像的元数据</span><br><span class="line">    元数据信息可以理解为容器或者镜像的详情，他比ps命令显示的内容要详细的多，显示格式是json类型</span><br><span class="line">    docker inspect [OPTIONS] CONTAINER|IMAGE [CONTAINER|IMAGE...]</span><br><span class="line">    OPTIONS：可选参数</span><br><span class="line">    CONTAINER:容器</span><br><span class="line">    IMAGE:镜像</span><br><span class="line">    </span><br><span class="line">    OPTIONS的常用值</span><br><span class="line">    -f string : 格式化输出结果，inspect默认显示整个文件的详情，-f参数可以指定只显示某些属性</span><br><span class="line">    --s:只对容器有效，显示容器的配置文件行数和大小，显示的结果中会多出SizeRw/SizeRootFs两个参数</span><br><span class="line">    --type string:指定要inspect的类型，container表示容器，image表示镜像，默认是容器。</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">23、docker stats 监控容器资源的使用情况，每秒刷新一次，直到使用ctrl+c退出</span><br><span class="line">    docker stats [OPTIONS] [CONTAINER...]</span><br><span class="line">    OPTIONS ：可选参数</span><br><span class="line">    CONTAINER ：容器</span><br><span class="line">    </span><br><span class="line">    OPTIONS的常用值</span><br><span class="line">    -a filter ：显示所有容器的资源使用情况，默认只显示正在运行的</span><br><span class="line">    --format string: 格式化输出结果</span><br><span class="line">    --no-stream:不间隔刷新，只显示第一次统计结果</span><br><span class="line">    --no-trunc:不截断显示信息，默认情况下有些字段只显示简略信息</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">24、docker top 查看容器中运行的进程信息</span><br><span class="line">    top可以查看容器的进程信息，docker exec CONTAINER ps也可以查看容器的进程</span><br><span class="line">    前者查看的是容器运行在宿主机的进程id,后者查看的是容器内的进程id</span><br><span class="line">    docker top CONTAINER [ps OPTIONS]</span><br><span class="line">    </span><br><span class="line">    CONTAINER:容器</span><br><span class="line">    OPTIONS:ps命令的可选参数</span><br><span class="line">    </span><br><span class="line">    常用写法</span><br><span class="line">    查看centos镜像的宿主机进程id</span><br><span class="line">    docker top centos</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">25、docker rename 重命名容器</span><br><span class="line">    rename可以对容器进行重命名，在容器run时如果没有使用--name参数指定容器名称，可以用rename命令进行命名</span><br><span class="line">    docker rename CONTAINER NEW_NAME</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">26、docker attach 连接到容器内</span><br><span class="line">    attach 可以连接到容器内，这个容器必须是正在运行的容器，不是运行状态时，会报错</span><br><span class="line">    当使用ctrl+c或者exit等命令退出时，会导致容器停止运行，所以，不建议在生产环境中使用该命令。生产环境可以</span><br><span class="line">    使用exec命令进入容器</span><br><span class="line">    docker attach [OPTIONS] CONTAINER </span><br><span class="line">    OPTIONS:可选参数</span><br><span class="line">    CONTAINER:容器</span><br><span class="line">    </span><br><span class="line">    OPTIONS常用值</span><br><span class="line">    --sig-proxy=false boolean:默认是true,为false时可以防止容器遇到ctrl+c退出信号时停止运行</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">27、docker update 更新一个或者多个容器的配置</span><br><span class="line">    docker update [OPTIONS] CONTAINER [CONTAINER...]</span><br><span class="line">    OPTIONS:可选参数</span><br><span class="line">    CONTAINER:容器</span><br><span class="line">    </span><br><span class="line">    OPTIONS的常用值</span><br><span class="line">    -m bytes:指定容器的内存大小，单位可选b、k、m、g</span><br><span class="line">    --memory-swap bytes:</span><br><span class="line">    --cpu demecial :cpu资源，如1.5表示可以使用宿主机的1.5个cpu资源</span><br><span class="line">    --cpuset-cpus string：容器可以使用宿主机的cpu内核编号，0-3表示4个内核都可以使用，1,3表示只能使用1和3号内核</span><br><span class="line">    --restart string:指定容器退出的重启策略。no：不重启；on-failure:容器非正常退出时重启；</span><br><span class="line">    on-failure:3：非正常退出时容器重启3次；alaways:总是重启；unless-stopped:在容器退出时总是重启容器，</span><br><span class="line">    但是不考虑在Docker守护进程启动时就已经停止的容器</span><br><span class="line">    --pids-limit int:限制容器进程或线程的数量，-1表示不限制</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">28、docker logs 查看容器日志</span><br><span class="line">    docker logs [OPTIONS] CONTAINER</span><br><span class="line">    OPTIONS:可选参数</span><br><span class="line">    CONTAINER:容器</span><br><span class="line">    </span><br><span class="line">    OPTIONS的常用值</span><br><span class="line">    -f:跟踪日志的实时输出</span><br><span class="line">    --until string:查看某个时间点之前的日志，格式：2020-07-13T13:47:20Z,或使用相对时间10m，表示10分钟之前</span><br><span class="line">    --since string:查看某个时间点之后的日志，格式：2020-07-13T13:47:20Z, 或使用相对时间10m,表示10分钟之内</span><br><span class="line">    -n int:查看最后几行日志，默认显示全部</span><br><span class="line">    -t :日志中显示时间戳</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">29、docker wait 阻塞容器，直到容器退出并打印它的退出代码</span><br><span class="line">    wait命令可以阻塞一个或者多个容器直到容器退出并打印它们的退出代码</span><br><span class="line">    docker wait CONTAINER [CONTAINER...]</span><br><span class="line">    CONTAINER:容器</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">30、docker port 列出端口的映射关系</span><br><span class="line">    docker port CONTAINER [PRIVATE_PORT[/PROTO]]</span><br><span class="line">    CONTAINER:容器</span><br><span class="line">    PRIVATE_PORT:容器端口</span><br><span class="line">    PROTO：端口使用的协议</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">31、docker export 将容器打包成一个文件</span><br><span class="line">    export命令可以将容器打包到一个文件中，和save命令容器混淆</span><br><span class="line">    export和save的不同之处在于：export打包的是容器，save打包的是镜像</span><br><span class="line">    export打包的是容器当时的快照，至于容器的历史记录和元数据信息都会丢失，还有，export的文件在被import成一个镜像时，</span><br><span class="line">    可以重新指定镜像的名称和版本号</span><br><span class="line">    docker export [OPTIONS] CONTAINER</span><br><span class="line">    OPTIONS:可选参数</span><br><span class="line">    CONTAINER:容器</span><br><span class="line">    </span><br><span class="line">    OPTIONS的常用值</span><br><span class="line">    -o string:指定打包文件</span><br><span class="line">    </span><br><span class="line">    常见用法：</span><br><span class="line">    将my-boot容器打包到my-boot.tar文件</span><br><span class="line">    docker export -o /tmp/my-boot.tar my-boot</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">32、docker import 从本地文件或者远程文件导入镜像到本地仓库</span><br><span class="line">    import可以从本地文件或者远程文件中导入镜像到本地仓库</span><br><span class="line">    如果是从文件导入，这个文件需要是export命令导出的文件</span><br><span class="line">    </span><br><span class="line">    docker import [OPTIONS] file|URL|- [REPOSITORY[:TAG]]</span><br><span class="line">    OPTIONS:可选参数</span><br><span class="line">    file:文件地址</span><br><span class="line">    URL:URL地址</span><br><span class="line">    -:从标准输入终端导入，通常和linux的cat命令一起使用</span><br><span class="line">    REPOSITORY：本地镜像仓库地址</span><br><span class="line">    TAG：版本号</span><br><span class="line">    </span><br><span class="line">    OPTIONS的常用值</span><br><span class="line">    -m string :添加描述信息</span><br><span class="line">    -c list ：对创建的容器使用dockerfile命令</span><br><span class="line">    </span><br><span class="line">    import常见用法</span><br><span class="line">    1、 从my-boot.tar文件创建镜像</span><br><span class="line">        cat /tmp/my-boot.tar | docker import -</span><br><span class="line">    2、 从my-boot.tar文件导入镜像</span><br><span class="line">        docker import /tmp/my-boot.tar</span><br><span class="line">    3、 从my-boot.tar文件创建镜像，并指定镜像名称为my-boo-test、版本号为1.0</span><br><span class="line">        docker import /tmp/my-boot.tar my-boot-test:1.0</span><br><span class="line">    4、 从my-boot.tar文件创建镜像，备注信息为测试，并指定镜像名称为my-boot-test、版本号为1.0</span><br><span class="line">       docker import -m &quot;描述信息&quot;  /tmp/my-boot.tar my-boot-test:1.0</span><br><span class="line">    5、 从远程服务器的my-boot.tar文件创建镜像</span><br><span class="line">        docker import http://192.168.100.1:8080/images/my-boot.tar</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 容器化技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚拟机Linux主机ip自动变化解决</title>
      <link href="/DoublePeach/myblog/2022/10/15/%E8%99%9A%E6%8B%9F%E6%9C%BALinux%E4%B8%BB%E6%9C%BAip%E8%87%AA%E5%8A%A8%E5%8F%98%E5%8C%96%E8%A7%A3%E5%86%B3/"/>
      <url>/DoublePeach/myblog/2022/10/15/%E8%99%9A%E6%8B%9F%E6%9C%BALinux%E4%B8%BB%E6%9C%BAip%E8%87%AA%E5%8A%A8%E5%8F%98%E5%8C%96%E8%A7%A3%E5%86%B3/</url>
      
        <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>今天我使用创建的虚拟机去用XShell远程连接的时候，报了连接错误，我再三检查我的配置信息都没有任何问题，连接步骤也都ok，可就是连接不成功，如图：</p><img src="/2022/10/15/%E8%99%9A%E6%8B%9F%E6%9C%BALinux%E4%B8%BB%E6%9C%BAip%E8%87%AA%E5%8A%A8%E5%8F%98%E5%8C%96%E8%A7%A3%E5%86%B3/366637cf171f1e136258f278f730e26f.png" class><p>在百思不得其解，最后决定按Xshell连接Linux的步骤重新连接一次，然后在虚拟机中的Linux系统终端输入ifconfig查询主机ip时发现：主机ip居然自动改变了，我重新使用变化后的ip地址进行Xshell连接，一次成功！果然，就是ip不正确的问题。</p><p>随后我就又郁闷了，主机ip还能自己变动吗，那要这么一直自己变动，那岂不是隔一段时间就得重新查询修改会话属性才能建立连接，太麻烦了！可不可以取消掉这种自动修改ip的机制，一劳永逸？</p><p>涉及我的知识盲区，我百度了一番这才有了答案。</p><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p><strong>修改配置文件</strong><br>变化的原因：在配置文件&#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-ens33中，在一开始虚拟机设置的IP地址是dhcp是动态地址，所以才会一直变化，现在就要改成static再自己设置一个固定的ipaddr就可以了</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/sysconfig/network-scripts/ifcfg-ens33 </span><br><span class="line">reboot</span><br></pre></td></tr></table></figure><p><strong>然后在打开的文件中修改如下配置：</strong></p><img src="/2022/10/15/%E8%99%9A%E6%8B%9F%E6%9C%BALinux%E4%B8%BB%E6%9C%BAip%E8%87%AA%E5%8A%A8%E5%8F%98%E5%8C%96%E8%A7%A3%E5%86%B3/e53587d51fd37b9a8b6829987b61ce07.png" class><p>修改完成后:wq保存并退出就好了<br>然后用reboot重启之后，再进行远程连接，地址就不变了！</p>]]></content>
      
      
      <categories>
          
          <category> 问题解决 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>本地项目推送到gitee（命令行方式）</title>
      <link href="/DoublePeach/myblog/2022/10/05/%E6%9C%AC%E5%9C%B0%E9%A1%B9%E7%9B%AE%E6%8E%A8%E9%80%81%E5%88%B0gitee%EF%BC%88%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%96%B9%E5%BC%8F%EF%BC%89/"/>
      <url>/DoublePeach/myblog/2022/10/05/%E6%9C%AC%E5%9C%B0%E9%A1%B9%E7%9B%AE%E6%8E%A8%E9%80%81%E5%88%B0gitee%EF%BC%88%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%96%B9%E5%BC%8F%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>如何使用命令行方式将本地项目推送到gitee呢？</p><p>步骤如下：</p><br><p>1、首先在gitee上新建仓库<br>登录gitee账号，选择“仓库”，新建仓库。</p><br><p>2、在本地磁盘新建一个文件夹，上传代码。<br>2.1、在本地新建upload文件夹</p><p>2.2、在该文件夹中打开git Bash</p><p>2.3、输入命令1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><p>2.4、使用命令添加远程仓库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin &lt;仓库地址&gt;</span><br></pre></td></tr></table></figure><p>git remote add origin <a href="https://gitee.com/%E8%87%AA%E5%B7%B1%E7%9A%84%E7%A0%81%E4%BA%91%E7%94%A8%E6%88%B7%E5%90%8D/%E8%A6%81%E4%B8%8A%E4%BC%A0%E5%88%B0%E7%9A%84%E4%BB%93%E5%BA%93%E5%90%8D">https://gitee.com/自己的码云用户名/要上传到的仓库名</a></p><p>2.5、输入命令2： git pull origin master<br>使用 git pull origin master 命令，将码云上的仓库pull到本地文件夹</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin master</span><br></pre></td></tr></table></figure><p>2.6、将要上传的文件添加到upload文件夹中</p><p>2.7、输入命令3：git add .</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure><p>使用git add . （. 表示所有的）或者 git add + 文件名 &#x2F;&#x2F; 将文件保存到缓存区</p><p>2.8、输入命令4：git commit -m “新添加的文件内容描述”<br>使用git commit -m “新添加的文件内容描述”<br>双引号里边添加文件描述</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m “新添加的文件内容描述”</span><br></pre></td></tr></table></figure><p>2.9、输入命令5：git push origin master （将代码提交到主分支）<br>使用git push origin master ，将本地仓库推送到远程仓库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电商项目经验杂记3</title>
      <link href="/DoublePeach/myblog/2022/09/20/%E7%94%B5%E5%95%86%E9%A1%B9%E7%9B%AE%E7%BB%8F%E9%AA%8C%E6%9D%82%E8%AE%B03/"/>
      <url>/DoublePeach/myblog/2022/09/20/%E7%94%B5%E5%95%86%E9%A1%B9%E7%9B%AE%E7%BB%8F%E9%AA%8C%E6%9D%82%E8%AE%B03/</url>
      
        <content type="html"><![CDATA[<h1 id="第一小点：​"><a href="#第一小点：​" class="headerlink" title="第一小点：​"></a>第一小点：​</h1><p>在springboot配置文件中自定义配置项，并注入到类中的属性中：<br>application.yml中自定义配置：</p><img src="/2022/09/20/%E7%94%B5%E5%95%86%E9%A1%B9%E7%9B%AE%E7%BB%8F%E9%AA%8C%E6%9D%82%E8%AE%B03/3e894166f8262142afe0d8f83fd27bbd.png" class><p>注意：这里可能会报黄以及无法点击跳转，但可以注入我们可以不用管<br>类中的属性上添加注解：</p><img src="/2022/09/20/%E7%94%B5%E5%95%86%E9%A1%B9%E7%9B%AE%E7%BB%8F%E9%AA%8C%E6%9D%82%E8%AE%B03/d7b8f21b1159370b90e78912ff1c6679.png" class><p>这样就完成了自定义配置项对项目解耦合</p><p>*记录：2022年9月2日01点55分</p><h1 id="第二小点"><a href="#第二小点" class="headerlink" title="第二小点"></a>第二小点</h1><p>【完成项目的新增收货地址功能中的获取用户输入的省市区数据，至此数据库该表中所有的字段都补全完毕】</p><p>控制器接收前端参数使用url的方式：<br>@PathVariable注解用于接收url中的参数，该参数必须在{}中</p><img src="/2022/09/20/%E7%94%B5%E5%95%86%E9%A1%B9%E7%9B%AE%E7%BB%8F%E9%AA%8C%E6%9D%82%E8%AE%B03/de65eb29079cf23fbc173490cc2c81f4.png" class>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电商项目经验杂记2</title>
      <link href="/DoublePeach/myblog/2022/09/20/%E7%94%B5%E5%95%86%E9%A1%B9%E7%9B%AE%E7%BB%8F%E9%AA%8C%E6%9D%82%E8%AE%B02/"/>
      <url>/DoublePeach/myblog/2022/09/20/%E7%94%B5%E5%95%86%E9%A1%B9%E7%9B%AE%E7%BB%8F%E9%AA%8C%E6%9D%82%E8%AE%B02/</url>
      
        <content type="html"><![CDATA[<h1 id="1-前端接收后端返回数据时的问题"><a href="#1-前端接收后端返回数据时的问题" class="headerlink" title="1.前端接收后端返回数据时的问题"></a>1.前端接收后端返回数据时的问题</h1><p>在写用户信息加载的时候，前端ajax请求成功发到后端，也成功返回了json格式的字符串，但取json中的属性值就是不成功。<br>最后发现，success中的回调函数的参数不能直接为data，然后data.username，而是json.data.username</p><img src="/2022/09/20/%E7%94%B5%E5%95%86%E9%A1%B9%E7%9B%AE%E7%BB%8F%E9%AA%8C%E6%9D%82%E8%AE%B02/47f83e75b8c568e7a243d56c0784e1e1.png" class><p><strong>这里有个前端小知识点：设置单选框radio是否选中要用prop函数，即：选择器.prop(‘checked’,true)</strong></p><h1 id="2-在做头像上传业务功能时的一些收获"><a href="#2-在做头像上传业务功能时的一些收获" class="headerlink" title="2.在做头像上传业务功能时的一些收获"></a>2.在做头像上传业务功能时的一些收获</h1><p>（这个因为没接触过，所以记了挺多东西）</p><ul><li>文件上传的文件处理以及异常规划类都写在控制层内，因为带有文件数据包，层与层之间传递包影响效率<br>文件上传时，使用SpringMVC中提供的MultipartFile接口作为控制器的参数，接收前端发来的文件内的数据包\</li></ul><img src="/2022/09/20/%E7%94%B5%E5%95%86%E9%A1%B9%E7%9B%AE%E7%BB%8F%E9%AA%8C%E6%9D%82%E8%AE%B02/37d01d1ea6666d996670690cbb0a791c.png" class><p>前端页面这里采用form表单进行提交，必须要填enctype属性</p><img src="/2022/09/20/%E7%94%B5%E5%95%86%E9%A1%B9%E7%9B%AE%E7%BB%8F%E9%AA%8C%E6%9D%82%E8%AE%B02/809ce5bdd433e7623ad9b18f11757835.png" class><ul><li>上传头像时，当上传的头像大于设定的10MB时，不按预期抛出自定义异常，而是抛出了tomcat的FileSize异常<br>问题的根源：tomcat默认设置能接收HTTP POST请求的大小最大为2M,如果你的POST请求传递的数据大于2M,就会报错误。<br>解决的办法：修改tomcat的配置文件C:&#x2F;MinyooCMS&#x2F;tomcat&#x2F;conf&#x2F;server.xml(或者安装在D盘文件路径是D: &#x2F;MinyooCMS&#x2F;tomcat&#x2F;conf&#x2F;server.xml),找到里面的<Connector>标签,在该标签中添 加”maxPostSize”属性,将该属性值设置成你想要的最大值,单位是字节,或者把这个值设置为 0(maxPostSize&#x3D;”0”),tomcat将不再检查POST的大小。即可解决上述问题。<br>springboot的项目使用的都是内嵌的Tomcat服务器，因此不好按上述修改配置文件。<br>可以在springboot的主配置文件中声明最大文件设置：</Connector></li></ul><img src="/2022/09/20/%E7%94%B5%E5%95%86%E9%A1%B9%E7%9B%AE%E7%BB%8F%E9%AA%8C%E6%9D%82%E8%AE%B02/b02471469f9ac3eb22ede96f4a0a9d9f.png" class><ul><li><p>修改头像向后端传输的是文件，而serio()只能用来传递字符串等类型的表单参数，<br>所以这里data属性因使用js中的FormData对象来封装并传递文件数据，并且要设置processData和contentType属性，如下：</p><img src="/2022/09/20/%E7%94%B5%E5%95%86%E9%A1%B9%E7%9B%AE%E7%BB%8F%E9%AA%8C%E6%9D%82%E8%AE%B02/1c8f471e978eab22096dc89fc41fe80c.png" class></li><li><p>最后在前端页面中使用了cookie技术，将上传的头像保存在cookie中，并设置过期时间为7天<br>这样在有效期内每次需要展示用户头像的时候，都不需要再查数据库，而是直接从cookie中取即可</p></li></ul><p>对应的实现代码在本机的：E:\src_htt\Spring\projects\computer_store\src\main\resources\static\web\upload.html 中</p><ul><li>这个头像上传还可以做优化，比如Controller层可以简化，把业务逻辑和异常处理都放在业务层<br>（不过在控制层也有好处就是减少数据传输造成性能损失）</li></ul>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电商项目经验杂记1</title>
      <link href="/DoublePeach/myblog/2022/09/15/%E7%94%B5%E5%95%86%E9%A1%B9%E7%9B%AE%E7%BB%8F%E9%AA%8C%E6%9D%82%E8%AE%B01/"/>
      <url>/DoublePeach/myblog/2022/09/15/%E7%94%B5%E5%95%86%E9%A1%B9%E7%9B%AE%E7%BB%8F%E9%AA%8C%E6%9D%82%E8%AE%B01/</url>
      
        <content type="html"><![CDATA[<p>记录一些自己在电商项目上遇到和解决了一些问题的经验，提高日后的开发能力和效率</p><h1 id="1、使用逆向工程生成实体类和Mapper"><a href="#1、使用逆向工程生成实体类和Mapper" class="headerlink" title="1、使用逆向工程生成实体类和Mapper"></a>1、使用逆向工程生成实体类和Mapper</h1><p>本机逆向工程代码实例位置：E:\devTools\maven-tools\逆向工程实例代码\mybatis-generator</p><h2 id="逆向工程生成的类中有很多的注释，批量删除注释的方法："><a href="#逆向工程生成的类中有很多的注释，批量删除注释的方法：" class="headerlink" title="逆向工程生成的类中有很多的注释，批量删除注释的方法："></a>逆向工程生成的类中有很多的注释，批量删除注释的方法：</h2><p>**ctrl + R 正则表达式匹配： **</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(/\*([^*]|[\r\n]|(\*+([^*/]|[\r\n])))*\*+/|[ \t]*//.*)</span><br></pre></td></tr></table></figure><h2 id="2、单元测试写法："><a href="#2、单元测试写法：" class="headerlink" title="2、单元测试写法："></a>2、单元测试写法：</h2><p>单元测试时，自定义的测试类要这么写：</p><img src="/2022/09/15/%E7%94%B5%E5%95%86%E9%A1%B9%E7%9B%AE%E7%BB%8F%E9%AA%8C%E6%9D%82%E8%AE%B01/e8f14b5f9664ae51a9972bc6f1f4f991.png" class><h1 id="3、Service层处理业务逻辑功能更清晰"><a href="#3、Service层处理业务逻辑功能更清晰" class="headerlink" title="3、Service层处理业务逻辑功能更清晰"></a>3、Service层处理业务逻辑功能更清晰</h1><p>例如：service层下有异常处理包，有service接口，有接口的实现类impl包</p><p><strong>快捷键：ctrl + alt + t 对选中的代码块进行环绕，例如 if 、while 、for 、try等等</strong></p><h1 id="4、service中的注册功能进行密码加密："><a href="#4、service中的注册功能进行密码加密：" class="headerlink" title="4、service中的注册功能进行密码加密："></a>4、service中的注册功能进行密码加密：</h1><img src="/2022/09/15/%E7%94%B5%E5%95%86%E9%A1%B9%E7%9B%AE%E7%BB%8F%E9%AA%8C%E6%9D%82%E8%AE%B01/728bc69fd4c4d0a9b285a2109410fc4b.png" class><p><strong>盐值若不记录在数据库的话，会导致登录功能有误</strong></p><h2 id="外部定义一个调md5加密算法的方法："><a href="#外部定义一个调md5加密算法的方法：" class="headerlink" title="外部定义一个调md5加密算法的方法："></a>外部定义一个调md5加密算法的方法：</h2><img src="/2022/09/15/%E7%94%B5%E5%95%86%E9%A1%B9%E7%9B%AE%E7%BB%8F%E9%AA%8C%E6%9D%82%E8%AE%B01/e5fd33aa360e962863620c416b2ad366.png" class><h1 id="5、控制层封装响应结果集对象"><a href="#5、控制层封装响应结果集对象" class="headerlink" title="5、控制层封装响应结果集对象"></a>5、控制层封装响应结果集对象</h1><p>当中要包含状态码、描述信息、带泛型<E>的数据，以此对象返回前端</E></p><p>其中描述信息中，要将捕获的异常赋值进去，这样前端就能显示后台出了什么问题</p><h1 id="6、Controller层定义用于统一异常处理的基类BaseController"><a href="#6、Controller层定义用于统一异常处理的基类BaseController" class="headerlink" title="6、Controller层定义用于统一异常处理的基类BaseController"></a>6、Controller层定义用于统一异常处理的基类BaseController</h1><h2 id="使用-ExceptionHandler-要拦截的异常类-class-注解进行异常统一拦截处理"><a href="#使用-ExceptionHandler-要拦截的异常类-class-注解进行异常统一拦截处理" class="headerlink" title="使用@ExceptionHandler(要拦截的异常类.class) 注解进行异常统一拦截处理"></a>使用@ExceptionHandler(要拦截的异常类.class) 注解进行异常统一拦截处理</h2><p>@ExceptionHandler注解用于统一处理方法抛出的异常。当我们使用这个注解时，需要定义一个 异常的处理方法，再给这个方法加上@ExceptionHandler注解，这个方法就会处理类中其他方法 （被@RequestMapping注解）抛出的异常。@ExceptionHandler注解中可以添加参数，参数是某 个异常类的class，代表这个方法专门处理该类异常。</p><img src="/2022/09/15/%E7%94%B5%E5%95%86%E9%A1%B9%E7%9B%AE%E7%BB%8F%E9%AA%8C%E6%9D%82%E8%AE%B01/3fe7d2f8eb6705af4c72ad126baed260.png" class><p>又回顾了一遍ajax局部刷新向后台发送请求的流程，学习了一个新的传递参数的方式：<br>使用Ajax传递参数的时候，可以<strong>用serialize直接获取被选择的表单内所有参数值</strong>，<br>一起传值给后端，后端使用的springboot的话可以自动装配参数</p><img src="/2022/09/15/%E7%94%B5%E5%95%86%E9%A1%B9%E7%9B%AE%E7%BB%8F%E9%AA%8C%E6%9D%82%E8%AE%B01/f427b05692ec3eee67addade1437413c.png" class><br><br><h1 id="7、使用会话Session的收获"><a href="#7、使用会话Session的收获" class="headerlink" title="7、使用会话Session的收获"></a>7、使用会话Session的收获</h1><p>用session进行登录功能时，将获取session的对象封装到了controller层的基类中 (controller层中所有的controller都继承这个基类)</p><img src="/2022/09/15/%E7%94%B5%E5%95%86%E9%A1%B9%E7%9B%AE%E7%BB%8F%E9%AA%8C%E6%9D%82%E8%AE%B01/20c16830a5ec1b0cd94b2679b63997d4.png" class><br><h1 id="8、使用框架中的拦截器HandlerInterceptor："><a href="#8、使用框架中的拦截器HandlerInterceptor：" class="headerlink" title="8、使用框架中的拦截器HandlerInterceptor："></a>8、使用框架中的拦截器HandlerInterceptor：</h1><p>在访问某些页面时拦截未登录的用户，有三个方法，一般只用preHandle()方法</p><img src="/2022/09/15/%E7%94%B5%E5%95%86%E9%A1%B9%E7%9B%AE%E7%BB%8F%E9%AA%8C%E6%9D%82%E8%AE%B01/becdb303c1ce55da76fcd27c98c3989a.png" class><p>有拦截器还不够，因为有些页面，用户未登录也可以访问，不能全部拦截<br><strong>所以需要使用servlet中的过滤器来指定白名单(未登录可以访问的url)和黑名单(未登录不能访问的url)</strong></p><br><h1 id="9、servlet中的过滤器："><a href="#9、servlet中的过滤器：" class="headerlink" title="9、servlet中的过滤器："></a>9、servlet中的过滤器：</h1><img src="/2022/09/15/%E7%94%B5%E5%95%86%E9%A1%B9%E7%9B%AE%E7%BB%8F%E9%AA%8C%E6%9D%82%E8%AE%B01/6480410e873ed7aeec97599cb353c1e7.png" class><br><br>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux+nginx部署静态网站步骤以及访问nginx遇到的问题解决</title>
      <link href="/DoublePeach/myblog/2022/08/28/Linux-nginx%E9%83%A8%E7%BD%B2%E9%9D%99%E6%80%81%E7%BD%91%E7%AB%99%E6%AD%A5%E9%AA%A4%E4%BB%A5%E5%8F%8A%E8%AE%BF%E9%97%AEnginx%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
      <url>/DoublePeach/myblog/2022/08/28/Linux-nginx%E9%83%A8%E7%BD%B2%E9%9D%99%E6%80%81%E7%BD%91%E7%AB%99%E6%AD%A5%E9%AA%A4%E4%BB%A5%E5%8F%8A%E8%AE%BF%E9%97%AEnginx%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/</url>
      
        <content type="html"><![CDATA[<p><strong>首先说一下使用linux+nginx部署静态网站的步骤：</strong><br><strong>这里以ace静态网站为例，说明部署此类静态网站步骤：</strong></p><h1 id="一、linux-nginx部署ace静态网站："><a href="#一、linux-nginx部署ace静态网站：" class="headerlink" title="一、linux+nginx部署ace静态网站："></a>一、linux+nginx部署ace静态网站：</h1><h2 id="1、使用传输工具将项目传输到linux的-x2F-opt-x2F-www-x2F-ace目录下"><a href="#1、使用传输工具将项目传输到linux的-x2F-opt-x2F-www-x2F-ace目录下" class="headerlink" title="1、使用传输工具将项目传输到linux的&#x2F;opt&#x2F;www&#x2F;ace目录下"></a>1、使用传输工具将项目传输到linux的&#x2F;opt&#x2F;www&#x2F;ace目录下</h2><h2 id="2、使用vim修改nginx-1-14-2-x2F-conf-x2F-nginx-conf中的配置文件"><a href="#2、使用vim修改nginx-1-14-2-x2F-conf-x2F-nginx-conf中的配置文件" class="headerlink" title="2、使用vim修改nginx-1.14.2&#x2F;conf&#x2F;nginx.conf中的配置文件:"></a>2、使用vim修改nginx-1.14.2&#x2F;conf&#x2F;nginx.conf中的配置文件:</h2><p>即修改location中的请求拦截转发<br>location后面跟的是url中的请求地址<br>root后跟的是项目ace源文件在linux文件中的磁盘位置<br>index后面跟的是访问此项目时默认跳转的页面</p><img src="/2022/08/28/Linux-nginx%E9%83%A8%E7%BD%B2%E9%9D%99%E6%80%81%E7%BD%91%E7%AB%99%E6%AD%A5%E9%AA%A4%E4%BB%A5%E5%8F%8A%E8%AE%BF%E9%97%AEnginx%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/img.png" class><p><strong>这里要注意路径问题，源文件的位置必须放在root + &#x2F;ace 里面</strong></p><h2 id="3、修改完成后重启nginx"><a href="#3、修改完成后重启nginx" class="headerlink" title="3、修改完成后重启nginx"></a>3、修改完成后重启nginx</h2><p>至此，即可正常访问部署的静态网站</p><h1 id="二、部署nginx时遇到的问题解决："><a href="#二、部署nginx时遇到的问题解决：" class="headerlink" title="二、部署nginx时遇到的问题解决："></a>二、部署nginx时遇到的问题解决：</h1><p>这里出现问题：<br><strong>访问192.168.10.129&#x2F;ace时，出现无法访问，如下图这样</strong></p><img src="/2022/08/28/Linux-nginx%E9%83%A8%E7%BD%B2%E9%9D%99%E6%80%81%E7%BD%91%E7%AB%99%E6%AD%A5%E9%AA%A4%E4%BB%A5%E5%8F%8A%E8%AE%BF%E9%97%AEnginx%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/img_1.png" class><h2 id="1、原因："><a href="#1、原因：" class="headerlink" title="1、原因："></a>1、原因：</h2><p>磁盘中有若干nginx配置文件，未加载到正确的nginx.conf配置文件导致拦截转发请求失败</p><h2 id="2、解决"><a href="#2、解决" class="headerlink" title="2、解决"></a>2、解决</h2><h3 id="方法1："><a href="#方法1：" class="headerlink" title="方法1："></a>方法1：</h3><p>采用指定配置文件方式启动nginx服务：<br><code>./nginx -c /usr/soft/nginx/nginx-1.14.2/conf/nginx.conf</code></p><h3 id="方法2："><a href="#方法2：" class="headerlink" title="方法2："></a>方法2：</h3><p>修改nginx服务启动时的默认配置文件加载<br>修改方式如下：<br>####<strong>（1）查看Nginx默认配置文件nginx.conf路径</strong><br><code>nginx -t</code></p><p>查看到Nginx默认配置文件路径位置是：<br><code>/usr/local/nginx/conf/nginx.conf，可按以下步骤将其更改到/xxx/nginx路径下。</code></p><p>####<strong>（2）将原文件移动到需要更改的目录</strong><br><code>mv /usr/local/nginx/conf/nginx.conf /xxx/nginx/</code></p><p>####<strong>（3）创建连接到原目录</strong><br><code>ln -s /xxx/nginx/nginx.conf /usr/local/nginx/conf/</code></p><p>####<strong>（4）启动&#x2F;重启Nginx</strong><br><code>/usr/local/nginx/sbin/nginx 或 /usr/local/nginx/sbin/nginx -s reload</code></p><p><strong>推荐使用第一种方式，指定配置文件的加载，更加灵活</strong></p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用springboot配置文件对源代码实现解耦合</title>
      <link href="/DoublePeach/myblog/2022/08/25/%E4%BD%BF%E7%94%A8springboot%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%AF%B9%E6%BA%90%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E8%A7%A3%E8%80%A6%E5%90%88/"/>
      <url>/DoublePeach/myblog/2022/08/25/%E4%BD%BF%E7%94%A8springboot%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%AF%B9%E6%BA%90%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E8%A7%A3%E8%80%A6%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h1 id="0、前言"><a href="#0、前言" class="headerlink" title="0、前言"></a>0、前言</h1><p>今天在做项目的时候，<strong>写一个无session登录拦截以及部分页面放行的功能时</strong>，使用的传统方法，当配置项过多、并且这些配置项以后可能会更改，这种传统的方式将所有的配置项都写死在了java类中，感觉耦合度非常高，<strong>所以我就想：能不能对这种方式做一些优化？我想了很多种方案，不断尝试，例如使用注解注入配置文件的方式，</strong>我试了以下几种注解注入，结果要不就是报一堆异常，要不就是不能达到目的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ImportResource(&quot;classpath:ListUrl.yml&quot;)</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:ListUrl.yml&quot;)</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(&quot;whitelist&quot;)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(LoginFilterConfig.class)</span></span><br></pre></td></tr></table></figure><p><strong>最后，功夫不负有心人，我找到了一种堪称完美的方式：使用springboot配置文件+Data赋值注入的方式，实现解耦合！</strong></p><p><strong>再介绍我这种方式之前，先给大家看看传统的方式完成登录拦截和放行功能的写法：</strong></p><h1 id="1、传统写法"><a href="#1、传统写法" class="headerlink" title="1、传统写法"></a>1、传统写法</h1><h2 id="（1）定义一个拦截器，并实现HandlerInterceptor并配置拦截条件以及页面跳转"><a href="#（1）定义一个拦截器，并实现HandlerInterceptor并配置拦截条件以及页面跳转" class="headerlink" title="（1）定义一个拦截器，并实现HandlerInterceptor并配置拦截条件以及页面跳转"></a>（1）定义一个拦截器，并实现HandlerInterceptor并配置拦截条件以及页面跳转</h2><img src="/2022/08/25/%E4%BD%BF%E7%94%A8springboot%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%AF%B9%E6%BA%90%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E8%A7%A3%E8%80%A6%E5%90%88/a7c17cb5ec527df928e232c63e0ae6f6.png" class><h2 id="（2）定义过滤器类，并实现WebMvcConfigurer接口中的addInterceptors"><a href="#（2）定义过滤器类，并实现WebMvcConfigurer接口中的addInterceptors" class="headerlink" title="（2）定义过滤器类，并实现WebMvcConfigurer接口中的addInterceptors"></a>（2）定义过滤器类，并实现WebMvcConfigurer接口中的addInterceptors</h2><p><strong>手动创建List集合，并将放行的页面的字符串一个个添加到list中</strong></p><img src="/2022/08/25/%E4%BD%BF%E7%94%A8springboot%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%AF%B9%E6%BA%90%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E8%A7%A3%E8%80%A6%E5%90%88/4406f8deb4fc7ba9411007e146fd7ae5.png" class><h2 id="完成"><a href="#完成" class="headerlink" title="完成"></a>完成</h2><p>​这样就使用传统的方式完成了登录拦截和部分页面放行的功能，<strong>但这种方式从代码上看，很明显的一个缺陷就是设置放行页面时，代码耦合度太高，</strong>将来某一天想取消放行或增加额外的放行页面时，还需要修改java源代码。</p><p>​<strong>所以我想到了使用配置文件的方式，将这些放行页面的路径字符串添加为springboot的list集合配置项，然后在java代码中注入该集合，实现配置文件的读取。</strong></p><p><strong>将来修改放行页面时直接在配置文件中改，这样不就耦合度大大降低了吗？</strong></p><h1 id="2、配置文件的方式"><a href="#2、配置文件的方式" class="headerlink" title="2、配置文件的方式"></a>2、配置文件的方式</h1><h2 id="（1）配置拦截器，这步同上，没有变化"><a href="#（1）配置拦截器，这步同上，没有变化" class="headerlink" title="（1）配置拦截器，这步同上，没有变化"></a>（1）配置拦截器，这步同上，没有变化</h2><h2 id="（2）springboot主配置文件声明配置项"><a href="#（2）springboot主配置文件声明配置项" class="headerlink" title="（2）springboot主配置文件声明配置项"></a>（2）springboot主配置文件声明配置项</h2><p>​<strong>这里一定要注意List集合在yml配置文件中的书写方式</strong></p><p>​<strong>- 与 list元素之间有空格！</strong></p><img src="/2022/08/25/%E4%BD%BF%E7%94%A8springboot%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%AF%B9%E6%BA%90%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E8%A7%A3%E8%80%A6%E5%90%88/5a2c73825d02143d502337650f9661ff.png" class><h2 id="（3）配置拦截器"><a href="#（3）配置拦截器" class="headerlink" title="（3）配置拦截器"></a>（3）配置拦截器</h2><h3 id="注解作用以及原理解释："><a href="#注解作用以及原理解释：" class="headerlink" title="***注解作用以及原理解释："></a>***注解作用以及原理解释：</h3><p>​<strong>- 使用Lombok中的@Data注解进行属性的赋值注入</strong></p><p>​<strong>- 添加了@Configuration注解后，此类会被spring容器标记为配置类，springboot会将其主配置文件application.yml中的配置项与此类中的属性进行”按名对应“，并通过Set方法注入（此步使用@Data自动完成）</strong></p><p>​<strong>- @ConfigurationProperties注解设置配置项的前缀</strong></p><img src="/2022/08/25/%E4%BD%BF%E7%94%A8springboot%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%AF%B9%E6%BA%90%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E8%A7%A3%E8%80%A6%E5%90%88/b04270d66878745c37583e460a171f4e.png" class><h2 id="完成-1"><a href="#完成-1" class="headerlink" title="完成"></a>完成</h2><p>​<strong>这样，优化后的这种读取配置文件的方式实现登录拦截放行功能就完成了，相比传统的那种，不仅代码更简洁，而且耦合度更低，代码更易于修改维护管理，以后遇到类似的可以使用配置文件解耦合的地方可以经常使用！！！</strong></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排除Bug的一些记录</title>
      <link href="/DoublePeach/myblog/2022/08/20/%E6%8E%92%E9%99%A4Bug%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AE%B0%E5%BD%95/"/>
      <url>/DoublePeach/myblog/2022/08/20/%E6%8E%92%E9%99%A4Bug%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>本文记录了一些在网站开发初期遇到的常见问题以及解决方法，记录在这里用于巩固自己记忆以及帮助搜索这些问题的人能更快地解决问题！</p><h1 id="1、远程部署网站后未加载最新的文章"><a href="#1、远程部署网站后未加载最新的文章" class="headerlink" title="1、远程部署网站后未加载最新的文章"></a>1、远程部署网站后未加载最新的文章</h1><p>使用hexo new “” ，创建文章并完成，上传gitee、部署网站、刷新后发现新文章仍未发布<br>这种情况一般是上传问题！</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">首先检查hexo d上传后的gitee仓库的最后一次更新时间是否为&quot;刚刚&quot;</span><br><span class="line">若不是，则检查_config.yml中的仓库地址repository和分支branch是否正确</span><br><span class="line">若是，则在giteePages服务页中，手动点击更新，待重新部署后，文章正常显示！</span><br></pre></td></tr></table></figure><h1 id="2、使用md语法写的文章图片不显示或加载失败"><a href="#2、使用md语法写的文章图片不显示或加载失败" class="headerlink" title="2、使用md语法写的文章图片不显示或加载失败"></a>2、使用md语法写的文章图片不显示或加载失败</h1><h2 id="1-我们需要安装一个图片路径转换的插件，插件名字为hexo-asset-image，只需执行以下命令"><a href="#1-我们需要安装一个图片路径转换的插件，插件名字为hexo-asset-image，只需执行以下命令" class="headerlink" title="(1)我们需要安装一个图片路径转换的插件，插件名字为hexo-asset-image，只需执行以下命令"></a>(1)我们需要安装一个图片路径转换的插件，插件名字为hexo-asset-image，只需执行以下命令</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">先进入你的hexo根目录下，然后执行以下命令下载插件</span><br><span class="line">npm install https://github.com/7ym0n/hexo-asset-image --save</span><br></pre></td></tr></table></figure><h2 id="2-打开hexo根目录下的-config-yml文件，修改post-asset-folder为true"><a href="#2-打开hexo根目录下的-config-yml文件，修改post-asset-folder为true" class="headerlink" title="(2)打开hexo根目录下的_config.yml文件，修改post_asset_folder为true"></a>(2)打开hexo根目录下的_config.yml文件，修改post_asset_folder为true</h2><p>这一步的目的是：打开文章资源文件夹功能。<br>当资源文件管理功能打开后，Hexo将会在你每一次通过 hexo new 命令创建新文章时自动创建一个文件夹。<br>这个资源文件夹将会有与这个md文件一样的名字。将所有与你的文章有关的资源放在这个关联文件夹中之后，<br>你可以通过相对路径来引用它们，这样你就得到了一个更简单而且方便得多的工作流。</p><h2 id="3-使用相对路径引用图片或其他静态资源"><a href="#3-使用相对路径引用图片或其他静态资源" class="headerlink" title="(3)使用相对路径引用图片或其他静态资源"></a>(3)使用相对路径引用图片或其他静态资源</h2><p>在md语法中，使用的是这种方式引用图片：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用! [](你的博文名字/图片名称)插入图片即可。</span><br></pre></td></tr></table></figure><p>但是在hexo3之后这种语法已经不适用了，引用资源时采用下面这种方式：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">首先将图片等静态资源放在hexo new 命令执行后生成的同名文件夹中</span><br><span class="line">然后在图片引用处：</span><br><span class="line">&#123;% asset_img &quot;图片名称&amp;后缀&quot; &quot;图片描述信息&quot; %&#125;</span><br></pre></td></tr></table></figure><p>官方参考使用说明地址：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://hexo.io/zh-cn/docs/asset-folders</span><br></pre></td></tr></table></figure><p>问题解决参考博主地址：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://blog.csdn.net/weixin_33827590/article/details/93066614?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-93066614-blog-113460538.pc_relevant_multi_platform_whitelistv4eslandingrelevant2&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-93066614-blog-113460538.pc_relevant_multi_platform_whitelistv4eslandingrelevant2&amp;utm_relevant_index=1</span><br></pre></td></tr></table></figure><h1 id="3、访问网站时样式加载失败"><a href="#3、访问网站时样式加载失败" class="headerlink" title="3、访问网站时样式加载失败"></a>3、访问网站时样式加载失败</h1><p>这个问题是比较常见的一个问题了，即使之前我解决过，但今天居然又遇到这种情况，但很快也又解决了！<br>我分享一下我面对这个问题的一个解决思路：</p><p>1、一般都是路径错误，在网页端按F12进入调试页，就可以查看样式未加载的404报错信息中的URL错误<br>2、观察仓库中图片的路径<br>3、在hexo g生成的public文件夹中的index.html中查看css引用地址和仓库中的图片路径的不同之处</p><img src="/2022/08/20/%E6%8E%92%E9%99%A4Bug%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AE%B0%E5%BD%95/img.png" class><p>4、一般都是根路径的问题，我这里的root直接为”&#x2F;“，表示为仓库的根路径<br>这样在引用图片的时候不需要加格外的相对路径，直接输入图片名称即可引用</p><img src="/2022/08/20/%E6%8E%92%E9%99%A4Bug%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AE%B0%E5%BD%95/img_1.png" class><h1 id="4、网站URL取消子域名"><a href="#4、网站URL取消子域名" class="headerlink" title="4、网站URL取消子域名"></a>4、网站URL取消子域名</h1><p>之前我这个博客的网站地址是<a href="https://doublepeach/gitee.io/Doublepeach/git.io">https://Doublepeach/gitee.io/Doublepeach/git.io</a><br>可以看到，这个网址比较长，而且前后域名和子域名重复，完全一样。<br>而现在的域名：<a href="https://doublepeach.gitee.io/">https://doublepeach.gitee.io</a> 就简洁多了 ，那怎么做到的呢？<br>(1)首先在仓库的管理页中，将仓库名称和仓库地址修改为一样的，如下：</p><img src="/2022/08/20/%E6%8E%92%E9%99%A4Bug%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AE%B0%E5%BD%95/img_2.png" class><p>(2)然后在hexo根目录下的_config.yml文件中修改repository仓库地址为新地址<br>(3)还是在_config.yml中,修改URL为 https:&#x2F;&#x2F;仓库名.gitee.io 即可</p><h1 id="5、文章模板设设置"><a href="#5、文章模板设设置" class="headerlink" title="5、文章模板设设置"></a>5、文章模板设设置</h1><p>每次hexo new 新文章时都需要写一些顶部的文章配置，为了方便，可以直接修改创建文件时的模板内容<br>修改位置为：  hexo根目录下的scaffolds(脚手架)下的post.md<br>这里推荐的常用模板：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">tags: 标签</span><br><span class="line">description: 描述信息</span><br><span class="line">sticky: 优先级</span><br><span class="line">comments: 是否开启评论(true或false)</span><br><span class="line">keywords: 关键字</span><br><span class="line">top_img: 顶部图片</span><br><span class="line">---</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于hexo部署到gitee时图片无法加载问题的完美解决</title>
      <link href="/DoublePeach/myblog/2022/08/19/%E5%85%B3%E4%BA%8Ehexo%E9%83%A8%E7%BD%B2%E5%88%B0gitee%E6%97%B6%E5%9B%BE%E7%89%87%E6%97%A0%E6%B3%95%E5%8A%A0%E8%BD%BD%E9%97%AE%E9%A2%98%E7%9A%84%E5%AE%8C%E7%BE%8E%E8%A7%A3%E5%86%B3/"/>
      <url>/DoublePeach/myblog/2022/08/19/%E5%85%B3%E4%BA%8Ehexo%E9%83%A8%E7%BD%B2%E5%88%B0gitee%E6%97%B6%E5%9B%BE%E7%89%87%E6%97%A0%E6%B3%95%E5%8A%A0%E8%BD%BD%E9%97%AE%E9%A2%98%E7%9A%84%E5%AE%8C%E7%BE%8E%E8%A7%A3%E5%86%B3/</url>
      
        <content type="html"><![CDATA[<h1 id="一、问题"><a href="#一、问题" class="headerlink" title="一、问题"></a>一、问题</h1><p>使用hexo部署静态网站或博客时，经常会有一个问题：明明导入了图片以及其他的js文件以及css文件，也成功部署了网站，但访问时，无论是图片还是样式就是加载不出来？？！！</p><p>这篇文章记录了我发现问题，并一步一步排除问题的过程。若不想听我絮絮叨debug过程，想直接解决问题，可直接跳到总结即可。</p><br><h1 id="二、问题查找"><a href="#二、问题查找" class="headerlink" title="二、问题查找"></a>二、问题查找</h1><p>前段时间在github上部署的时候也出现过图片样式不加载的问题，当时查找出来的问题是_config.yml文件中的url和root错误，修改完后还在csdn社区发帖子记录了这个问题以及解决方案。</p><p>万万没想到，才没过几天，我又遇到了css样式无法加载的这个问题。由于github访问速度实在受不了，所以这次我是想部署到gitee上，没想到又遇到这个问题，我第一反应是几天前的那个问题，但我检查后发现并没有修改，url和root都和在github部署时一样，</p><p>那是什么原因导致的呢？我带着这个疑问，看了网上其他的一些博主的解决方案，试了好几个还是无法解决样式不加载的问题，最后我看到了一篇文章中提到的一个观点，让我突然醍醐灌顶：<strong>在hexo g 渲染命令执行后，生成的public文件夹中的index.html文件中的路径不匹配资源或拼接的路径有误</strong>，我立马就去hexo g查看了我的public下的index.html中的资源路径引用，果然发现了问题</p><img src="/2022/08/19/%E5%85%B3%E4%BA%8Ehexo%E9%83%A8%E7%BD%B2%E5%88%B0gitee%E6%97%B6%E5%9B%BE%E7%89%87%E6%97%A0%E6%B3%95%E5%8A%A0%E8%BD%BD%E9%97%AE%E9%A2%98%E7%9A%84%E5%AE%8C%E7%BE%8E%E8%A7%A3%E5%86%B3/30e757e95c930ecf1c48dfd7935be3ad.png" class title="图片"><p>这路径，一看就不合法呀，”&#x2F;.&#x2F;“是什么鬼？! <strong>所以我立马就定位到是我引入图片资源时配置的路径的问题</strong>，然后我将主题配置文件中所有的.&#x2F;都修改为&#x2F; 。如下：</p><img src="/2022/08/19/%E5%85%B3%E4%BA%8Ehexo%E9%83%A8%E7%BD%B2%E5%88%B0gitee%E6%97%B6%E5%9B%BE%E7%89%87%E6%97%A0%E6%B3%95%E5%8A%A0%E8%BD%BD%E9%97%AE%E9%A2%98%E7%9A%84%E5%AE%8C%E7%BE%8E%E8%A7%A3%E5%86%B3/a18be1fedea1c2b632c3def8987c9217.png" class><p>这样再hexo g编译时生成的资源路径拼接就正确了，如下：</p><img src="/2022/08/19/%E5%85%B3%E4%BA%8Ehexo%E9%83%A8%E7%BD%B2%E5%88%B0gitee%E6%97%B6%E5%9B%BE%E7%89%87%E6%97%A0%E6%B3%95%E5%8A%A0%E8%BD%BD%E9%97%AE%E9%A2%98%E7%9A%84%E5%AE%8C%E7%BE%8E%E8%A7%A3%E5%86%B3/667bd3bd00a1932b3f678abe99a1ca8b.png" class><p>解决了路径问题后我立马开启hexo三件套hexo clean 、hexo g 、 hexo d 上传、重部署、刷新！结果。。。还是css样式不加载。。。我人傻了，懵了好一整子，<strong>痛定思痛</strong>，决定再细细走一边这个路径问题，在我鼠标跟着大脑逻辑一阵跳转后，终于发现：<strong>还是路径问题，只不过这个路径问题是仓库路径根路径问题</strong></p><p>原先我的url和root是这样的：</p><img src="/2022/08/19/%E5%85%B3%E4%BA%8Ehexo%E9%83%A8%E7%BD%B2%E5%88%B0gitee%E6%97%B6%E5%9B%BE%E7%89%87%E6%97%A0%E6%B3%95%E5%8A%A0%E8%BD%BD%E9%97%AE%E9%A2%98%E7%9A%84%E5%AE%8C%E7%BE%8E%E8%A7%A3%E5%86%B3/9cd6bd88bce3c8702aa19ca941bc390d.png" class><p>但事实上，<strong>这里的url是要填写最终网站部署的url，而root根路径就是代表仓库本身，而hexo g 是直接把各种静态资源放在了重渲染后生成的public文件夹，并且hexo d上传时也只上传public文件夹中的资源</strong>，所以root这里不需要加任何东西，如下：</p><img src="/2022/08/19/%E5%85%B3%E4%BA%8Ehexo%E9%83%A8%E7%BD%B2%E5%88%B0gitee%E6%97%B6%E5%9B%BE%E7%89%87%E6%97%A0%E6%B3%95%E5%8A%A0%E8%BD%BD%E9%97%AE%E9%A2%98%E7%9A%84%E5%AE%8C%E7%BE%8E%E8%A7%A3%E5%86%B3/f9f8b97b92235fab9a07cd98af74c133.png" class><p><strong>然后，三件套重部署后，刷新！噫！成了！！！css等样式都正常加载，其他资源也能正常访问！ 完美解决！</strong></p><h1 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h1><h3 id="1、修改-config-yml文件中的url和root"><a href="#1、修改-config-yml文件中的url和root" class="headerlink" title="1、修改_config.yml文件中的url和root"></a>1、修改_config.yml文件中的url和root</h3><p>如图：</p><img src="/2022/08/19/%E5%85%B3%E4%BA%8Ehexo%E9%83%A8%E7%BD%B2%E5%88%B0gitee%E6%97%B6%E5%9B%BE%E7%89%87%E6%97%A0%E6%B3%95%E5%8A%A0%E8%BD%BD%E9%97%AE%E9%A2%98%E7%9A%84%E5%AE%8C%E7%BE%8E%E8%A7%A3%E5%86%B3/f9f8b97b92235fab9a07cd98af74c133.png" class><p><strong>其中url为自己最终部署的网站地址，gitee上为pages页中的以下路径：</strong></p><img src="/2022/08/19/%E5%85%B3%E4%BA%8Ehexo%E9%83%A8%E7%BD%B2%E5%88%B0gitee%E6%97%B6%E5%9B%BE%E7%89%87%E6%97%A0%E6%B3%95%E5%8A%A0%E8%BD%BD%E9%97%AE%E9%A2%98%E7%9A%84%E5%AE%8C%E7%BE%8E%E8%A7%A3%E5%86%B3/098e3a413146d4622cf8a40560a5cb6f.png" class><h3 id="2、检查资源路径问题"><a href="#2、检查资源路径问题" class="headerlink" title="2、检查资源路径问题"></a>2、检查资源路径问题</h3><p><strong>查看hexo g后的public文件夹中的index.html文件中的静态资源引用，url拼接是否正确</strong>,若不正确或有明显拼接错误的，在资源引用处修改，这里每个人的情况不一样，就不上图了，只要注意一点：“ url + root + 资源引入 ” 这三个拼接起来要等于你要引入的静态资源在上传gitee后的仓库中的资源路径。</p><br><h3 id="这样就可以完美解决问题了，文章图片正常加载！！！"><a href="#这样就可以完美解决问题了，文章图片正常加载！！！" class="headerlink" title="这样就可以完美解决问题了，文章图片正常加载！！！"></a>这样就可以完美解决问题了，文章图片正常加载！！！</h3>]]></content>
      
      
      
        <tags>
            
            <tag> hexo相关 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>测试文章</title>
      <link href="/DoublePeach/myblog/2022/08/19/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/"/>
      <url>/DoublePeach/myblog/2022/08/19/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<p>测试一下图片导入功能~~~</p><h2 id="第一种："><a href="#第一种：" class="headerlink" title="第一种："></a>第一种：</h2><p><img src="/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/f9f8b97b92235fab9a07cd98af74c133.png"></p><h2 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h2><img src="/2022/08/19/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/f9f8b97b92235fab9a07cd98af74c133.png" class title="图片"><p>测试完成，第一种不能显示图片，第二种可以<br>（要注意：md文件和资源文件不在同一个文件夹下，而是关联关系）</p>]]></content>
      
      
      <categories>
          
          <category> 测试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>代码演示</title>
      <link href="/DoublePeach/myblog/2022/08/16/%E4%BB%A3%E7%A0%81%E5%9D%97%E6%BC%94%E7%A4%BA/%E6%BC%94%E7%A4%BA/"/>
      <url>/DoublePeach/myblog/2022/08/16/%E4%BB%A3%E7%A0%81%E5%9D%97%E6%BC%94%E7%A4%BA/%E6%BC%94%E7%A4%BA/</url>
      
        <content type="html"><![CDATA[<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">x</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/DoublePeach/myblog/2022/08/10/hello-world/"/>
      <url>/DoublePeach/myblog/2022/08/10/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
